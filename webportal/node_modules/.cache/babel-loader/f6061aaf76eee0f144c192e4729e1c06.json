{"ast":null,"code":"/*\n Highcharts JS v8.2.0 (2020-08-20)\n\n (c) 2009-2018 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (T, O) {\n  \"object\" === typeof module && module.exports ? (O[\"default\"] = O, module.exports = T.document ? O(T) : O) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts\", function () {\n    return O(T);\n  }) : (T.Highcharts && T.Highcharts.error(16, !0), T.Highcharts = O(T));\n})(\"undefined\" !== typeof window ? window : this, function (T) {\n  function O(f, a, S, y) {\n    f.hasOwnProperty(a) || (f[a] = y.apply(null, S));\n  }\n\n  var n = {};\n  O(n, \"Core/Globals.js\", [], function () {\n    var f = \"undefined\" !== typeof T ? T : \"undefined\" !== typeof window ? window : {},\n        a = f.document,\n        S = f.navigator && f.navigator.userAgent || \"\",\n        y = a && a.createElementNS && !!a.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        n = /(edge|msie|trident)/i.test(S) && !f.opera,\n        G = -1 !== S.indexOf(\"Firefox\"),\n        C = -1 !== S.indexOf(\"Chrome\"),\n        J = G && 4 > parseInt(S.split(\"Firefox/\")[1], 10);\n    return {\n      product: \"Highcharts\",\n      version: \"8.2.0\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: a,\n      hasBidiBug: J,\n      hasTouch: !!f.TouchEvent,\n      isMS: n,\n      isWebKit: -1 !== S.indexOf(\"AppleWebKit\"),\n      isFirefox: G,\n      isChrome: C,\n      isSafari: !C && -1 !== S.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(S),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      symbolSizes: {},\n      svg: y,\n      win: f,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: function noop() {},\n      charts: [],\n      dateFormats: {}\n    };\n  });\n  O(n, \"Core/Utilities.js\", [n[\"Core/Globals.js\"]], function (f) {\n    function a(b, c, e, d) {\n      var z = c ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === b && (b = z + \": Deprecated member\");\n      var w = I(b),\n          g = w ? z + \" #\" + b + \": www.highcharts.com/errors/\" + b + \"/\" : b.toString();\n\n      z = function z() {\n        if (c) throw Error(g);\n        v.console && -1 === a.messages.indexOf(g) && console.log(g);\n      };\n\n      if (\"undefined\" !== typeof d) {\n        var k = \"\";\n        w && (g += \"?\");\n        U(d, function (b, c) {\n          k += \"\\n - \" + c + \": \" + b;\n          w && (g += encodeURI(c) + \"=\" + encodeURI(b));\n        });\n        g += k;\n      }\n\n      e ? ea(e, \"displayError\", {\n        code: b,\n        message: g,\n        params: d\n      }, z) : z();\n      a.messages.push(g);\n    }\n\n    function S() {\n      var b,\n          c = arguments,\n          e = {},\n          d = function d(b, c) {\n        \"object\" !== typeof b && (b = {});\n        U(c, function (e, z) {\n          !y(e, !0) || t(e) || p(e) ? b[z] = c[z] : b[z] = d(b[z] || {}, e);\n        });\n        return b;\n      };\n\n      !0 === c[0] && (e = c[1], c = Array.prototype.slice.call(c, 2));\n      var z = c.length;\n\n      for (b = 0; b < z; b++) {\n        e = d(e, c[b]);\n      }\n\n      return e;\n    }\n\n    function y(b, c) {\n      return !!b && \"object\" === typeof b && (!c || !E(b));\n    }\n\n    function n(b, c, e) {\n      var d;\n      K(c) ? m(e) ? b.setAttribute(c, e) : b && b.getAttribute && ((d = b.getAttribute(c)) || \"class\" !== c || (d = b.getAttribute(c + \"Name\"))) : U(c, function (c, e) {\n        b.setAttribute(e, c);\n      });\n      return d;\n    }\n\n    function G() {\n      for (var b = arguments, c = b.length, e = 0; e < c; e++) {\n        var d = b[e];\n        if (\"undefined\" !== typeof d && null !== d) return d;\n      }\n    }\n\n    function C(b, c) {\n      if (!b) return c;\n      var e = b.split(\".\").reverse();\n      if (1 === e.length) return c[b];\n\n      for (b = e.pop(); \"undefined\" !== typeof b && \"undefined\" !== typeof c && null !== c;) {\n        c = c[b], b = e.pop();\n      }\n\n      return c;\n    }\n\n    f.timers = [];\n    var J = f.charts,\n        H = f.doc,\n        v = f.win;\n    (a || (a = {})).messages = [];\n    f.error = a;\n\n    var L = function () {\n      function b(b, c, e) {\n        this.options = c;\n        this.elem = b;\n        this.prop = e;\n      }\n\n      b.prototype.dSetter = function () {\n        var b = this.paths,\n            c = b && b[0];\n        b = b && b[1];\n        var e = [],\n            d = this.now || 0;\n        if (1 !== d && c && b) {\n          if (c.length === b.length && 1 > d) for (var z = 0; z < b.length; z++) {\n            for (var w = c[z], g = b[z], k = [], h = 0; h < g.length; h++) {\n              var P = w[h],\n                  l = g[h];\n              k[h] = \"number\" === typeof P && \"number\" === typeof l && (\"A\" !== g[0] || 4 !== h && 5 !== h) ? P + d * (l - P) : l;\n            }\n\n            e.push(k);\n          } else e = b;\n        } else e = this.toD || [];\n        this.elem.attr(\"d\", e, void 0, !0);\n      };\n\n      b.prototype.update = function () {\n        var b = this.elem,\n            c = this.prop,\n            e = this.now,\n            d = this.options.step;\n        if (this[c + \"Setter\"]) this[c + \"Setter\"]();else b.attr ? b.element && b.attr(c, e, null, !0) : b.style[c] = e + this.unit;\n        d && d.call(b, e, this);\n      };\n\n      b.prototype.run = function (b, c, e) {\n        var d = this,\n            z = d.options,\n            w = function w(b) {\n          return w.stopped ? !1 : d.step(b);\n        },\n            g = v.requestAnimationFrame || function (b) {\n          setTimeout(b, 13);\n        },\n            h = function h() {\n          for (var b = 0; b < f.timers.length; b++) {\n            f.timers[b]() || f.timers.splice(b--, 1);\n          }\n\n          f.timers.length && g(h);\n        };\n\n        b !== c || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = b, this.end = c, this.unit = e, this.now = this.start, this.pos = 0, w.elem = this.elem, w.prop = this.prop, w() && 1 === f.timers.push(w) && g(h)) : (delete z.curAnim[this.prop], z.complete && 0 === Object.keys(z.curAnim).length && z.complete.call(this.elem));\n      };\n\n      b.prototype.step = function (b) {\n        var c = +new Date(),\n            e = this.options,\n            d = this.elem,\n            z = e.complete,\n            w = e.duration,\n            g = e.curAnim;\n        if (d.attr && !d.element) b = !1;else if (b || c >= w + this.startTime) {\n          this.now = this.end;\n          this.pos = 1;\n          this.update();\n          var h = g[this.prop] = !0;\n          U(g, function (b) {\n            !0 !== b && (h = !1);\n          });\n          h && z && z.call(d);\n          b = !1;\n        } else this.pos = e.easing((c - this.startTime) / w), this.now = this.start + (this.end - this.start) * this.pos, this.update(), b = !0;\n        return b;\n      };\n\n      b.prototype.initPath = function (b, c, e) {\n        function d(b, c) {\n          for (; b.length < r;) {\n            var e = b[0],\n                d = c[r - b.length];\n            d && \"M\" === e[0] && (b[0] = \"C\" === d[0] ? [\"C\", e[1], e[2], e[1], e[2], e[1], e[2]] : [\"L\", e[1], e[2]]);\n            b.unshift(e);\n            h && b.push(b[b.length - 1]);\n          }\n        }\n\n        function z(b, c) {\n          for (; b.length < r;) {\n            if (c = b[b.length / k - 1].slice(), \"C\" === c[0] && (c[1] = c[5], c[2] = c[6]), h) {\n              var e = b[b.length / k].slice();\n              b.splice(b.length / 2, 0, c, e);\n            } else b.push(c);\n          }\n        }\n\n        var w = b.startX,\n            g = b.endX;\n        c = c && c.slice();\n        e = e.slice();\n        var h = b.isArea,\n            k = h ? 2 : 1;\n        if (!c) return [e, e];\n\n        if (w && g) {\n          for (b = 0; b < w.length; b++) {\n            if (w[b] === g[0]) {\n              var P = b;\n              break;\n            } else if (w[0] === g[g.length - w.length + b]) {\n              P = b;\n              var l = !0;\n              break;\n            } else if (w[w.length - 1] === g[g.length - w.length + b]) {\n              P = w.length - b;\n              break;\n            }\n          }\n\n          \"undefined\" === typeof P && (c = []);\n        }\n\n        if (c.length && I(P)) {\n          var r = e.length + P * k;\n          l ? (d(c, e), z(e, c)) : (d(e, c), z(c, e));\n        }\n\n        return [c, e];\n      };\n\n      b.prototype.fillSetter = function () {\n        b.prototype.strokeSetter.apply(this, arguments);\n      };\n\n      b.prototype.strokeSetter = function () {\n        this.elem.attr(this.prop, f.color(this.start).tweenTo(f.color(this.end), this.pos), null, !0);\n      };\n\n      return b;\n    }();\n\n    f.Fx = L;\n    f.merge = S;\n\n    var q = f.pInt = function (b, c) {\n      return parseInt(b, c || 10);\n    },\n        K = f.isString = function (b) {\n      return \"string\" === typeof b;\n    },\n        E = f.isArray = function (b) {\n      b = Object.prototype.toString.call(b);\n      return \"[object Array]\" === b || \"[object Array Iterator]\" === b;\n    };\n\n    f.isObject = y;\n\n    var p = f.isDOMElement = function (b) {\n      return y(b) && \"number\" === typeof b.nodeType;\n    },\n        t = f.isClass = function (b) {\n      var c = b && b.constructor;\n      return !(!y(b, !0) || p(b) || !c || !c.name || \"Object\" === c.name);\n    },\n        I = f.isNumber = function (b) {\n      return \"number\" === typeof b && !isNaN(b) && Infinity > b && -Infinity < b;\n    },\n        u = f.erase = function (b, c) {\n      for (var e = b.length; e--;) {\n        if (b[e] === c) {\n          b.splice(e, 1);\n          break;\n        }\n      }\n    },\n        m = f.defined = function (b) {\n      return \"undefined\" !== typeof b && null !== b;\n    };\n\n    f.attr = n;\n\n    var h = f.splat = function (b) {\n      return E(b) ? b : [b];\n    },\n        l = f.syncTimeout = function (b, c, e) {\n      if (0 < c) return setTimeout(b, c, e);\n      b.call(0, e);\n      return -1;\n    },\n        k = f.clearTimeout = function (b) {\n      m(b) && clearTimeout(b);\n    },\n        g = f.extend = function (b, c) {\n      var e;\n      b || (b = {});\n\n      for (e in c) {\n        b[e] = c[e];\n      }\n\n      return b;\n    };\n\n    f.pick = G;\n\n    var d = f.css = function (b, c) {\n      f.isMS && !f.svg && c && \"undefined\" !== typeof c.opacity && (c.filter = \"alpha(opacity=\" + 100 * c.opacity + \")\");\n      g(b.style, c);\n    },\n        x = f.createElement = function (b, c, e, z, w) {\n      b = H.createElement(b);\n      c && g(b, c);\n      w && d(b, {\n        padding: \"0\",\n        border: \"none\",\n        margin: \"0\"\n      });\n      e && d(b, e);\n      z && z.appendChild(b);\n      return b;\n    },\n        r = f.extendClass = function (b, c) {\n      var e = function e() {};\n\n      e.prototype = new b();\n      g(e.prototype, c);\n      return e;\n    },\n        A = f.pad = function (b, c, e) {\n      return Array((c || 2) + 1 - String(b).replace(\"-\", \"\").length).join(e || \"0\") + b;\n    },\n        N = f.relativeLength = function (b, c, e) {\n      return /%$/.test(b) ? c * parseFloat(b) / 100 + (e || 0) : parseFloat(b);\n    },\n        B = f.wrap = function (b, c, e) {\n      var d = b[c];\n\n      b[c] = function () {\n        var b = Array.prototype.slice.call(arguments),\n            c = arguments,\n            z = this;\n\n        z.proceed = function () {\n          d.apply(z, arguments.length ? arguments : c);\n        };\n\n        b.unshift(d);\n        b = e.apply(this, b);\n        z.proceed = null;\n        return b;\n      };\n    },\n        M = f.format = function (b, c, e) {\n      var d = \"{\",\n          z = !1,\n          w = [],\n          g = /f$/,\n          h = /\\.([0-9])/,\n          k = f.defaultOptions.lang,\n          P = e && e.time || f.time;\n\n      for (e = e && e.numberFormatter || X; b;) {\n        var l = b.indexOf(d);\n        if (-1 === l) break;\n        var r = b.slice(0, l);\n\n        if (z) {\n          r = r.split(\":\");\n          d = C(r.shift() || \"\", c);\n          if (r.length && \"number\" === typeof d) if (r = r.join(\":\"), g.test(r)) {\n            var m = parseInt((r.match(h) || [\"\", \"-1\"])[1], 10);\n            null !== d && (d = e(d, m, k.decimalPoint, -1 < r.indexOf(\",\") ? k.thousandsSep : \"\"));\n          } else d = P.dateFormat(r, d);\n          w.push(d);\n        } else w.push(r);\n\n        b = b.slice(l + 1);\n        d = (z = !z) ? \"}\" : \"{\";\n      }\n\n      w.push(b);\n      return w.join(\"\");\n    },\n        R = f.getMagnitude = function (b) {\n      return Math.pow(10, Math.floor(Math.log(b) / Math.LN10));\n    },\n        F = f.normalizeTickInterval = function (b, c, e, d, z) {\n      var w = b;\n      e = G(e, 1);\n      var g = b / e;\n      c || (c = z ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === d && (1 === e ? c = c.filter(function (b) {\n        return 0 === b % 1;\n      }) : .1 >= e && (c = [1 / e])));\n\n      for (d = 0; d < c.length && !(w = c[d], z && w * e >= b || !z && g <= (c[d] + (c[d + 1] || c[d])) / 2); d++) {\n        ;\n      }\n\n      return w = P(w * e, -Math.round(Math.log(.001) / Math.LN10));\n    },\n        e = f.stableSort = function (b, c) {\n      var e = b.length,\n          d,\n          z;\n\n      for (z = 0; z < e; z++) {\n        b[z].safeI = z;\n      }\n\n      b.sort(function (b, e) {\n        d = c(b, e);\n        return 0 === d ? b.safeI - e.safeI : d;\n      });\n\n      for (z = 0; z < e; z++) {\n        delete b[z].safeI;\n      }\n    },\n        c = f.arrayMin = function (b) {\n      for (var c = b.length, e = b[0]; c--;) {\n        b[c] < e && (e = b[c]);\n      }\n\n      return e;\n    },\n        b = f.arrayMax = function (b) {\n      for (var c = b.length, e = b[0]; c--;) {\n        b[c] > e && (e = b[c]);\n      }\n\n      return e;\n    },\n        z = f.destroyObjectProperties = function (b, c) {\n      U(b, function (e, d) {\n        e && e !== c && e.destroy && e.destroy();\n        delete b[d];\n      });\n    },\n        w = f.discardElement = function (b) {\n      var c = f.garbageBin;\n      c || (c = x(\"div\"));\n      b && c.appendChild(b);\n      c.innerHTML = \"\";\n    },\n        P = f.correctFloat = function (b, c) {\n      return parseFloat(b.toPrecision(c || 14));\n    },\n        Z = f.setAnimation = function (b, c) {\n      c.renderer.globalAnimation = G(b, c.options.chart.animation, !0);\n    },\n        W = f.animObject = function (b) {\n      return y(b) ? f.merge({\n        duration: 500,\n        defer: 0\n      }, b) : {\n        duration: b ? 500 : 0,\n        defer: 0\n      };\n    },\n        aa = f.timeUnits = {\n      millisecond: 1,\n      second: 1E3,\n      minute: 6E4,\n      hour: 36E5,\n      day: 864E5,\n      week: 6048E5,\n      month: 24192E5,\n      year: 314496E5\n    },\n        X = f.numberFormat = function (b, c, e, d) {\n      b = +b || 0;\n      c = +c;\n      var z = f.defaultOptions.lang,\n          w = (b.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          g = b.toString().split(\"e\");\n      if (-1 === c) c = Math.min(w, 20);else if (!I(c)) c = 2;else if (c && g[1] && 0 > g[1]) {\n        var h = c + +g[1];\n        0 <= h ? (g[0] = (+g[0]).toExponential(h).split(\"e\")[0], c = h) : (g[0] = g[0].split(\".\")[0] || 0, b = 20 > c ? (g[0] * Math.pow(10, g[1])).toFixed(c) : 0, g[1] = 0);\n      }\n      var k = (Math.abs(g[1] ? g[0] : b) + Math.pow(10, -Math.max(c, w) - 1)).toFixed(c);\n      w = String(q(k));\n      h = 3 < w.length ? w.length % 3 : 0;\n      e = G(e, z.decimalPoint);\n      d = G(d, z.thousandsSep);\n      b = (0 > b ? \"-\" : \"\") + (h ? w.substr(0, h) + d : \"\");\n      b += w.substr(h).replace(/(\\d{3})(?=\\d)/g, \"$1\" + d);\n      c && (b += e + k.slice(-c));\n      g[1] && 0 !== +b && (b += \"e\" + g[1]);\n      return b;\n    };\n\n    Math.easeInOutSine = function (b) {\n      return -.5 * (Math.cos(Math.PI * b) - 1);\n    };\n\n    var ba = f.getStyle = function (b, c, e) {\n      if (\"width\" === c) return c = Math.min(b.offsetWidth, b.scrollWidth), e = b.getBoundingClientRect && b.getBoundingClientRect().width, e < c && e >= c - 1 && (c = Math.floor(e)), Math.max(0, c - f.getStyle(b, \"padding-left\") - f.getStyle(b, \"padding-right\"));\n      if (\"height\" === c) return Math.max(0, Math.min(b.offsetHeight, b.scrollHeight) - f.getStyle(b, \"padding-top\") - f.getStyle(b, \"padding-bottom\"));\n      v.getComputedStyle || a(27, !0);\n      if (b = v.getComputedStyle(b, void 0)) b = b.getPropertyValue(c), G(e, \"opacity\" !== c) && (b = q(b));\n      return b;\n    },\n        ca = f.getDeferredAnimation = function (b, c, e) {\n      var d = W(c),\n          z = 0,\n          w = 0;\n      (e ? [e] : b.series).forEach(function (b) {\n        b = W(b.options.animation);\n        z = c && m(c.defer) ? d.defer : Math.max(z, b.duration + b.defer);\n        w = Math.min(d.duration, b.duration);\n      });\n      b.renderer.forExport && (z = 0);\n      return {\n        defer: Math.max(0, z - w),\n        duration: Math.min(z, w)\n      };\n    },\n        Y = f.inArray = function (b, c, e) {\n      a(32, !1, void 0, {\n        \"Highcharts.inArray\": \"use Array.indexOf\"\n      });\n      return c.indexOf(b, e);\n    },\n        V = f.find = Array.prototype.find ? function (b, c) {\n      return b.find(c);\n    } : function (b, c) {\n      var e,\n          d = b.length;\n\n      for (e = 0; e < d; e++) {\n        if (c(b[e], e)) return b[e];\n      }\n    };\n\n    f.keys = function (b) {\n      a(32, !1, void 0, {\n        \"Highcharts.keys\": \"use Object.keys\"\n      });\n      return Object.keys(b);\n    };\n\n    var Q = f.offset = function (b) {\n      var c = H.documentElement;\n      b = b.parentElement || b.parentNode ? b.getBoundingClientRect() : {\n        top: 0,\n        left: 0\n      };\n      return {\n        top: b.top + (v.pageYOffset || c.scrollTop) - (c.clientTop || 0),\n        left: b.left + (v.pageXOffset || c.scrollLeft) - (c.clientLeft || 0)\n      };\n    },\n        fa = f.stop = function (b, c) {\n      for (var e = f.timers.length; e--;) {\n        f.timers[e].elem !== b || c && c !== f.timers[e].prop || (f.timers[e].stopped = !0);\n      }\n    },\n        U = f.objectEach = function (b, c, e) {\n      for (var d in b) {\n        Object.hasOwnProperty.call(b, d) && c.call(e || b[d], b[d], d, b);\n      }\n    };\n\n    U({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (b, c) {\n      f[c] = function (e) {\n        var d;\n        a(32, !1, void 0, (d = {}, d[\"Highcharts.\" + c] = \"use Array.\" + b, d));\n        return Array.prototype[b].apply(e, [].slice.call(arguments, 1));\n      };\n    });\n\n    var ja = f.addEvent = function (b, c, e, d) {\n      void 0 === d && (d = {});\n      var z = b.addEventListener || f.addEventListenerPolyfill;\n      var w = \"function\" === typeof b && b.prototype ? b.prototype.protoEvents = b.prototype.protoEvents || {} : b.hcEvents = b.hcEvents || {};\n      f.Point && b instanceof f.Point && b.series && b.series.chart && (b.series.chart.runTrackerClick = !0);\n      z && z.call(b, c, e, !1);\n      w[c] || (w[c] = []);\n      w[c].push({\n        fn: e,\n        order: \"number\" === typeof d.order ? d.order : Infinity\n      });\n      w[c].sort(function (b, c) {\n        return b.order - c.order;\n      });\n      return function () {\n        ha(b, c, e);\n      };\n    },\n        ha = f.removeEvent = function (b, c, e) {\n      function d(c, e) {\n        var d = b.removeEventListener || f.removeEventListenerPolyfill;\n        d && d.call(b, c, e, !1);\n      }\n\n      function z(e) {\n        var z;\n\n        if (b.nodeName) {\n          if (c) {\n            var w = {};\n            w[c] = !0;\n          } else w = e;\n\n          U(w, function (b, c) {\n            if (e[c]) for (z = e[c].length; z--;) {\n              d(c, e[c][z].fn);\n            }\n          });\n        }\n      }\n\n      var w;\n      [\"protoEvents\", \"hcEvents\"].forEach(function (g, h) {\n        var k = (h = h ? b : b.prototype) && h[g];\n        k && (c ? (w = k[c] || [], e ? (k[c] = w.filter(function (b) {\n          return e !== b.fn;\n        }), d(c, e)) : (z(k), k[c] = [])) : (z(k), h[g] = {}));\n      });\n    },\n        ea = f.fireEvent = function (b, c, e, d) {\n      var z;\n      e = e || {};\n\n      if (H.createEvent && (b.dispatchEvent || b.fireEvent)) {\n        var w = H.createEvent(\"Events\");\n        w.initEvent(c, !0, !0);\n        g(w, e);\n        b.dispatchEvent ? b.dispatchEvent(w) : b.fireEvent(c, w);\n      } else e.target || g(e, {\n        preventDefault: function preventDefault() {\n          e.defaultPrevented = !0;\n        },\n        target: b,\n        type: c\n      }), function (c, d) {\n        void 0 === c && (c = []);\n        void 0 === d && (d = []);\n        var w = 0,\n            g = 0,\n            h = c.length + d.length;\n\n        for (z = 0; z < h; z++) {\n          !1 === (c[w] ? d[g] ? c[w].order <= d[g].order ? c[w++] : d[g++] : c[w++] : d[g++]).fn.call(b, e) && e.preventDefault();\n        }\n      }(b.protoEvents && b.protoEvents[c], b.hcEvents && b.hcEvents[c]);\n\n      d && !e.defaultPrevented && d.call(b, e);\n    },\n        ka = f.animate = function (b, c, e) {\n      var d,\n          z = \"\",\n          w,\n          g;\n\n      if (!y(e)) {\n        var h = arguments;\n        e = {\n          duration: h[2],\n          easing: h[3],\n          complete: h[4]\n        };\n      }\n\n      I(e.duration) || (e.duration = 400);\n      e.easing = \"function\" === typeof e.easing ? e.easing : Math[e.easing] || Math.easeInOutSine;\n      e.curAnim = S(c);\n      U(c, function (h, k) {\n        fa(b, k);\n        g = new L(b, e, k);\n        w = null;\n        \"d\" === k && E(c.d) ? (g.paths = g.initPath(b, b.pathArray, c.d), g.toD = c.d, d = 0, w = 1) : b.attr ? d = b.attr(k) : (d = parseFloat(ba(b, k)) || 0, \"opacity\" !== k && (z = \"px\"));\n        w || (w = h);\n        w && w.match && w.match(\"px\") && (w = w.replace(/px/g, \"\"));\n        g.run(d, w, z);\n      });\n    },\n        la = f.seriesType = function (b, c, e, d, z) {\n      var w = ia(),\n          g = f.seriesTypes;\n      w.plotOptions[b] = S(w.plotOptions[c], e);\n      g[b] = r(g[c] || function () {}, d);\n      g[b].prototype.type = b;\n      z && (g[b].prototype.pointClass = r(f.Point, z));\n      return g[b];\n    },\n        da,\n        ma = f.uniqueKey = function () {\n      var b = Math.random().toString(36).substring(2, 9) + \"-\",\n          c = 0;\n      return function () {\n        return \"highcharts-\" + (da ? \"\" : b) + c++;\n      };\n    }(),\n        O = f.useSerialIds = function (b) {\n      return da = G(b, da);\n    },\n        na = f.isFunction = function (b) {\n      return \"function\" === typeof b;\n    },\n        ia = f.getOptions = function () {\n      return f.defaultOptions;\n    },\n        oa = f.setOptions = function (b) {\n      f.defaultOptions = S(!0, f.defaultOptions, b);\n      (b.time || b.global) && f.time.update(S(f.defaultOptions.global, f.defaultOptions.time, b.global, b.time));\n      return f.defaultOptions;\n    };\n\n    v.jQuery && (v.jQuery.fn.highcharts = function () {\n      var b = [].slice.call(arguments);\n      if (this[0]) return b[0] ? (new f[K(b[0]) ? b.shift() : \"Chart\"](this[0], b[0], b[1]), this) : J[n(this[0], \"data-highcharts-chart\")];\n    });\n    return {\n      Fx: f.Fx,\n      addEvent: ja,\n      animate: ka,\n      animObject: W,\n      arrayMax: b,\n      arrayMin: c,\n      attr: n,\n      clamp: function clamp(b, c, e) {\n        return b > c ? b < e ? b : e : c;\n      },\n      clearTimeout: k,\n      correctFloat: P,\n      createElement: x,\n      css: d,\n      defined: m,\n      destroyObjectProperties: z,\n      discardElement: w,\n      erase: u,\n      error: a,\n      extend: g,\n      extendClass: r,\n      find: V,\n      fireEvent: ea,\n      format: M,\n      getDeferredAnimation: ca,\n      getMagnitude: R,\n      getNestedProperty: C,\n      getOptions: ia,\n      getStyle: ba,\n      inArray: Y,\n      isArray: E,\n      isClass: t,\n      isDOMElement: p,\n      isFunction: na,\n      isNumber: I,\n      isObject: y,\n      isString: K,\n      merge: S,\n      normalizeTickInterval: F,\n      numberFormat: X,\n      objectEach: U,\n      offset: Q,\n      pad: A,\n      pick: G,\n      pInt: q,\n      relativeLength: N,\n      removeEvent: ha,\n      seriesType: la,\n      setAnimation: Z,\n      setOptions: oa,\n      splat: h,\n      stableSort: e,\n      stop: fa,\n      syncTimeout: l,\n      timeUnits: aa,\n      uniqueKey: ma,\n      useSerialIds: O,\n      wrap: B\n    };\n  });\n  O(n, \"Core/Color.js\", [n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var S = a.isNumber,\n        y = a.merge,\n        n = a.pInt;\n\n    a = function () {\n      function a(f) {\n        this.parsers = [{\n          regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n          parse: function parse(a) {\n            return [n(a[1]), n(a[2]), n(a[3]), parseFloat(a[4], 10)];\n          }\n        }, {\n          regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n          parse: function parse(a) {\n            return [n(a[1]), n(a[2]), n(a[3]), 1];\n          }\n        }];\n        this.rgba = [];\n        if (!(this instanceof a)) return new a(f);\n        this.init(f);\n      }\n\n      a.parse = function (f) {\n        return new a(f);\n      };\n\n      a.prototype.init = function (f) {\n        var J, H;\n        if ((this.input = f = a.names[f && f.toLowerCase ? f.toLowerCase() : \"\"] || f) && f.stops) this.stops = f.stops.map(function (q) {\n          return new a(q[1]);\n        });else {\n          if (f && f.charAt && \"#\" === f.charAt()) {\n            var v = f.length;\n            f = parseInt(f.substr(1), 16);\n            7 === v ? J = [(f & 16711680) >> 16, (f & 65280) >> 8, f & 255, 1] : 4 === v && (J = [(f & 3840) >> 4 | (f & 3840) >> 8, (f & 240) >> 4 | f & 240, (f & 15) << 4 | f & 15, 1]);\n          }\n\n          if (!J) for (H = this.parsers.length; H-- && !J;) {\n            var L = this.parsers[H];\n            (v = L.regex.exec(f)) && (J = L.parse(v));\n          }\n        }\n        this.rgba = J || [];\n      };\n\n      a.prototype.get = function (a) {\n        var f = this.input,\n            H = this.rgba;\n\n        if (\"undefined\" !== typeof this.stops) {\n          var v = y(f);\n          v.stops = [].concat(v.stops);\n          this.stops.forEach(function (f, q) {\n            v.stops[q] = [v.stops[q][0], f.get(a)];\n          });\n        } else v = H && S(H[0]) ? \"rgb\" === a || !a && 1 === H[3] ? \"rgb(\" + H[0] + \",\" + H[1] + \",\" + H[2] + \")\" : \"a\" === a ? H[3] : \"rgba(\" + H.join(\",\") + \")\" : f;\n\n        return v;\n      };\n\n      a.prototype.brighten = function (a) {\n        var f,\n            H = this.rgba;\n        if (this.stops) this.stops.forEach(function (f) {\n          f.brighten(a);\n        });else if (S(a) && 0 !== a) for (f = 0; 3 > f; f++) {\n          H[f] += n(255 * a), 0 > H[f] && (H[f] = 0), 255 < H[f] && (H[f] = 255);\n        }\n        return this;\n      };\n\n      a.prototype.setOpacity = function (a) {\n        this.rgba[3] = a;\n        return this;\n      };\n\n      a.prototype.tweenTo = function (a, f) {\n        var H = this.rgba,\n            v = a.rgba;\n        v.length && H && H.length ? (a = 1 !== v[3] || 1 !== H[3], f = (a ? \"rgba(\" : \"rgb(\") + Math.round(v[0] + (H[0] - v[0]) * (1 - f)) + \",\" + Math.round(v[1] + (H[1] - v[1]) * (1 - f)) + \",\" + Math.round(v[2] + (H[2] - v[2]) * (1 - f)) + (a ? \",\" + (v[3] + (H[3] - v[3]) * (1 - f)) : \"\") + \")\") : f = a.input || \"none\";\n        return f;\n      };\n\n      a.names = {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      };\n      return a;\n    }();\n\n    f.Color = a;\n    f.color = a.parse;\n    return f.Color;\n  });\n  O(n, \"Core/Renderer/SVG/SVGElement.js\", [n[\"Core/Color.js\"], n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a, n) {\n    var y = a.deg2rad,\n        D = a.doc,\n        G = a.hasTouch,\n        C = a.isFirefox,\n        J = a.noop,\n        H = a.svg,\n        v = a.SVG_NS,\n        L = a.win,\n        q = n.animate,\n        K = n.animObject,\n        E = n.attr,\n        p = n.createElement,\n        t = n.css,\n        I = n.defined,\n        u = n.erase,\n        m = n.extend,\n        h = n.fireEvent,\n        l = n.isArray,\n        k = n.isFunction,\n        g = n.isNumber,\n        d = n.isString,\n        x = n.merge,\n        r = n.objectEach,\n        A = n.pick,\n        N = n.pInt,\n        B = n.stop,\n        M = n.syncTimeout,\n        R = n.uniqueKey;\n    \"\";\n\n    n = function () {\n      function F() {\n        this.height = this.element = void 0;\n        this.opacity = 1;\n        this.renderer = void 0;\n        this.SVG_NS = v;\n        this.symbolCustomAttribs = \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \");\n        this.width = void 0;\n      }\n\n      F.prototype._defaultGetter = function (e) {\n        e = A(this[e + \"Value\"], this[e], this.element ? this.element.getAttribute(e) : null, 0);\n        /^[\\-0-9\\.]+$/.test(e) && (e = parseFloat(e));\n        return e;\n      };\n\n      F.prototype._defaultSetter = function (e, c, b) {\n        b.setAttribute(c, e);\n      };\n\n      F.prototype.add = function (e) {\n        var c = this.renderer,\n            b = this.element;\n        e && (this.parentGroup = e);\n        this.parentInverted = e && e.inverted;\n        \"undefined\" !== typeof this.textStr && \"text\" === this.element.nodeName && c.buildText(this);\n        this.added = !0;\n        if (!e || e.handleZ || this.zIndex) var d = this.zIndexSetter();\n        d || (e ? e.element : c.box).appendChild(b);\n        if (this.onAdd) this.onAdd();\n        return this;\n      };\n\n      F.prototype.addClass = function (e, c) {\n        var b = c ? \"\" : this.attr(\"class\") || \"\";\n        e = (e || \"\").split(/ /g).reduce(function (c, e) {\n          -1 === b.indexOf(e) && c.push(e);\n          return c;\n        }, b ? [b] : []).join(\" \");\n        e !== b && this.attr(\"class\", e);\n        return this;\n      };\n\n      F.prototype.afterSetters = function () {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      };\n\n      F.prototype.align = function (e, c, b) {\n        var z,\n            w = {};\n        var g = this.renderer;\n        var h = g.alignedObjects;\n        var k, l;\n\n        if (e) {\n          if (this.alignOptions = e, this.alignByTranslate = c, !b || d(b)) this.alignTo = z = b || \"renderer\", u(h, this), h.push(this), b = void 0;\n        } else e = this.alignOptions, c = this.alignByTranslate, z = this.alignTo;\n\n        b = A(b, g[z], g);\n        z = e.align;\n        g = e.verticalAlign;\n        h = (b.x || 0) + (e.x || 0);\n        var r = (b.y || 0) + (e.y || 0);\n        \"right\" === z ? k = 1 : \"center\" === z && (k = 2);\n        k && (h += (b.width - (e.width || 0)) / k);\n        w[c ? \"translateX\" : \"x\"] = Math.round(h);\n        \"bottom\" === g ? l = 1 : \"middle\" === g && (l = 2);\n        l && (r += (b.height - (e.height || 0)) / l);\n        w[c ? \"translateY\" : \"y\"] = Math.round(r);\n        this[this.placed ? \"animate\" : \"attr\"](w);\n        this.placed = !0;\n        this.alignAttr = w;\n        return this;\n      };\n\n      F.prototype.alignSetter = function (e) {\n        var c = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        c[e] && (this.alignValue = e, this.element.setAttribute(\"text-anchor\", c[e]));\n      };\n\n      F.prototype.animate = function (e, c, b) {\n        var d = this,\n            w = K(A(c, this.renderer.globalAnimation, !0));\n        c = w.defer;\n        A(D.hidden, D.msHidden, D.webkitHidden, !1) && (w.duration = 0);\n        0 !== w.duration ? (b && (w.complete = b), M(function () {\n          d.element && q(d, e, w);\n        }, c)) : (this.attr(e, void 0, b), r(e, function (b, c) {\n          w.step && w.step.call(this, b, {\n            prop: c,\n            pos: 1\n          });\n        }, this));\n        return this;\n      };\n\n      F.prototype.applyTextOutline = function (e) {\n        var c = this.element,\n            b;\n        -1 !== e.indexOf(\"contrast\") && (e = e.replace(/contrast/g, this.renderer.getContrast(c.style.fill)));\n        e = e.split(\" \");\n        var d = e[e.length - 1];\n\n        if ((b = e[0]) && \"none\" !== b && a.svg) {\n          this.fakeTS = !0;\n          e = [].slice.call(c.getElementsByTagName(\"tspan\"));\n          this.ySetter = this.xSetter;\n          b = b.replace(/(^[\\d\\.]+)(.*?)$/g, function (b, c, e) {\n            return 2 * c + e;\n          });\n          this.removeTextOutline(e);\n          var w = c.textContent ? /^[\\u0591-\\u065F\\u066A-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC]/.test(c.textContent) : !1;\n          var g = c.firstChild;\n          e.forEach(function (e, z) {\n            0 === z && (e.setAttribute(\"x\", c.getAttribute(\"x\")), z = c.getAttribute(\"y\"), e.setAttribute(\"y\", z || 0), null === z && c.setAttribute(\"y\", 0));\n            z = e.cloneNode(!0);\n            E(w && !C ? e : z, {\n              \"class\": \"highcharts-text-outline\",\n              fill: d,\n              stroke: d,\n              \"stroke-width\": b,\n              \"stroke-linejoin\": \"round\"\n            });\n            c.insertBefore(z, g);\n          });\n          w && C && e[0] && (e = e[0].cloneNode(!0), e.textContent = \" \", c.insertBefore(e, g));\n        }\n      };\n\n      F.prototype.attr = function (e, c, b, d) {\n        var z = this.element,\n            g,\n            h = this,\n            k,\n            l,\n            m = this.symbolCustomAttribs;\n\n        if (\"string\" === typeof e && \"undefined\" !== typeof c) {\n          var x = e;\n          e = {};\n          e[x] = c;\n        }\n\n        \"string\" === typeof e ? h = (this[e + \"Getter\"] || this._defaultGetter).call(this, e, z) : (r(e, function (b, c) {\n          k = !1;\n          d || B(this, c);\n          this.symbolName && -1 !== m.indexOf(c) && (g || (this.symbolAttr(e), g = !0), k = !0);\n          !this.rotation || \"x\" !== c && \"y\" !== c || (this.doTransform = !0);\n          k || (l = this[c + \"Setter\"] || this._defaultSetter, l.call(this, b, c, z), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(c) && this.updateShadows(c, b, l));\n        }, this), this.afterSetters());\n        b && b.call(this);\n        return h;\n      };\n\n      F.prototype.clip = function (e) {\n        return this.attr(\"clip-path\", e ? \"url(\" + this.renderer.url + \"#\" + e.id + \")\" : \"none\");\n      };\n\n      F.prototype.crisp = function (e, c) {\n        c = c || e.strokeWidth || 0;\n        var b = Math.round(c) % 2 / 2;\n        e.x = Math.floor(e.x || this.x || 0) + b;\n        e.y = Math.floor(e.y || this.y || 0) + b;\n        e.width = Math.floor((e.width || this.width || 0) - 2 * b);\n        e.height = Math.floor((e.height || this.height || 0) - 2 * b);\n        I(e.strokeWidth) && (e.strokeWidth = c);\n        return e;\n      };\n\n      F.prototype.complexColor = function (e, c, b) {\n        var d = this.renderer,\n            w,\n            g,\n            k,\n            m,\n            p,\n            B,\n            t,\n            A,\n            u,\n            M,\n            Q = [],\n            F;\n        h(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          e.radialGradient ? g = \"radialGradient\" : e.linearGradient && (g = \"linearGradient\");\n\n          if (g) {\n            k = e[g];\n            p = d.gradients;\n            B = e.stops;\n            u = b.radialReference;\n            l(k) && (e[g] = k = {\n              x1: k[0],\n              y1: k[1],\n              x2: k[2],\n              y2: k[3],\n              gradientUnits: \"userSpaceOnUse\"\n            });\n            \"radialGradient\" === g && u && !I(k.gradientUnits) && (m = k, k = x(k, d.getRadialAttr(u, m), {\n              gradientUnits: \"userSpaceOnUse\"\n            }));\n            r(k, function (b, c) {\n              \"id\" !== c && Q.push(c, b);\n            });\n            r(B, function (b) {\n              Q.push(b);\n            });\n            Q = Q.join(\",\");\n            if (p[Q]) M = p[Q].attr(\"id\");else {\n              k.id = M = R();\n              var z = p[Q] = d.createElement(g).attr(k).add(d.defs);\n              z.radAttr = m;\n              z.stops = [];\n              B.forEach(function (b) {\n                0 === b[1].indexOf(\"rgba\") ? (w = f.parse(b[1]), t = w.get(\"rgb\"), A = w.get(\"a\")) : (t = b[1], A = 1);\n                b = d.createElement(\"stop\").attr({\n                  offset: b[0],\n                  \"stop-color\": t,\n                  \"stop-opacity\": A\n                }).add(z);\n                z.stops.push(b);\n              });\n            }\n            F = \"url(\" + d.url + \"#\" + M + \")\";\n            b.setAttribute(c, F);\n            b.gradient = Q;\n\n            e.toString = function () {\n              return F;\n            };\n          }\n        });\n      };\n\n      F.prototype.css = function (e) {\n        var c = this.styles,\n            b = {},\n            d = this.element,\n            w = \"\",\n            g = !c,\n            k = [\"textOutline\", \"textOverflow\", \"width\"];\n        e && e.color && (e.fill = e.color);\n        c && r(e, function (e, d) {\n          c && c[d] !== e && (b[d] = e, g = !0);\n        });\n\n        if (g) {\n          c && (e = m(c, b));\n          if (e) if (null === e.width || \"auto\" === e.width) delete this.textWidth;else if (\"text\" === d.nodeName.toLowerCase() && e.width) var h = this.textWidth = N(e.width);\n          this.styles = e;\n          h && !H && this.renderer.forExport && delete e.width;\n\n          if (d.namespaceURI === this.SVG_NS) {\n            var l = function l(b, c) {\n              return \"-\" + c.toLowerCase();\n            };\n\n            r(e, function (b, c) {\n              -1 === k.indexOf(c) && (w += c.replace(/([A-Z])/g, l) + \":\" + b + \";\");\n            });\n            w && E(d, \"style\", w);\n          } else t(d, e);\n\n          this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), e && e.textOutline && this.applyTextOutline(e.textOutline));\n        }\n\n        return this;\n      };\n\n      F.prototype.dashstyleSetter = function (e) {\n        var c = this[\"stroke-width\"];\n        \"inherit\" === c && (c = 1);\n\n        if (e = e && e.toLowerCase()) {\n          var b = e.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (e = b.length; e--;) {\n            b[e] = \"\" + N(b[e]) * A(c, NaN);\n          }\n\n          e = b.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", e);\n        }\n      };\n\n      F.prototype.destroy = function () {\n        var e = this,\n            c = e.element || {},\n            b = e.renderer,\n            d = b.isSVG && \"SPAN\" === c.nodeName && e.parentGroup || void 0,\n            w = c.ownerSVGElement;\n        c.onclick = c.onmouseout = c.onmouseover = c.onmousemove = c.point = null;\n        B(e);\n\n        if (e.clipPath && w) {\n          var g = e.clipPath;\n          [].forEach.call(w.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (b) {\n            -1 < b.getAttribute(\"clip-path\").indexOf(g.element.id) && b.removeAttribute(\"clip-path\");\n          });\n          e.clipPath = g.destroy();\n        }\n\n        if (e.stops) {\n          for (w = 0; w < e.stops.length; w++) {\n            e.stops[w].destroy();\n          }\n\n          e.stops.length = 0;\n          e.stops = void 0;\n        }\n\n        e.safeRemoveChild(c);\n\n        for (b.styledMode || e.destroyShadows(); d && d.div && 0 === d.div.childNodes.length;) {\n          c = d.parentGroup, e.safeRemoveChild(d.div), delete d.div, d = c;\n        }\n\n        e.alignTo && u(b.alignedObjects, e);\n        r(e, function (b, c) {\n          e[c] && e[c].parentGroup === e && e[c].destroy && e[c].destroy();\n          delete e[c];\n        });\n      };\n\n      F.prototype.destroyShadows = function () {\n        (this.shadows || []).forEach(function (e) {\n          this.safeRemoveChild(e);\n        }, this);\n        this.shadows = void 0;\n      };\n\n      F.prototype.destroyTextPath = function (e, c) {\n        var b = e.getElementsByTagName(\"text\")[0];\n\n        if (b) {\n          if (b.removeAttribute(\"dx\"), b.removeAttribute(\"dy\"), c.element.setAttribute(\"id\", \"\"), this.textPathWrapper && b.getElementsByTagName(\"textPath\").length) {\n            for (e = this.textPathWrapper.element.childNodes; e.length;) {\n              b.appendChild(e[0]);\n            }\n\n            b.removeChild(this.textPathWrapper.element);\n          }\n        } else if (e.getAttribute(\"dx\") || e.getAttribute(\"dy\")) e.removeAttribute(\"dx\"), e.removeAttribute(\"dy\");\n\n        this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());\n      };\n\n      F.prototype.dSetter = function (e, c, b) {\n        l(e) && (\"string\" === typeof e[0] && (e = this.renderer.pathToSegments(e)), this.pathArray = e, e = e.reduce(function (b, c, e) {\n          return c && c.join ? (e ? b + \" \" : \"\") + c.join(\" \") : (c || \"\").toString();\n        }, \"\"));\n        /(NaN| {2}|^$)/.test(e) && (e = \"M 0 0\");\n        this[c] !== e && (b.setAttribute(c, e), this[c] = e);\n      };\n\n      F.prototype.fadeOut = function (e) {\n        var c = this;\n        c.animate({\n          opacity: 0\n        }, {\n          duration: A(e, 150),\n          complete: function complete() {\n            c.attr({\n              y: -9999\n            }).hide();\n          }\n        });\n      };\n\n      F.prototype.fillSetter = function (e, c, b) {\n        \"string\" === typeof e ? b.setAttribute(c, e) : e && this.complexColor(e, c, b);\n      };\n\n      F.prototype.getBBox = function (e, c) {\n        var b,\n            d = this.renderer,\n            w = this.element,\n            g = this.styles,\n            h = this.textStr,\n            l = d.cache,\n            r = d.cacheKeys,\n            x = w.namespaceURI === this.SVG_NS;\n        c = A(c, this.rotation, 0);\n        var p = d.styledMode ? w && F.prototype.getStyle.call(w, \"font-size\") : g && g.fontSize;\n\n        if (I(h)) {\n          var B = h.toString();\n          -1 === B.indexOf(\"<\") && (B = B.replace(/[0-9]/g, \"0\"));\n          B += [\"\", c, p, this.textWidth, g && g.textOverflow, g && g.fontWeight].join();\n        }\n\n        B && !e && (b = l[B]);\n\n        if (!b) {\n          if (x || d.forExport) {\n            try {\n              var t = this.fakeTS && function (b) {\n                [].forEach.call(w.querySelectorAll(\".highcharts-text-outline\"), function (c) {\n                  c.style.display = b;\n                });\n              };\n\n              k(t) && t(\"none\");\n              b = w.getBBox ? m({}, w.getBBox()) : {\n                width: w.offsetWidth,\n                height: w.offsetHeight\n              };\n              k(t) && t(\"\");\n            } catch (V) {\n              \"\";\n            }\n\n            if (!b || 0 > b.width) b = {\n              width: 0,\n              height: 0\n            };\n          } else b = this.htmlGetBBox();\n\n          d.isSVG && (e = b.width, d = b.height, x && (b.height = d = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[g && g.fontSize + \",\" + Math.round(d)] || d), c && (g = c * y, b.width = Math.abs(d * Math.sin(g)) + Math.abs(e * Math.cos(g)), b.height = Math.abs(d * Math.cos(g)) + Math.abs(e * Math.sin(g))));\n\n          if (B && 0 < b.height) {\n            for (; 250 < r.length;) {\n              delete l[r.shift()];\n            }\n\n            l[B] || r.push(B);\n            l[B] = b;\n          }\n        }\n\n        return b;\n      };\n\n      F.prototype.getStyle = function (e) {\n        return L.getComputedStyle(this.element || this, \"\").getPropertyValue(e);\n      };\n\n      F.prototype.hasClass = function (e) {\n        return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(e);\n      };\n\n      F.prototype.hide = function (e) {\n        e ? this.attr({\n          y: -9999\n        }) : this.attr({\n          visibility: \"hidden\"\n        });\n        return this;\n      };\n\n      F.prototype.htmlGetBBox = function () {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      };\n\n      F.prototype.init = function (e, c) {\n        this.element = \"span\" === c ? p(c) : D.createElementNS(this.SVG_NS, c);\n        this.renderer = e;\n        h(this, \"afterInit\");\n      };\n\n      F.prototype.invert = function (e) {\n        this.inverted = e;\n        this.updateTransform();\n        return this;\n      };\n\n      F.prototype.on = function (e, c) {\n        var b,\n            d,\n            w = this.element,\n            g;\n        G && \"click\" === e ? (w.ontouchstart = function (c) {\n          b = c.touches[0].clientX;\n          d = c.touches[0].clientY;\n        }, w.ontouchend = function (e) {\n          b && 4 <= Math.sqrt(Math.pow(b - e.changedTouches[0].clientX, 2) + Math.pow(d - e.changedTouches[0].clientY, 2)) || c.call(w, e);\n          g = !0;\n          e.preventDefault();\n        }, w.onclick = function (b) {\n          g || c.call(w, b);\n        }) : w[\"on\" + e] = c;\n        return this;\n      };\n\n      F.prototype.opacitySetter = function (e, c, b) {\n        this[c] = e;\n        b.setAttribute(c, e);\n      };\n\n      F.prototype.removeClass = function (e) {\n        return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(d(e) ? new RegExp(\"(^| )\" + e + \"( |$)\") : e, \" \").replace(/ +/g, \" \").trim());\n      };\n\n      F.prototype.removeTextOutline = function (e) {\n        for (var c = e.length, b; c--;) {\n          b = e[c], \"highcharts-text-outline\" === b.getAttribute(\"class\") && u(e, this.element.removeChild(b));\n        }\n      };\n\n      F.prototype.safeRemoveChild = function (e) {\n        var c = e.parentNode;\n        c && c.removeChild(e);\n      };\n\n      F.prototype.setRadialReference = function (e) {\n        var c = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = e;\n        c && c.radAttr && c.animate(this.renderer.getRadialAttr(e, c.radAttr));\n        return this;\n      };\n\n      F.prototype.setTextPath = function (e, c) {\n        var b = this.element,\n            d = {\n          textAnchor: \"text-anchor\"\n        },\n            w = !1,\n            k = this.textPathWrapper,\n            h = !k;\n        c = x(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, c);\n        var l = c.attributes;\n\n        if (e && c && c.enabled) {\n          k && null === k.element.parentNode ? (h = !0, k = k.destroy()) : k && this.removeTextOutline.call(k.parentGroup, [].slice.call(b.getElementsByTagName(\"tspan\")));\n          this.options && this.options.padding && (l.dx = -this.options.padding);\n          k || (this.textPathWrapper = k = this.renderer.createElement(\"textPath\"), w = !0);\n          var m = k.element;\n          (c = e.element.getAttribute(\"id\")) || e.element.setAttribute(\"id\", c = R());\n          if (h) for (e = b.getElementsByTagName(\"tspan\"); e.length;) {\n            e[0].setAttribute(\"y\", 0), g(l.dx) && e[0].setAttribute(\"x\", -l.dx), m.appendChild(e[0]);\n          }\n          w && k && k.add({\n            element: this.text ? this.text.element : b\n          });\n          m.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", this.renderer.url + \"#\" + c);\n          I(l.dy) && (m.parentNode.setAttribute(\"dy\", l.dy), delete l.dy);\n          I(l.dx) && (m.parentNode.setAttribute(\"dx\", l.dx), delete l.dx);\n          r(l, function (b, c) {\n            m.setAttribute(d[c] || c, b);\n          });\n          b.removeAttribute(\"transform\");\n          this.removeTextOutline.call(k, [].slice.call(b.getElementsByTagName(\"tspan\")));\n          this.text && !this.renderer.styledMode && this.attr({\n            fill: \"none\",\n            \"stroke-width\": 0\n          });\n          this.applyTextOutline = this.updateTransform = J;\n        } else k && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(b, e), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));\n\n        return this;\n      };\n\n      F.prototype.shadow = function (e, c, b) {\n        var d = [],\n            g = this.element,\n            k = !1,\n            h = this.oldShadowOptions;\n        var l = {\n          color: \"#000000\",\n          offsetX: 1,\n          offsetY: 1,\n          opacity: .15,\n          width: 3\n        };\n        var x;\n        !0 === e ? x = l : \"object\" === typeof e && (x = m(l, e));\n        x && (x && h && r(x, function (b, c) {\n          b !== h[c] && (k = !0);\n        }), k && this.destroyShadows(), this.oldShadowOptions = x);\n        if (!x) this.destroyShadows();else if (!this.shadows) {\n          var p = x.opacity / x.width;\n          var B = this.parentInverted ? \"translate(-1,-1)\" : \"translate(\" + x.offsetX + \", \" + x.offsetY + \")\";\n\n          for (l = 1; l <= x.width; l++) {\n            var t = g.cloneNode(!1);\n            var A = 2 * x.width + 1 - 2 * l;\n            E(t, {\n              stroke: e.color || \"#000000\",\n              \"stroke-opacity\": p * l,\n              \"stroke-width\": A,\n              transform: B,\n              fill: \"none\"\n            });\n            t.setAttribute(\"class\", (t.getAttribute(\"class\") || \"\") + \" highcharts-shadow\");\n            b && (E(t, \"height\", Math.max(E(t, \"height\") - A, 0)), t.cutHeight = A);\n            c ? c.element.appendChild(t) : g.parentNode && g.parentNode.insertBefore(t, g);\n            d.push(t);\n          }\n\n          this.shadows = d;\n        }\n        return this;\n      };\n\n      F.prototype.show = function (e) {\n        return this.attr({\n          visibility: e ? \"inherit\" : \"visible\"\n        });\n      };\n\n      F.prototype.strokeSetter = function (e, c, b) {\n        this[c] = e;\n        this.stroke && this[\"stroke-width\"] ? (F.prototype.fillSetter.call(this, this.stroke, \"stroke\", b), b.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === c && 0 === e && this.hasStroke ? (b.removeAttribute(\"stroke\"), this.hasStroke = !1) : this.renderer.styledMode && this[\"stroke-width\"] && (b.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0);\n      };\n\n      F.prototype.strokeWidth = function () {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var e = this.getStyle(\"stroke-width\"),\n            c = 0;\n        if (e.indexOf(\"px\") === e.length - 2) c = N(e);else if (\"\" !== e) {\n          var b = D.createElementNS(v, \"rect\");\n          E(b, {\n            width: e,\n            \"stroke-width\": 0\n          });\n          this.element.parentNode.appendChild(b);\n          c = b.getBBox().width;\n          b.parentNode.removeChild(b);\n        }\n        return c;\n      };\n\n      F.prototype.symbolAttr = function (e) {\n        var c = this;\n        \"x y r start end width height innerR anchorX anchorY clockwise\".split(\" \").forEach(function (b) {\n          c[b] = A(e[b], c[b]);\n        });\n        c.attr({\n          d: c.renderer.symbols[c.symbolName](c.x, c.y, c.width, c.height, c)\n        });\n      };\n\n      F.prototype.textSetter = function (e) {\n        e !== this.textStr && (delete this.textPxLength, this.textStr = e, this.added && this.renderer.buildText(this));\n      };\n\n      F.prototype.titleSetter = function (e) {\n        var c = this.element.getElementsByTagName(\"title\")[0];\n        c || (c = D.createElementNS(this.SVG_NS, \"title\"), this.element.appendChild(c));\n        c.firstChild && c.removeChild(c.firstChild);\n        c.appendChild(D.createTextNode(String(A(e, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\")));\n      };\n\n      F.prototype.toFront = function () {\n        var e = this.element;\n        e.parentNode.appendChild(e);\n        return this;\n      };\n\n      F.prototype.translate = function (e, c) {\n        return this.attr({\n          translateX: e,\n          translateY: c\n        });\n      };\n\n      F.prototype.updateShadows = function (e, c, b) {\n        var d = this.shadows;\n        if (d) for (var g = d.length; g--;) {\n          b.call(d[g], \"height\" === e ? Math.max(c - (d[g].cutHeight || 0), 0) : \"d\" === e ? this.d : c, e, d[g]);\n        }\n      };\n\n      F.prototype.updateTransform = function () {\n        var e = this.translateX || 0,\n            c = this.translateY || 0,\n            b = this.scaleX,\n            d = this.scaleY,\n            g = this.inverted,\n            k = this.rotation,\n            h = this.matrix,\n            l = this.element;\n        g && (e += this.width, c += this.height);\n        e = [\"translate(\" + e + \",\" + c + \")\"];\n        I(h) && e.push(\"matrix(\" + h.join(\",\") + \")\");\n        g ? e.push(\"rotate(90) scale(-1,1)\") : k && e.push(\"rotate(\" + k + \" \" + A(this.rotationOriginX, l.getAttribute(\"x\"), 0) + \" \" + A(this.rotationOriginY, l.getAttribute(\"y\") || 0) + \")\");\n        (I(b) || I(d)) && e.push(\"scale(\" + A(b, 1) + \" \" + A(d, 1) + \")\");\n        e.length && l.setAttribute(\"transform\", e.join(\" \"));\n      };\n\n      F.prototype.visibilitySetter = function (e, c, b) {\n        \"inherit\" === e ? b.removeAttribute(c) : this[c] !== e && b.setAttribute(c, e);\n        this[c] = e;\n      };\n\n      F.prototype.xGetter = function (e) {\n        \"circle\" === this.element.nodeName && (\"x\" === e ? e = \"cx\" : \"y\" === e && (e = \"cy\"));\n        return this._defaultGetter(e);\n      };\n\n      F.prototype.zIndexSetter = function (e, c) {\n        var b = this.renderer,\n            d = this.parentGroup,\n            g = (d || b).element || b.box,\n            k = this.element,\n            h = !1;\n        b = g === b.box;\n        var l = this.added;\n        var r;\n        I(e) ? (k.setAttribute(\"data-z-index\", e), e = +e, this[c] === e && (l = !1)) : I(this[c]) && k.removeAttribute(\"data-z-index\");\n        this[c] = e;\n\n        if (l) {\n          (e = this.zIndex) && d && (d.handleZ = !0);\n          c = g.childNodes;\n\n          for (r = c.length - 1; 0 <= r && !h; r--) {\n            d = c[r];\n            l = d.getAttribute(\"data-z-index\");\n            var m = !I(l);\n            if (d !== k) if (0 > e && m && !b && !r) g.insertBefore(k, c[r]), h = !0;else if (N(l) <= e || m && (!I(e) || 0 <= e)) g.insertBefore(k, c[r + 1] || null), h = !0;\n          }\n\n          h || (g.insertBefore(k, c[b ? 3 : 0] || null), h = !0);\n        }\n\n        return h;\n      };\n\n      return F;\n    }();\n\n    n.prototype[\"stroke-widthSetter\"] = n.prototype.strokeSetter;\n    n.prototype.yGetter = n.prototype.xGetter;\n\n    n.prototype.matrixSetter = n.prototype.rotationOriginXSetter = n.prototype.rotationOriginYSetter = n.prototype.rotationSetter = n.prototype.scaleXSetter = n.prototype.scaleYSetter = n.prototype.translateXSetter = n.prototype.translateYSetter = n.prototype.verticalAlignSetter = function (d, e) {\n      this[e] = d;\n      this.doTransform = !0;\n    };\n\n    a.SVGElement = n;\n    return a.SVGElement;\n  });\n  O(n, \"Core/Renderer/SVG/SVGLabel.js\", [n[\"Core/Renderer/SVG/SVGElement.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = this && this.__extends || function () {\n      var _a = function a(f, L) {\n        _a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, f) {\n          a.__proto__ = f;\n        } || function (a, f) {\n          for (var q in f) {\n            f.hasOwnProperty(q) && (a[q] = f[q]);\n          }\n        };\n\n        return _a(f, L);\n      };\n\n      return function (f, L) {\n        function q() {\n          this.constructor = f;\n        }\n\n        _a(f, L);\n\n        f.prototype = null === L ? Object.create(L) : (q.prototype = L.prototype, new q());\n      };\n    }(),\n        y = a.defined,\n        D = a.extend,\n        G = a.isNumber,\n        C = a.merge,\n        J = a.removeEvent;\n\n    return function (a) {\n      function v(f, q, H, E, p, t, I, u, m, h) {\n        var l = a.call(this) || this;\n        l.init(f, \"g\");\n        l.textStr = q;\n        l.x = H;\n        l.y = E;\n        l.anchorX = t;\n        l.anchorY = I;\n        l.baseline = m;\n        l.className = h;\n        \"button\" !== h && l.addClass(\"highcharts-label\");\n        h && l.addClass(\"highcharts-\" + h);\n        l.text = f.text(\"\", 0, 0, u).attr({\n          zIndex: 1\n        });\n\n        if (\"string\" === typeof p) {\n          var k = /^url\\((.*?)\\)$/.test(p);\n          if (l.renderer.symbols[p] || k) l.symbolKey = p;\n        }\n\n        l.bBox = v.emptyBBox;\n        l.padding = 3;\n        l.paddingLeft = 0;\n        l.baselineOffset = 0;\n        l.needsBox = f.styledMode || k;\n        l.deferredAttr = {};\n        l.alignFactor = 0;\n        return l;\n      }\n\n      n(v, a);\n\n      v.prototype.alignSetter = function (a) {\n        a = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[a];\n        a !== this.alignFactor && (this.alignFactor = a, this.bBox && G(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      };\n\n      v.prototype.anchorXSetter = function (a, f) {\n        this.anchorX = a;\n        this.boxAttr(f, Math.round(a) - this.getCrispAdjust() - this.xSetting);\n      };\n\n      v.prototype.anchorYSetter = function (a, f) {\n        this.anchorY = a;\n        this.boxAttr(f, a - this.ySetting);\n      };\n\n      v.prototype.boxAttr = function (a, f) {\n        this.box ? this.box.attr(a, f) : this.deferredAttr[a] = f;\n      };\n\n      v.prototype.css = function (a) {\n        if (a) {\n          var q = {};\n          a = C(a);\n          v.textProps.forEach(function (f) {\n            \"undefined\" !== typeof a[f] && (q[f] = a[f], delete a[f]);\n          });\n          this.text.css(q);\n          var L = \"fontSize\" in q || \"fontWeight\" in q;\n          if (\"width\" in q || L) this.updateBoxSize(), L && this.updateTextPadding();\n        }\n\n        return f.prototype.css.call(this, a);\n      };\n\n      v.prototype.destroy = function () {\n        J(this.element, \"mouseenter\");\n        J(this.element, \"mouseleave\");\n        this.text && this.text.destroy();\n        this.box && (this.box = this.box.destroy());\n        f.prototype.destroy.call(this);\n      };\n\n      v.prototype.fillSetter = function (a, f) {\n        a && (this.needsBox = !0);\n        this.fill = a;\n        this.boxAttr(f, a);\n      };\n\n      v.prototype.getBBox = function () {\n        var a = this.bBox,\n            f = this.padding;\n        return {\n          width: a.width + 2 * f,\n          height: a.height + 2 * f,\n          x: a.x - f,\n          y: a.y - f\n        };\n      };\n\n      v.prototype.getCrispAdjust = function () {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n      };\n\n      v.prototype.heightSetter = function (a) {\n        this.heightSetting = a;\n      };\n\n      v.prototype.on = function (a, q) {\n        var v = this,\n            E = v.text,\n            p = E && \"SPAN\" === E.element.tagName ? E : void 0;\n\n        if (p) {\n          var t = function t(_t) {\n            (\"mouseenter\" === a || \"mouseleave\" === a) && _t.relatedTarget instanceof Element && (v.element.contains(_t.relatedTarget) || p.element.contains(_t.relatedTarget)) || q.call(v.element, _t);\n          };\n\n          p.on(a, t);\n        }\n\n        f.prototype.on.call(v, a, t || q);\n        return v;\n      };\n\n      v.prototype.onAdd = function () {\n        var a = this.textStr;\n        this.text.add(this);\n        this.attr({\n          text: y(a) ? a : \"\",\n          x: this.x,\n          y: this.y\n        });\n        this.box && y(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      };\n\n      v.prototype.paddingSetter = function (a) {\n        y(a) && a !== this.padding && (this.padding = a, this.updateTextPadding());\n      };\n\n      v.prototype.paddingLeftSetter = function (a) {\n        y(a) && a !== this.paddingLeft && (this.paddingLeft = a, this.updateTextPadding());\n      };\n\n      v.prototype.rSetter = function (a, f) {\n        this.boxAttr(f, a);\n      };\n\n      v.prototype.shadow = function (a) {\n        a && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(a));\n        return this;\n      };\n\n      v.prototype.strokeSetter = function (a, f) {\n        this.stroke = a;\n        this.boxAttr(f, a);\n      };\n\n      v.prototype[\"stroke-widthSetter\"] = function (a, f) {\n        a && (this.needsBox = !0);\n        this[\"stroke-width\"] = a;\n        this.boxAttr(f, a);\n      };\n\n      v.prototype[\"text-alignSetter\"] = function (a) {\n        this.textAlign = a;\n      };\n\n      v.prototype.textSetter = function (a) {\n        \"undefined\" !== typeof a && this.text.attr({\n          text: a\n        });\n        this.updateBoxSize();\n        this.updateTextPadding();\n      };\n\n      v.prototype.updateBoxSize = function () {\n        var a = this.text.element.style,\n            f = {},\n            H = this.padding,\n            E = this.paddingLeft,\n            p = G(this.widthSetting) && G(this.heightSetting) && !this.textAlign || !y(this.text.textStr) ? v.emptyBBox : this.text.getBBox();\n        this.width = (this.widthSetting || p.width || 0) + 2 * H + E;\n        this.height = (this.heightSetting || p.height || 0) + 2 * H;\n        this.baselineOffset = H + Math.min(this.renderer.fontMetrics(a && a.fontSize, this.text).b, p.height || Infinity);\n        this.needsBox && (this.box || (a = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), a.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), a.add(this), a = this.getCrispAdjust(), f.x = a, f.y = (this.baseline ? -this.baselineOffset : 0) + a), f.width = Math.round(this.width), f.height = Math.round(this.height), this.box.attr(D(f, this.deferredAttr)), this.deferredAttr = {});\n        this.bBox = p;\n      };\n\n      v.prototype.updateTextPadding = function () {\n        var a = this.text,\n            f = this.baseline ? 0 : this.baselineOffset,\n            v = this.paddingLeft + this.padding;\n        y(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (v += {\n          center: .5,\n          right: 1\n        }[this.textAlign] * (this.widthSetting - this.bBox.width));\n        if (v !== a.x || f !== a.y) a.attr(\"x\", v), a.hasBoxWidthChanged && (this.bBox = a.getBBox(!0), this.updateBoxSize()), \"undefined\" !== typeof f && a.attr(\"y\", f);\n        a.x = v;\n        a.y = f;\n      };\n\n      v.prototype.widthSetter = function (a) {\n        this.widthSetting = G(a) ? a : void 0;\n      };\n\n      v.prototype.xSetter = function (a) {\n        this.x = a;\n        this.alignFactor && (a -= this.alignFactor * ((this.widthSetting || this.bBox.width) + 2 * this.padding), this[\"forceAnimate:x\"] = !0);\n        this.xSetting = Math.round(a);\n        this.attr(\"translateX\", this.xSetting);\n      };\n\n      v.prototype.ySetter = function (a) {\n        this.ySetting = this.y = Math.round(a);\n        this.attr(\"translateY\", this.ySetting);\n      };\n\n      v.emptyBBox = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      v.textProps = \"color cursor direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width\".split(\" \");\n      return v;\n    }(f);\n  });\n  O(n, \"Core/Renderer/SVG/SVGRenderer.js\", [n[\"Core/Color.js\"], n[\"Core/Globals.js\"], n[\"Core/Renderer/SVG/SVGElement.js\"], n[\"Core/Renderer/SVG/SVGLabel.js\"], n[\"Core/Utilities.js\"]], function (f, a, n, y, D) {\n    var G = D.addEvent,\n        C = D.attr,\n        J = D.createElement,\n        H = D.css,\n        v = D.defined,\n        L = D.destroyObjectProperties,\n        q = D.extend,\n        K = D.isArray,\n        E = D.isNumber,\n        p = D.isObject,\n        t = D.isString,\n        I = D.merge,\n        u = D.objectEach,\n        m = D.pick,\n        h = D.pInt,\n        l = D.splat,\n        k = D.uniqueKey,\n        g = a.charts,\n        d = a.deg2rad,\n        x = a.doc,\n        r = a.isFirefox,\n        A = a.isMS,\n        N = a.isWebKit;\n    D = a.noop;\n\n    var B = a.svg,\n        M = a.SVG_NS,\n        R = a.symbolSizes,\n        F = a.win,\n        e = function () {\n      function c(b, c, e, d, g, k, h) {\n        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;\n        this.init(b, c, e, d, g, k, h);\n      }\n\n      c.prototype.init = function (b, c, e, d, g, k, h) {\n        var w = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        });\n        h || w.css(this.getStyle(d));\n        d = w.element;\n        b.appendChild(d);\n        C(b, \"dir\", \"ltr\");\n        -1 === b.innerHTML.indexOf(\"xmlns\") && C(d, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = d;\n        this.boxWrapper = w;\n        this.alignedObjects = [];\n        this.url = (r || N) && x.getElementsByTagName(\"base\").length ? F.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\") : \"\";\n        this.createElement(\"desc\").add().element.appendChild(x.createTextNode(\"Created with Highcharts 8.2.0\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = k;\n        this.forExport = g;\n        this.styledMode = h;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(c, e, !1);\n        var z;\n        r && b.getBoundingClientRect && (c = function c() {\n          H(b, {\n            left: 0,\n            top: 0\n          });\n          z = b.getBoundingClientRect();\n          H(b, {\n            left: Math.ceil(z.left) - z.left + \"px\",\n            top: Math.ceil(z.top) - z.top + \"px\"\n          });\n        }, c(), this.unSubPixelFix = G(F, \"resize\", c));\n      };\n\n      c.prototype.definition = function (b) {\n        function c(b, d) {\n          var g;\n          l(b).forEach(function (b) {\n            var w = e.createElement(b.tagName),\n                z = {};\n            u(b, function (b, c) {\n              \"tagName\" !== c && \"children\" !== c && \"textContent\" !== c && (z[c] = b);\n            });\n            w.attr(z);\n            w.add(d || e.defs);\n            b.textContent && w.element.appendChild(x.createTextNode(b.textContent));\n            c(b.children || [], w);\n            g = w;\n          });\n          return g;\n        }\n\n        var e = this;\n        return c(b);\n      };\n\n      c.prototype.getStyle = function (b) {\n        return this.style = q({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, b);\n      };\n\n      c.prototype.setStyle = function (b) {\n        this.boxWrapper.css(this.getStyle(b));\n      };\n\n      c.prototype.isHidden = function () {\n        return !this.boxWrapper.getBBox().width;\n      };\n\n      c.prototype.destroy = function () {\n        var b = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        L(this.gradients || {});\n        this.gradients = null;\n        b && (this.defs = b.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      };\n\n      c.prototype.createElement = function (b) {\n        var c = new this.Element();\n        c.init(this, b);\n        return c;\n      };\n\n      c.prototype.getRadialAttr = function (b, c) {\n        return {\n          cx: b[0] - b[2] / 2 + c.cx * b[2],\n          cy: b[1] - b[2] / 2 + c.cy * b[2],\n          r: c.r * b[2]\n        };\n      };\n\n      c.prototype.truncate = function (b, c, e, d, g, k, h) {\n        var w = this,\n            z = b.rotation,\n            l,\n            r = d ? 1 : 0,\n            m = (e || d).length,\n            P = m,\n            p = [],\n            t = function t(b) {\n          c.firstChild && c.removeChild(c.firstChild);\n          b && c.appendChild(x.createTextNode(b));\n        },\n            B = function B(z, k) {\n          k = k || z;\n          if (\"undefined\" === typeof p[k]) if (c.getSubStringLength) try {\n            p[k] = g + c.getSubStringLength(0, d ? k + 1 : k);\n          } catch (da) {\n            \"\";\n          } else w.getSpanWidth && (t(h(e || d, z)), p[k] = g + w.getSpanWidth(b, c));\n          return p[k];\n        },\n            a;\n\n        b.rotation = 0;\n        var A = B(c.textContent.length);\n\n        if (a = g + A > k) {\n          for (; r <= m;) {\n            P = Math.ceil((r + m) / 2), d && (l = h(d, P)), A = B(P, l && l.length - 1), r === m ? r = m + 1 : A > k ? m = P - 1 : r = P;\n          }\n\n          0 === m ? t(\"\") : e && m === e.length - 1 || t(l || h(e || d, P));\n        }\n\n        d && d.splice(0, P);\n        b.actualWidth = A;\n        b.rotation = z;\n        return a;\n      };\n\n      c.prototype.buildText = function (b) {\n        var c = b.element,\n            e = this,\n            d = e.forExport,\n            g = m(b.textStr, \"\").toString(),\n            k = -1 !== g.indexOf(\"<\"),\n            l = c.childNodes,\n            r,\n            p = C(c, \"x\"),\n            a = b.styles,\n            A = b.textWidth,\n            I = a && a.lineHeight,\n            Q = a && a.textOutline,\n            f = a && \"ellipsis\" === a.textOverflow,\n            F = a && \"nowrap\" === a.whiteSpace,\n            N = a && a.fontSize,\n            q,\n            E = l.length;\n        a = A && !b.added && this.box;\n\n        var v = function v(b) {\n          var d;\n          e.styledMode || (d = /(px|em)$/.test(b && b.style.fontSize) ? b.style.fontSize : N || e.style.fontSize || 12);\n          return I ? h(I) : e.fontMetrics(d, b.getAttribute(\"style\") ? b : c).h;\n        },\n            R = function R(b, c) {\n          u(e.escapes, function (e, d) {\n            c && -1 !== c.indexOf(e) || (b = b.toString().replace(new RegExp(e, \"g\"), d));\n          });\n          return b;\n        },\n            n = function n(b, c) {\n          var e = b.indexOf(\"<\");\n          b = b.substring(e, b.indexOf(\">\") - e);\n          e = b.indexOf(c + \"=\");\n          if (-1 !== e && (e = e + c.length + 1, c = b.charAt(e), '\"' === c || \"'\" === c)) return b = b.substring(e + 1), b.substring(0, b.indexOf(c));\n        },\n            K = /<br.*?>/g;\n\n        var J = [g, f, F, I, Q, N, A].join();\n\n        if (J !== b.textCache) {\n          for (b.textCache = J; E--;) {\n            c.removeChild(l[E]);\n          }\n\n          k || Q || f || A || -1 !== g.indexOf(\" \") && (!F || K.test(g)) ? (a && a.appendChild(c), k ? (g = e.styledMode ? g.replace(/<(b|strong)>/g, '<span class=\"highcharts-strong\">').replace(/<(i|em)>/g, '<span class=\"highcharts-emphasized\">') : g.replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">').replace(/<(i|em)>/g, '<span style=\"font-style:italic\">'), g = g.replace(/<a/g, \"<span\").replace(/<\\/(b|strong|i|em|a)>/g, \"</span>\").split(K)) : g = [g], g = g.filter(function (b) {\n            return \"\" !== b;\n          }), g.forEach(function (g, w) {\n            var k = 0,\n                z = 0;\n            g = g.replace(/^\\s+|\\s+$/g, \"\").replace(/<span/g, \"|||<span\").replace(/<\\/span>/g, \"</span>|||\");\n            var h = g.split(\"|||\");\n            h.forEach(function (g) {\n              if (\"\" !== g || 1 === h.length) {\n                var l = {},\n                    m = x.createElementNS(e.SVG_NS, \"tspan\"),\n                    P,\n                    a;\n                (P = n(g, \"class\")) && C(m, \"class\", P);\n                if (P = n(g, \"style\")) P = P.replace(/(;| |^)color([ :])/, \"$1fill$2\"), C(m, \"style\", P);\n\n                if ((a = n(g, \"href\")) && !d && -1 === a.split(\":\")[0].toLowerCase().indexOf(\"javascript\")) {\n                  var t = x.createElementNS(e.SVG_NS, \"a\");\n                  C(t, \"href\", a);\n                  C(m, \"class\", \"highcharts-anchor\");\n                  t.appendChild(m);\n                  e.styledMode || H(m, {\n                    cursor: \"pointer\"\n                  });\n                }\n\n                g = R(g.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, \"\") || \" \");\n\n                if (\" \" !== g) {\n                  m.appendChild(x.createTextNode(g));\n                  k ? l.dx = 0 : w && null !== p && (l.x = p);\n                  C(m, l);\n                  c.appendChild(t || m);\n                  !k && q && (!B && d && H(m, {\n                    display: \"block\"\n                  }), C(m, \"dy\", v(m)));\n\n                  if (A) {\n                    var Q = g.replace(/([^\\^])-/g, \"$1- \").split(\" \");\n                    l = !F && (1 < h.length || w || 1 < Q.length);\n                    t = 0;\n                    a = v(m);\n                    if (f) r = e.truncate(b, m, g, void 0, 0, Math.max(0, A - parseInt(N || 12, 10)), function (b, c) {\n                      return b.substring(0, c) + \"\\u2026\";\n                    });else if (l) for (; Q.length;) {\n                      Q.length && !F && 0 < t && (m = x.createElementNS(M, \"tspan\"), C(m, {\n                        dy: a,\n                        x: p\n                      }), P && C(m, \"style\", P), m.appendChild(x.createTextNode(Q.join(\" \").replace(/- /g, \"-\"))), c.appendChild(m)), e.truncate(b, m, null, Q, 0 === t ? z : 0, A, function (b, c) {\n                        return Q.slice(0, c).join(\" \").replace(/- /g, \"-\");\n                      }), z = b.actualWidth, t++;\n                    }\n                  }\n\n                  k++;\n                }\n              }\n            });\n            q = q || c.childNodes.length;\n          }), f && r && b.attr(\"title\", R(b.textStr || \"\", [\"&lt;\", \"&gt;\"])), a && a.removeChild(c), t(Q) && b.applyTextOutline && b.applyTextOutline(Q)) : c.appendChild(x.createTextNode(R(g)));\n        }\n      };\n\n      c.prototype.getContrast = function (b) {\n        b = f.parse(b).rgba;\n        b[0] *= 1;\n        b[1] *= 1.2;\n        b[2] *= .5;\n        return 459 < b[0] + b[1] + b[2] ? \"#000000\" : \"#FFFFFF\";\n      };\n\n      c.prototype.button = function (b, c, e, d, g, k, h, l, r, m) {\n        var w = this.label(b, c, e, r, void 0, void 0, m, void 0, \"button\"),\n            z = 0,\n            x = this.styledMode;\n        b = (g = g ? I(g) : g) && g.style || {};\n        g && g.style && delete g.style;\n        w.attr(I({\n          padding: 8,\n          r: 2\n        }, g));\n\n        if (!x) {\n          g = I({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1,\n            style: {\n              color: \"#333333\",\n              cursor: \"pointer\",\n              fontWeight: \"normal\"\n            }\n          }, {\n            style: b\n          }, g);\n          var P = g.style;\n          delete g.style;\n          k = I(g, {\n            fill: \"#e6e6e6\"\n          }, k);\n          var t = k.style;\n          delete k.style;\n          h = I(g, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, h);\n          var a = h.style;\n          delete h.style;\n          l = I(g, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, l);\n          var p = l.style;\n          delete l.style;\n        }\n\n        G(w.element, A ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== z && w.setState(1);\n        });\n        G(w.element, A ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== z && w.setState(z);\n        });\n\n        w.setState = function (b) {\n          1 !== b && (w.state = z = b);\n          w.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][b || 0]);\n          x || w.attr([g, k, h, l][b || 0]).css([P, t, a, p][b || 0]);\n        };\n\n        x || w.attr(g).css(q({\n          cursor: \"default\"\n        }, P));\n        return w.on(\"click\", function (b) {\n          3 !== z && d.call(w, b);\n        });\n      };\n\n      c.prototype.crispLine = function (b, c, e) {\n        void 0 === e && (e = \"round\");\n        var d = b[0],\n            g = b[1];\n        d[1] === g[1] && (d[1] = g[1] = Math[e](d[1]) - c % 2 / 2);\n        d[2] === g[2] && (d[2] = g[2] = Math[e](d[2]) + c % 2 / 2);\n        return b;\n      };\n\n      c.prototype.path = function (b) {\n        var c = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        K(b) ? c.d = b : p(b) && q(c, b);\n        return this.createElement(\"path\").attr(c);\n      };\n\n      c.prototype.circle = function (b, c, e) {\n        b = p(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: c,\n          r: e\n        };\n        c = this.createElement(\"circle\");\n\n        c.xSetter = c.ySetter = function (b, c, e) {\n          e.setAttribute(\"c\" + c, b);\n        };\n\n        return c.attr(b);\n      };\n\n      c.prototype.arc = function (b, c, e, d, g, k) {\n        p(b) ? (d = b, c = d.y, e = d.r, b = d.x) : d = {\n          innerR: d,\n          start: g,\n          end: k\n        };\n        b = this.symbol(\"arc\", b, c, e, e, d);\n        b.r = e;\n        return b;\n      };\n\n      c.prototype.rect = function (b, c, e, d, g, k) {\n        g = p(b) ? b.r : g;\n        var w = this.createElement(\"rect\");\n        b = p(b) ? b : \"undefined\" === typeof b ? {} : {\n          x: b,\n          y: c,\n          width: Math.max(e, 0),\n          height: Math.max(d, 0)\n        };\n        this.styledMode || (\"undefined\" !== typeof k && (b.strokeWidth = k, b = w.crisp(b)), b.fill = \"none\");\n        g && (b.r = g);\n\n        w.rSetter = function (b, c, e) {\n          w.r = b;\n          C(e, {\n            rx: b,\n            ry: b\n          });\n        };\n\n        w.rGetter = function () {\n          return w.r;\n        };\n\n        return w.attr(b);\n      };\n\n      c.prototype.setSize = function (b, c, e) {\n        var d = this.alignedObjects,\n            g = d.length;\n        this.width = b;\n        this.height = c;\n\n        for (this.boxWrapper.animate({\n          width: b,\n          height: c\n        }, {\n          step: function step() {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: m(e, !0) ? void 0 : 0\n        }); g--;) {\n          d[g].align();\n        }\n      };\n\n      c.prototype.g = function (b) {\n        var c = this.createElement(\"g\");\n        return b ? c.attr({\n          \"class\": \"highcharts-\" + b\n        }) : c;\n      };\n\n      c.prototype.image = function (b, c, e, d, g, k) {\n        var w = {\n          preserveAspectRatio: \"none\"\n        },\n            h = function h(b, c) {\n          b.setAttributeNS ? b.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", c) : b.setAttribute(\"hc-svg-href\", c);\n        },\n            z = function z(c) {\n          h(l.element, b);\n          k.call(l, c);\n        };\n\n        1 < arguments.length && q(w, {\n          x: c,\n          y: e,\n          width: d,\n          height: g\n        });\n        var l = this.createElement(\"image\").attr(w);\n        k ? (h(l.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), w = new F.Image(), G(w, \"load\", z), w.src = b, w.complete && z({})) : h(l.element, b);\n        return l;\n      };\n\n      c.prototype.symbol = function (b, c, e, d, k, h) {\n        var w = this,\n            z = /^url\\((.*?)\\)$/,\n            l = z.test(b),\n            r = !l && (this.symbols[b] ? b : \"circle\"),\n            P = r && this.symbols[r],\n            t;\n\n        if (P) {\n          \"number\" === typeof c && (t = P.call(this.symbols, Math.round(c || 0), Math.round(e || 0), d || 0, k || 0, h));\n          var a = this.path(t);\n          w.styledMode || a.attr(\"fill\", \"none\");\n          q(a, {\n            symbolName: r,\n            x: c,\n            y: e,\n            width: d,\n            height: k\n          });\n          h && q(a, h);\n        } else if (l) {\n          var p = b.match(z)[1];\n          a = this.image(p);\n          a.imgwidth = m(R[p] && R[p].width, h && h.width);\n          a.imgheight = m(R[p] && R[p].height, h && h.height);\n\n          var B = function B() {\n            a.attr({\n              width: a.width,\n              height: a.height\n            });\n          };\n\n          [\"width\", \"height\"].forEach(function (b) {\n            a[b + \"Setter\"] = function (b, c) {\n              var e = {},\n                  d = this[\"img\" + c],\n                  g = \"width\" === c ? \"translateX\" : \"translateY\";\n              this[c] = b;\n              v(d) && (h && \"within\" === h.backgroundSize && this.width && this.height && (d = Math.round(d * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(c, d), this.alignByTranslate || (e[g] = ((this[c] || 0) - d) / 2, this.attr(e)));\n            };\n          });\n          v(c) && a.attr({\n            x: c,\n            y: e\n          });\n          a.isImg = !0;\n          v(a.imgwidth) && v(a.imgheight) ? B() : (a.attr({\n            width: 0,\n            height: 0\n          }), J(\"img\", {\n            onload: function onload() {\n              var b = g[w.chartIndex];\n              0 === this.width && (H(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), x.body.appendChild(this));\n              R[p] = {\n                width: this.width,\n                height: this.height\n              };\n              a.imgwidth = this.width;\n              a.imgheight = this.height;\n              a.element && B();\n              this.parentNode && this.parentNode.removeChild(this);\n              w.imgCount--;\n              if (!w.imgCount && b && !b.hasLoaded) b.onload();\n            },\n            src: p\n          }), this.imgCount++);\n        }\n\n        return a;\n      };\n\n      c.prototype.clipRect = function (b, c, e, d) {\n        var g = k() + \"-\",\n            w = this.createElement(\"clipPath\").attr({\n          id: g\n        }).add(this.defs);\n        b = this.rect(b, c, e, d, 0).add(w);\n        b.id = g;\n        b.clipPath = w;\n        b.count = 0;\n        return b;\n      };\n\n      c.prototype.text = function (b, c, e, d) {\n        var g = {};\n        if (d && (this.allowHTML || !this.forExport)) return this.html(b, c, e);\n        g.x = Math.round(c || 0);\n        e && (g.y = Math.round(e));\n        v(b) && (g.text = b);\n        b = this.createElement(\"text\").attr(g);\n        d || (b.xSetter = function (b, c, e) {\n          var d = e.getElementsByTagName(\"tspan\"),\n              g = e.getAttribute(c),\n              k;\n\n          for (k = 0; k < d.length; k++) {\n            var w = d[k];\n            w.getAttribute(c) === g && w.setAttribute(c, b);\n          }\n\n          e.setAttribute(c, b);\n        });\n        return b;\n      };\n\n      c.prototype.fontMetrics = function (b, c) {\n        b = !this.styledMode && /px/.test(b) || !F.getComputedStyle ? b || c && c.style && c.style.fontSize || this.style && this.style.fontSize : c && n.prototype.getStyle.call(c, \"font-size\");\n        b = /px/.test(b) ? h(b) : 12;\n        c = 24 > b ? b + 3 : Math.round(1.2 * b);\n        return {\n          h: c,\n          b: Math.round(.8 * c),\n          f: b\n        };\n      };\n\n      c.prototype.rotCorr = function (b, c, e) {\n        var g = b;\n        c && e && (g = Math.max(g * Math.cos(c * d), 4));\n        return {\n          x: -b / 3 * Math.sin(c * d),\n          y: g\n        };\n      };\n\n      c.prototype.pathToSegments = function (b) {\n        for (var c = [], e = [], d = {\n          A: 8,\n          C: 7,\n          H: 2,\n          L: 3,\n          M: 3,\n          Q: 5,\n          S: 5,\n          T: 3,\n          V: 2\n        }, g = 0; g < b.length; g++) {\n          t(e[0]) && E(b[g]) && e.length === d[e[0].toUpperCase()] && b.splice(g, 0, e[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" === typeof b[g] && (e.length && c.push(e.slice(0)), e.length = 0), e.push(b[g]);\n        }\n\n        c.push(e.slice(0));\n        return c;\n      };\n\n      c.prototype.label = function (b, c, e, d, g, k, h, l, r) {\n        return new y(this, b, c, e, d, g, k, h, l, r);\n      };\n\n      return c;\n    }();\n\n    e.prototype.Element = n;\n    e.prototype.SVG_NS = M;\n    e.prototype.draw = D;\n    e.prototype.escapes = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      \"'\": \"&#39;\",\n      '\"': \"&quot;\"\n    };\n    e.prototype.symbols = {\n      circle: function circle(c, b, e, d) {\n        return this.arc(c + e / 2, b + d / 2, e / 2, d / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      square: function square(c, b, e, d) {\n        return [[\"M\", c, b], [\"L\", c + e, b], [\"L\", c + e, b + d], [\"L\", c, b + d], [\"Z\"]];\n      },\n      triangle: function triangle(c, b, e, d) {\n        return [[\"M\", c + e / 2, b], [\"L\", c + e, b + d], [\"L\", c, b + d], [\"Z\"]];\n      },\n      \"triangle-down\": function triangleDown(c, b, e, d) {\n        return [[\"M\", c, b], [\"L\", c + e, b], [\"L\", c + e / 2, b + d], [\"Z\"]];\n      },\n      diamond: function diamond(c, b, e, d) {\n        return [[\"M\", c + e / 2, b], [\"L\", c + e, b + d / 2], [\"L\", c + e / 2, b + d], [\"L\", c, b + d / 2], [\"Z\"]];\n      },\n      arc: function arc(c, b, e, d, g) {\n        var k = [];\n\n        if (g) {\n          var h = g.start || 0,\n              w = g.end || 0,\n              z = g.r || e;\n          e = g.r || d || e;\n          var l = .001 > Math.abs(w - h - 2 * Math.PI);\n          w -= .001;\n          d = g.innerR;\n          l = m(g.open, l);\n          var r = Math.cos(h),\n              x = Math.sin(h),\n              a = Math.cos(w),\n              P = Math.sin(w);\n          h = m(g.longArc, .001 > w - h - Math.PI ? 0 : 1);\n          k.push([\"M\", c + z * r, b + e * x], [\"A\", z, e, 0, h, m(g.clockwise, 1), c + z * a, b + e * P]);\n          v(d) && k.push(l ? [\"M\", c + d * a, b + d * P] : [\"L\", c + d * a, b + d * P], [\"A\", d, d, 0, h, v(g.clockwise) ? 1 - g.clockwise : 0, c + d * r, b + d * x]);\n          l || k.push([\"Z\"]);\n        }\n\n        return k;\n      },\n      callout: function callout(c, b, e, d, g) {\n        var k = Math.min(g && g.r || 0, e, d),\n            h = k + 6,\n            w = g && g.anchorX || 0;\n        g = g && g.anchorY || 0;\n        var l = [[\"M\", c + k, b], [\"L\", c + e - k, b], [\"C\", c + e, b, c + e, b, c + e, b + k], [\"L\", c + e, b + d - k], [\"C\", c + e, b + d, c + e, b + d, c + e - k, b + d], [\"L\", c + k, b + d], [\"C\", c, b + d, c, b + d, c, b + d - k], [\"L\", c, b + k], [\"C\", c, b, c, b, c + k, b]];\n        w && w > e ? g > b + h && g < b + d - h ? l.splice(3, 1, [\"L\", c + e, g - 6], [\"L\", c + e + 6, g], [\"L\", c + e, g + 6], [\"L\", c + e, b + d - k]) : l.splice(3, 1, [\"L\", c + e, d / 2], [\"L\", w, g], [\"L\", c + e, d / 2], [\"L\", c + e, b + d - k]) : w && 0 > w ? g > b + h && g < b + d - h ? l.splice(7, 1, [\"L\", c, g + 6], [\"L\", c - 6, g], [\"L\", c, g - 6], [\"L\", c, b + k]) : l.splice(7, 1, [\"L\", c, d / 2], [\"L\", w, g], [\"L\", c, d / 2], [\"L\", c, b + k]) : g && g > d && w > c + h && w < c + e - h ? l.splice(5, 1, [\"L\", w + 6, b + d], [\"L\", w, b + d + 6], [\"L\", w - 6, b + d], [\"L\", c + k, b + d]) : g && 0 > g && w > c + h && w < c + e - h && l.splice(1, 1, [\"L\", w - 6, b], [\"L\", w, b - 6], [\"L\", w + 6, b], [\"L\", e - k, b]);\n        return l;\n      }\n    };\n    a.SVGRenderer = e;\n    a.Renderer = a.SVGRenderer;\n    return a.Renderer;\n  });\n  O(n, \"Core/Renderer/HTML/HTML.js\", [n[\"Core/Globals.js\"], n[\"Core/Renderer/SVG/SVGElement.js\"], n[\"Core/Renderer/SVG/SVGRenderer.js\"], n[\"Core/Utilities.js\"]], function (f, a, n, y) {\n    var D = y.attr,\n        G = y.createElement,\n        C = y.css,\n        J = y.defined,\n        H = y.extend,\n        v = y.pick,\n        L = y.pInt,\n        q = f.isFirefox,\n        K = f.isMS,\n        E = f.isWebKit,\n        p = f.win;\n    H(a.prototype, {\n      htmlCss: function htmlCss(a) {\n        var p = \"SPAN\" === this.element.tagName && a && \"width\" in a,\n            t = v(p && a.width, void 0);\n\n        if (p) {\n          delete a.width;\n          this.textWidth = t;\n          var m = !0;\n        }\n\n        a && \"ellipsis\" === a.textOverflow && (a.whiteSpace = \"nowrap\", a.overflow = \"hidden\");\n        this.styles = H(this.styles, a);\n        C(this.element, a);\n        m && this.htmlUpdateTransform();\n        return this;\n      },\n      htmlGetBBox: function htmlGetBBox() {\n        var a = this.element;\n        return {\n          x: a.offsetLeft,\n          y: a.offsetTop,\n          width: a.offsetWidth,\n          height: a.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function htmlUpdateTransform() {\n        if (this.added) {\n          var a = this.renderer,\n              p = this.element,\n              u = this.translateX || 0,\n              m = this.translateY || 0,\n              h = this.x || 0,\n              l = this.y || 0,\n              k = this.textAlign || \"left\",\n              g = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[k],\n              d = this.styles,\n              x = d && d.whiteSpace;\n          C(p, {\n            marginLeft: u,\n            marginTop: m\n          });\n          !a.styledMode && this.shadows && this.shadows.forEach(function (d) {\n            C(d, {\n              marginLeft: u + 1,\n              marginTop: m + 1\n            });\n          });\n          this.inverted && [].forEach.call(p.childNodes, function (d) {\n            a.invertChild(d, p);\n          });\n\n          if (\"SPAN\" === p.tagName) {\n            d = this.rotation;\n            var r = this.textWidth && L(this.textWidth),\n                A = [d, k, p.innerHTML, this.textWidth, this.textAlign].join(),\n                f;\n            (f = r !== this.oldTextWidth) && !(f = r > this.oldTextWidth) && ((f = this.textPxLength) || (C(p, {\n              width: \"\",\n              whiteSpace: x || \"nowrap\"\n            }), f = p.offsetWidth), f = f > r);\n            f && (/[ \\-]/.test(p.textContent || p.innerText) || \"ellipsis\" === p.style.textOverflow) ? (C(p, {\n              width: r + \"px\",\n              display: \"block\",\n              whiteSpace: x || \"normal\"\n            }), this.oldTextWidth = r, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            A !== this.cTT && (x = a.fontMetrics(p.style.fontSize, p).b, !J(d) || d === (this.oldRotation || 0) && k === this.oldAlign || this.setSpanRotation(d, g, x), this.getSpanCorrection(!J(d) && this.textPxLength || p.offsetWidth, x, g, d, k));\n            C(p, {\n              left: h + (this.xCorr || 0) + \"px\",\n              top: l + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = A;\n            this.oldRotation = d;\n            this.oldAlign = k;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function setSpanRotation(a, p, u) {\n        var m = {},\n            h = this.renderer.getTransformKey();\n        m[h] = m.transform = \"rotate(\" + a + \"deg)\";\n        m[h + (q ? \"Origin\" : \"-origin\")] = m.transformOrigin = 100 * p + \"% \" + u + \"px\";\n        C(this.element, m);\n      },\n      getSpanCorrection: function getSpanCorrection(a, p, u) {\n        this.xCorr = -a * u;\n        this.yCorr = -p;\n      }\n    });\n    H(n.prototype, {\n      getTransformKey: function getTransformKey() {\n        return K && !/Edge/.test(p.navigator.userAgent) ? \"-ms-transform\" : E ? \"-webkit-transform\" : q ? \"MozTransform\" : p.opera ? \"-o-transform\" : \"\";\n      },\n      html: function html(p, f, u) {\n        var m = this.createElement(\"span\"),\n            h = m.element,\n            l = m.renderer,\n            k = l.isSVG,\n            g = function g(d, _g) {\n          [\"opacity\", \"visibility\"].forEach(function (k) {\n            d[k + \"Setter\"] = function (h, l, r) {\n              var m = d.div ? d.div.style : _g;\n              a.prototype[k + \"Setter\"].call(this, h, l, r);\n              m && (m[l] = h);\n            };\n          });\n          d.addedSetters = !0;\n        };\n\n        m.textSetter = function (d) {\n          d !== h.innerHTML && (delete this.bBox, delete this.oldTextWidth);\n          this.textStr = d;\n          h.innerHTML = v(d, \"\");\n          m.doTransform = !0;\n        };\n\n        k && g(m, m.element.style);\n\n        m.xSetter = m.ySetter = m.alignSetter = m.rotationSetter = function (d, g) {\n          \"align\" === g ? m.alignValue = m.textAlign = d : m[g] = d;\n          m.doTransform = !0;\n        };\n\n        m.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        m.attr({\n          text: p,\n          x: Math.round(f),\n          y: Math.round(u)\n        }).css({\n          position: \"absolute\"\n        });\n        l.styledMode || m.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        h.style.whiteSpace = \"nowrap\";\n        m.css = m.htmlCss;\n        k && (m.add = function (d) {\n          var k = l.box.parentNode,\n              r = [];\n\n          if (this.parentGroup = d) {\n            var a = d.div;\n\n            if (!a) {\n              for (; d;) {\n                r.push(d), d = d.parentGroup;\n              }\n\n              r.reverse().forEach(function (d) {\n                function h(g, e) {\n                  d[e] = g;\n                  \"translateX\" === e ? x.left = g + \"px\" : x.top = g + \"px\";\n                  d.doTransform = !0;\n                }\n\n                var l = D(d.element, \"class\");\n                a = d.div = d.div || G(\"div\", l ? {\n                  className: l\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (d.translateX || 0) + \"px\",\n                  top: (d.translateY || 0) + \"px\",\n                  display: d.display,\n                  opacity: d.opacity,\n                  pointerEvents: d.styles && d.styles.pointerEvents\n                }, a || k);\n                var x = a.style;\n                H(d, {\n                  classSetter: function (d) {\n                    return function (e) {\n                      this.element.setAttribute(\"class\", e);\n                      d.className = e;\n                    };\n                  }(a),\n                  on: function on() {\n                    r[0].div && m.on.apply({\n                      element: r[0].div\n                    }, arguments);\n                    return d;\n                  },\n                  translateXSetter: h,\n                  translateYSetter: h\n                });\n                d.addedSetters || g(d);\n              });\n            }\n          } else a = k;\n\n          a.appendChild(h);\n          m.added = !0;\n          m.alignOnAdd && m.htmlUpdateTransform();\n          return m;\n        });\n        return m;\n      }\n    });\n  });\n  O(n, \"Core/Axis/Tick.js\", [n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = a.clamp,\n        y = a.correctFloat,\n        D = a.defined,\n        G = a.destroyObjectProperties,\n        C = a.extend,\n        J = a.fireEvent,\n        H = a.isNumber,\n        v = a.merge,\n        L = a.objectEach,\n        q = a.pick,\n        K = f.deg2rad;\n\n    a = function () {\n      function a(a, t, f, u, m) {\n        this.isNewLabel = this.isNew = !0;\n        this.axis = a;\n        this.pos = t;\n        this.type = f || \"\";\n        this.parameters = m || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        J(this, \"init\");\n        f || u || this.addLabel();\n      }\n\n      a.prototype.addLabel = function () {\n        var a = this,\n            t = a.axis,\n            f = t.options,\n            u = t.chart,\n            m = t.categories,\n            h = t.logarithmic,\n            l = t.names,\n            k = a.pos,\n            g = q(a.options && a.options.labels, f.labels),\n            d = t.tickPositions,\n            x = k === d[0],\n            r = k === d[d.length - 1];\n        l = this.parameters.category || (m ? q(m[k], l[k], k) : k);\n        var A = a.label;\n        m = (!g.step || 1 === g.step) && 1 === t.tickInterval;\n        d = d.info;\n        var N, B;\n\n        if (t.dateTime && d) {\n          var M = u.time.resolveDTLFormat(f.dateTimeLabelFormats[!f.grid && d.higherRanks[k] || d.unitName]);\n          var v = M.main;\n        }\n\n        a.isFirst = x;\n        a.isLast = r;\n        a.formatCtx = {\n          axis: t,\n          chart: u,\n          isFirst: x,\n          isLast: r,\n          dateTimeLabelFormat: v,\n          tickPositionInfo: d,\n          value: h ? y(h.lin2log(l)) : l,\n          pos: k\n        };\n        f = t.labelFormatter.call(a.formatCtx, this.formatCtx);\n        if (B = M && M.list) a.shortenLabel = function () {\n          for (N = 0; N < B.length; N++) {\n            if (A.attr({\n              text: t.labelFormatter.call(C(a.formatCtx, {\n                dateTimeLabelFormat: B[N]\n              }))\n            }), A.getBBox().width < t.getSlotWidth(a) - 2 * q(g.padding, 5)) return;\n          }\n\n          A.attr({\n            text: \"\"\n          });\n        };\n        m && t._addedPlotLB && a.moveLabel(f, g);\n        D(A) || a.movedLabel ? A && A.textStr !== f && !m && (!A.textWidth || g.style && g.style.width || A.styles.width || A.css({\n          width: null\n        }), A.attr({\n          text: f\n        }), A.textPxLength = A.getBBox().width) : (a.label = A = a.createLabel({\n          x: 0,\n          y: 0\n        }, f, g), a.rotation = 0);\n      };\n\n      a.prototype.createLabel = function (a, t, f) {\n        var p = this.axis,\n            m = p.chart;\n        if (a = D(t) && f.enabled ? m.renderer.text(t, a.x, a.y, f.useHTML).add(p.labelGroup) : null) m.styledMode || a.css(v(f.style)), a.textPxLength = a.getBBox().width;\n        return a;\n      };\n\n      a.prototype.destroy = function () {\n        G(this, this.axis);\n      };\n\n      a.prototype.getPosition = function (a, t, f, u) {\n        var m = this.axis,\n            h = m.chart,\n            l = u && h.oldChartHeight || h.chartHeight;\n        a = {\n          x: a ? y(m.translate(t + f, null, null, u) + m.transB) : m.left + m.offset + (m.opposite ? (u && h.oldChartWidth || h.chartWidth) - m.right - m.left : 0),\n          y: a ? l - m.bottom + m.offset - (m.opposite ? m.height : 0) : y(l - m.translate(t + f, null, null, u) - m.transB)\n        };\n        a.y = n(a.y, -1E5, 1E5);\n        J(this, \"afterGetPosition\", {\n          pos: a\n        });\n        return a;\n      };\n\n      a.prototype.getLabelPosition = function (a, t, f, u, m, h, l, k) {\n        var g = this.axis,\n            d = g.transA,\n            x = g.isLinked && g.linkedParent ? g.linkedParent.reversed : g.reversed,\n            r = g.staggerLines,\n            p = g.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            I = m.y,\n            B = u || g.reserveSpaceDefault ? 0 : -g.labelOffset * (\"center\" === g.labelAlign ? .5 : 1),\n            M = {};\n        D(I) || (I = 0 === g.side ? f.rotation ? -8 : -f.getBBox().height : 2 === g.side ? p.y + 8 : Math.cos(f.rotation * K) * (p.y - f.getBBox(!1, 0).height / 2));\n        a = a + m.x + B + p.x - (h && u ? h * d * (x ? -1 : 1) : 0);\n        t = t + I - (h && !u ? h * d * (x ? 1 : -1) : 0);\n        r && (f = l / (k || 1) % r, g.opposite && (f = r - f - 1), t += g.labelOffset / r * f);\n        M.x = a;\n        M.y = Math.round(t);\n        J(this, \"afterGetLabelPosition\", {\n          pos: M,\n          tickmarkOffset: h,\n          index: l\n        });\n        return M;\n      };\n\n      a.prototype.getLabelSize = function () {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      };\n\n      a.prototype.getMarkPath = function (a, t, f, u, m, h) {\n        return h.crispLine([[\"M\", a, t], [\"L\", a + (m ? 0 : -f), t + (m ? f : 0)]], u);\n      };\n\n      a.prototype.handleOverflow = function (a) {\n        var p = this.axis,\n            f = p.options.labels,\n            u = a.x,\n            m = p.chart.chartWidth,\n            h = p.chart.spacing,\n            l = q(p.labelLeft, Math.min(p.pos, h[3]));\n        h = q(p.labelRight, Math.max(p.isRadial ? 0 : p.pos + p.len, m - h[1]));\n        var k = this.label,\n            g = this.rotation,\n            d = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[p.labelAlign || k.attr(\"align\")],\n            x = k.getBBox().width,\n            r = p.getSlotWidth(this),\n            A = r,\n            N = 1,\n            B,\n            M = {};\n        if (g || \"justify\" !== q(f.overflow, \"justify\")) 0 > g && u - d * x < l ? B = Math.round(u / Math.cos(g * K) - l) : 0 < g && u + d * x > h && (B = Math.round((m - u) / Math.cos(g * K)));else if (m = u + (1 - d) * x, u - d * x < l ? A = a.x + A * (1 - d) - l : m > h && (A = h - a.x + A * d, N = -1), A = Math.min(r, A), A < r && \"center\" === p.labelAlign && (a.x += N * (r - A - d * (r - Math.min(x, A)))), x > A || p.autoRotation && (k.styles || {}).width) B = A;\n        B && (this.shortenLabel ? this.shortenLabel() : (M.width = Math.floor(B) + \"px\", (f.style || {}).textOverflow || (M.textOverflow = \"ellipsis\"), k.css(M)));\n      };\n\n      a.prototype.moveLabel = function (a, t) {\n        var p = this,\n            f = p.label,\n            m = !1,\n            h = p.axis,\n            l = h.reversed;\n        f && f.textStr === a ? (p.movedLabel = f, m = !0, delete p.label) : L(h.ticks, function (g) {\n          m || g.isNew || g === p || !g.label || g.label.textStr !== a || (p.movedLabel = g.label, m = !0, g.labelPos = p.movedLabel.xy, delete g.label);\n        });\n\n        if (!m && (p.labelPos || f)) {\n          var k = p.labelPos || f.xy;\n          f = h.horiz ? l ? 0 : h.width + h.left : k.x;\n          h = h.horiz ? k.y : l ? h.width + h.left : 0;\n          p.movedLabel = p.createLabel({\n            x: f,\n            y: h\n          }, a, t);\n          p.movedLabel && p.movedLabel.attr({\n            opacity: 0\n          });\n        }\n      };\n\n      a.prototype.render = function (a, t, f) {\n        var p = this.axis,\n            m = p.horiz,\n            h = this.pos,\n            l = q(this.tickmarkOffset, p.tickmarkOffset);\n        h = this.getPosition(m, h, l, t);\n        l = h.x;\n        var k = h.y;\n        p = m && l === p.pos + p.len || !m && k === p.pos ? -1 : 1;\n        f = q(f, 1);\n        this.isActive = !0;\n        this.renderGridLine(t, f, p);\n        this.renderMark(h, f, p);\n        this.renderLabel(h, t, f, a);\n        this.isNew = !1;\n        J(this, \"afterRender\");\n      };\n\n      a.prototype.renderGridLine = function (a, t, f) {\n        var p = this.axis,\n            m = p.options,\n            h = this.gridLine,\n            l = {},\n            k = this.pos,\n            g = this.type,\n            d = q(this.tickmarkOffset, p.tickmarkOffset),\n            x = p.chart.renderer,\n            r = g ? g + \"Grid\" : \"grid\",\n            A = m[r + \"LineWidth\"],\n            N = m[r + \"LineColor\"];\n        m = m[r + \"LineDashStyle\"];\n        h || (p.chart.styledMode || (l.stroke = N, l[\"stroke-width\"] = A, m && (l.dashstyle = m)), g || (l.zIndex = 1), a && (t = 0), this.gridLine = h = x.path().attr(l).addClass(\"highcharts-\" + (g ? g + \"-\" : \"\") + \"grid-line\").add(p.gridGroup));\n        if (h && (f = p.getPlotLinePath({\n          value: k + d,\n          lineWidth: h.strokeWidth() * f,\n          force: \"pass\",\n          old: a\n        }))) h[a || this.isNew ? \"attr\" : \"animate\"]({\n          d: f,\n          opacity: t\n        });\n      };\n\n      a.prototype.renderMark = function (a, t, f) {\n        var p = this.axis,\n            m = p.options,\n            h = p.chart.renderer,\n            l = this.type,\n            k = l ? l + \"Tick\" : \"tick\",\n            g = p.tickSize(k),\n            d = this.mark,\n            x = !d,\n            r = a.x;\n        a = a.y;\n        var A = q(m[k + \"Width\"], !l && p.isXAxis ? 1 : 0);\n        m = m[k + \"Color\"];\n        g && (p.opposite && (g[0] = -g[0]), x && (this.mark = d = h.path().addClass(\"highcharts-\" + (l ? l + \"-\" : \"\") + \"tick\").add(p.axisGroup), p.chart.styledMode || d.attr({\n          stroke: m,\n          \"stroke-width\": A\n        })), d[x ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(r, a, g[0], d.strokeWidth() * f, p.horiz, h),\n          opacity: t\n        }));\n      };\n\n      a.prototype.renderLabel = function (a, f, I, u) {\n        var m = this.axis,\n            h = m.horiz,\n            l = m.options,\n            k = this.label,\n            g = l.labels,\n            d = g.step;\n        m = q(this.tickmarkOffset, m.tickmarkOffset);\n        var x = !0,\n            r = a.x;\n        a = a.y;\n        k && H(r) && (k.xy = a = this.getLabelPosition(r, a, k, h, g, m, u, d), this.isFirst && !this.isLast && !q(l.showFirstLabel, 1) || this.isLast && !this.isFirst && !q(l.showLastLabel, 1) ? x = !1 : !h || g.step || g.rotation || f || 0 === I || this.handleOverflow(a), d && u % d && (x = !1), x && H(a.y) ? (a.opacity = I, k[this.isNewLabel ? \"attr\" : \"animate\"](a), this.isNewLabel = !1) : (k.attr(\"y\", -9999), this.isNewLabel = !0));\n      };\n\n      a.prototype.replaceMovedLabel = function () {\n        var a = this.label,\n            f = this.axis,\n            q = f.reversed;\n\n        if (a && !this.isNew) {\n          var u = f.horiz ? q ? f.left : f.width + f.left : a.xy.x;\n          q = f.horiz ? a.xy.y : q ? f.width + f.top : f.top;\n          a.animate({\n            x: u,\n            y: q,\n            opacity: 0\n          }, void 0, a.destroy);\n          delete this.label;\n        }\n\n        f.isDirty = !0;\n        this.label = this.movedLabel;\n        delete this.movedLabel;\n      };\n\n      return a;\n    }();\n\n    f.Tick = a;\n    return f.Tick;\n  });\n  O(n, \"Core/Time.js\", [n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = a.defined,\n        y = a.error,\n        D = a.extend,\n        G = a.isObject,\n        C = a.merge,\n        J = a.objectEach,\n        H = a.pad,\n        v = a.pick,\n        L = a.splat,\n        q = a.timeUnits,\n        K = f.win;\n\n    a = function () {\n      function a(a) {\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = K.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(a);\n      }\n\n      a.prototype.get = function (a, f) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          var p = f.getTime(),\n              t = p - this.getTimezoneOffset(f);\n          f.setTime(t);\n          a = f[\"getUTC\" + a]();\n          f.setTime(p);\n          return a;\n        }\n\n        return this.useUTC ? f[\"getUTC\" + a]() : f[\"get\" + a]();\n      };\n\n      a.prototype.set = function (a, f, q) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === a || \"Seconds\" === a || \"Minutes\" === a) return f[\"setUTC\" + a](q);\n          var p = this.getTimezoneOffset(f);\n          p = f.getTime() - p;\n          f.setTime(p);\n          f[\"setUTC\" + a](q);\n          a = this.getTimezoneOffset(f);\n          p = f.getTime() + a;\n          return f.setTime(p);\n        }\n\n        return this.useUTC ? f[\"setUTC\" + a](q) : f[\"set\" + a](q);\n      };\n\n      a.prototype.update = function (a) {\n        var f = v(a && a.useUTC, !0);\n        this.options = a = C(!0, this.options || {}, a);\n        this.Date = a.Date || K.Date || Date;\n        this.timezoneOffset = (this.useUTC = f) && a.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.variableTimezone = !(f && !a.getTimezoneOffset && !a.timezone);\n      };\n\n      a.prototype.makeTime = function (a, t, q, u, m, h) {\n        if (this.useUTC) {\n          var l = this.Date.UTC.apply(0, arguments);\n          var k = this.getTimezoneOffset(l);\n          l += k;\n          var g = this.getTimezoneOffset(l);\n          k !== g ? l += g - k : k - 36E5 !== this.getTimezoneOffset(l - 36E5) || f.isSafari || (l -= 36E5);\n        } else l = new this.Date(a, t, v(q, 1), v(u, 0), v(m, 0), v(h, 0)).getTime();\n\n        return l;\n      };\n\n      a.prototype.timezoneOffsetFunction = function () {\n        var a = this,\n            f = this.options,\n            q = f.moment || K.moment;\n        if (!this.useUTC) return function (a) {\n          return 6E4 * new Date(a.toString()).getTimezoneOffset();\n        };\n\n        if (f.timezone) {\n          if (q) return function (a) {\n            return 6E4 * -q.tz(a, f.timezone).utcOffset();\n          };\n          y(25);\n        }\n\n        return this.useUTC && f.getTimezoneOffset ? function (a) {\n          return 6E4 * f.getTimezoneOffset(a.valueOf());\n        } : function () {\n          return 6E4 * (a.timezoneOffset || 0);\n        };\n      };\n\n      a.prototype.dateFormat = function (a, t, q) {\n        var p;\n        if (!n(t) || isNaN(t)) return (null === (p = f.defaultOptions.lang) || void 0 === p ? void 0 : p.invalidDate) || \"\";\n        a = v(a, \"%Y-%m-%d %H:%M:%S\");\n        var m = this;\n        p = new this.Date(t);\n        var h = this.get(\"Hours\", p),\n            l = this.get(\"Day\", p),\n            k = this.get(\"Date\", p),\n            g = this.get(\"Month\", p),\n            d = this.get(\"FullYear\", p),\n            x = f.defaultOptions.lang,\n            r = null === x || void 0 === x ? void 0 : x.weekdays,\n            A = null === x || void 0 === x ? void 0 : x.shortWeekdays;\n        p = D({\n          a: A ? A[l] : r[l].substr(0, 3),\n          A: r[l],\n          d: H(k),\n          e: H(k, 2, \" \"),\n          w: l,\n          b: x.shortMonths[g],\n          B: x.months[g],\n          m: H(g + 1),\n          o: g + 1,\n          y: d.toString().substr(2, 2),\n          Y: d,\n          H: H(h),\n          k: h,\n          I: H(h % 12 || 12),\n          l: h % 12 || 12,\n          M: H(this.get(\"Minutes\", p)),\n          p: 12 > h ? \"AM\" : \"PM\",\n          P: 12 > h ? \"am\" : \"pm\",\n          S: H(p.getSeconds()),\n          L: H(Math.floor(t % 1E3), 3)\n        }, f.dateFormats);\n        J(p, function (d, g) {\n          for (; -1 !== a.indexOf(\"%\" + g);) {\n            a = a.replace(\"%\" + g, \"function\" === typeof d ? d.call(m, t) : d);\n          }\n        });\n        return q ? a.substr(0, 1).toUpperCase() + a.substr(1) : a;\n      };\n\n      a.prototype.resolveDTLFormat = function (a) {\n        return G(a, !0) ? a : (a = L(a), {\n          main: a[0],\n          from: a[1],\n          to: a[2]\n        });\n      };\n\n      a.prototype.getTimeTicks = function (a, f, I, u) {\n        var m = this,\n            h = [],\n            l = {};\n        var k = new m.Date(f);\n        var g = a.unitRange,\n            d = a.count || 1,\n            x;\n        u = v(u, 1);\n\n        if (n(f)) {\n          m.set(\"Milliseconds\", k, g >= q.second ? 0 : d * Math.floor(m.get(\"Milliseconds\", k) / d));\n          g >= q.second && m.set(\"Seconds\", k, g >= q.minute ? 0 : d * Math.floor(m.get(\"Seconds\", k) / d));\n          g >= q.minute && m.set(\"Minutes\", k, g >= q.hour ? 0 : d * Math.floor(m.get(\"Minutes\", k) / d));\n          g >= q.hour && m.set(\"Hours\", k, g >= q.day ? 0 : d * Math.floor(m.get(\"Hours\", k) / d));\n          g >= q.day && m.set(\"Date\", k, g >= q.month ? 1 : Math.max(1, d * Math.floor(m.get(\"Date\", k) / d)));\n\n          if (g >= q.month) {\n            m.set(\"Month\", k, g >= q.year ? 0 : d * Math.floor(m.get(\"Month\", k) / d));\n            var r = m.get(\"FullYear\", k);\n          }\n\n          g >= q.year && m.set(\"FullYear\", k, r - r % d);\n          g === q.week && (r = m.get(\"Day\", k), m.set(\"Date\", k, m.get(\"Date\", k) - r + u + (r < u ? -7 : 0)));\n          r = m.get(\"FullYear\", k);\n          u = m.get(\"Month\", k);\n          var p = m.get(\"Date\", k),\n              t = m.get(\"Hours\", k);\n          f = k.getTime();\n          m.variableTimezone && (x = I - f > 4 * q.month || m.getTimezoneOffset(f) !== m.getTimezoneOffset(I));\n          f = k.getTime();\n\n          for (k = 1; f < I;) {\n            h.push(f), f = g === q.year ? m.makeTime(r + k * d, 0) : g === q.month ? m.makeTime(r, u + k * d) : !x || g !== q.day && g !== q.week ? x && g === q.hour && 1 < d ? m.makeTime(r, u, p, t + k * d) : f + g * d : m.makeTime(r, u, p + k * d * (g === q.day ? 1 : 7)), k++;\n          }\n\n          h.push(f);\n          g <= q.hour && 1E4 > h.length && h.forEach(function (d) {\n            0 === d % 18E5 && \"000000000\" === m.dateFormat(\"%H%M%S%L\", d) && (l[d] = \"day\");\n          });\n        }\n\n        h.info = D(a, {\n          higherRanks: l,\n          totalRange: g * d\n        });\n        return h;\n      };\n\n      return a;\n    }();\n\n    f.Time = a;\n    return f.Time;\n  });\n  O(n, \"Core/Options.js\", [n[\"Core/Globals.js\"], n[\"Core/Time.js\"], n[\"Core/Color.js\"], n[\"Core/Utilities.js\"]], function (f, a, n, y) {\n    n = n.parse;\n    y = y.merge;\n    f.defaultOptions = {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: {\n        Date: void 0,\n        getTimezoneOffset: void 0,\n        timezone: void 0,\n        timezoneOffset: 0,\n        useUTC: !0\n      },\n      chart: {\n        styledMode: !1,\n        borderRadius: 0,\n        colorCount: 10,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        width: null,\n        height: null,\n        borderColor: \"#335cad\",\n        backgroundColor: \"#ffffff\",\n        plotBorderColor: \"#cccccc\"\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      caption: {\n        margin: 15,\n        text: \"\",\n        align: \"left\",\n        verticalAlign: \"bottom\"\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function labelFormatter() {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: f.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: f.isTouchDevice ? 25 : 10,\n        headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n        backgroundColor: n(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n    \"\";\n    f.time = new a(y(f.defaultOptions.global, f.defaultOptions.time));\n\n    f.dateFormat = function (a, n, C) {\n      return f.time.dateFormat(a, n, C);\n    };\n\n    return {\n      dateFormat: f.dateFormat,\n      defaultOptions: f.defaultOptions,\n      time: f.time\n    };\n  });\n  O(n, \"Core/Axis/Axis.js\", [n[\"Core/Color.js\"], n[\"Core/Globals.js\"], n[\"Core/Axis/Tick.js\"], n[\"Core/Utilities.js\"], n[\"Core/Options.js\"]], function (f, a, n, y, D) {\n    var G = y.addEvent,\n        C = y.animObject,\n        J = y.arrayMax,\n        H = y.arrayMin,\n        v = y.clamp,\n        L = y.correctFloat,\n        q = y.defined,\n        K = y.destroyObjectProperties,\n        E = y.error,\n        p = y.extend,\n        t = y.fireEvent,\n        I = y.format,\n        u = y.getMagnitude,\n        m = y.isArray,\n        h = y.isFunction,\n        l = y.isNumber,\n        k = y.isString,\n        g = y.merge,\n        d = y.normalizeTickInterval,\n        x = y.objectEach,\n        r = y.pick,\n        A = y.relativeLength,\n        N = y.removeEvent,\n        B = y.splat,\n        M = y.syncTimeout,\n        R = D.defaultOptions,\n        F = a.deg2rad;\n\n    y = function () {\n      function e(c, b) {\n        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.oldMin = this.oldMax = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;\n        this.init(c, b);\n      }\n\n      e.prototype.init = function (c, b) {\n        var e = b.isX,\n            d = this;\n        d.chart = c;\n        d.horiz = c.inverted && !d.isZAxis ? !e : e;\n        d.isXAxis = e;\n        d.coll = d.coll || (e ? \"xAxis\" : \"yAxis\");\n        t(this, \"init\", {\n          userOptions: b\n        });\n        d.opposite = b.opposite;\n        d.side = b.side || (d.horiz ? d.opposite ? 0 : 2 : d.opposite ? 1 : 3);\n        d.setOptions(b);\n        var g = this.options,\n            k = g.type;\n        d.labelFormatter = g.labels.formatter || d.defaultLabelFormatter;\n        d.userOptions = b;\n        d.minPixelPadding = 0;\n        d.reversed = g.reversed;\n        d.visible = !1 !== g.visible;\n        d.zoomEnabled = !1 !== g.zoomEnabled;\n        d.hasNames = \"category\" === k || !0 === g.categories;\n        d.categories = g.categories || d.hasNames;\n        d.names || (d.names = [], d.names.keys = {});\n        d.plotLinesAndBandsGroups = {};\n        d.positiveValuesOnly = !!d.logarithmic;\n        d.isLinked = q(g.linkedTo);\n        d.ticks = {};\n        d.labelEdge = [];\n        d.minorTicks = {};\n        d.plotLinesAndBands = [];\n        d.alternateBands = {};\n        d.len = 0;\n        d.minRange = d.userMinRange = g.minRange || g.maxZoom;\n        d.range = g.range;\n        d.offset = g.offset || 0;\n        d.max = null;\n        d.min = null;\n        d.crosshair = r(g.crosshair, B(c.options.tooltip.crosshairs)[e ? 0 : 1], !1);\n        b = d.options.events;\n        -1 === c.axes.indexOf(d) && (e ? c.axes.splice(c.xAxis.length, 0, d) : c.axes.push(d), c[d.coll].push(d));\n        d.series = d.series || [];\n        c.inverted && !d.isZAxis && e && \"undefined\" === typeof d.reversed && (d.reversed = !0);\n        d.labelRotation = d.options.labels.rotation;\n        x(b, function (b, c) {\n          h(b) && G(d, c, b);\n        });\n        t(this, \"afterInit\");\n      };\n\n      e.prototype.setOptions = function (c) {\n        this.options = g(e.defaultOptions, \"yAxis\" === this.coll && e.defaultYAxisOptions, [e.defaultTopAxisOptions, e.defaultRightAxisOptions, e.defaultBottomAxisOptions, e.defaultLeftAxisOptions][this.side], g(R[this.coll], c));\n        t(this, \"afterSetOptions\", {\n          userOptions: c\n        });\n      };\n\n      e.prototype.defaultLabelFormatter = function () {\n        var c = this.axis,\n            b = l(this.value) ? this.value : NaN,\n            e = c.chart.time,\n            d = c.categories,\n            g = this.dateTimeLabelFormat,\n            k = R.lang,\n            h = k.numericSymbols;\n        k = k.numericSymbolMagnitude || 1E3;\n        var a = h && h.length,\n            r = c.options.labels.format;\n        c = c.logarithmic ? Math.abs(b) : c.tickInterval;\n        var m = this.chart,\n            x = m.numberFormatter;\n        if (r) var f = I(r, this, m);else if (d) f = \"\" + this.value;else if (g) f = e.dateFormat(g, b);else if (a && 1E3 <= c) for (; a-- && \"undefined\" === typeof f;) {\n          e = Math.pow(k, a + 1), c >= e && 0 === 10 * b % e && null !== h[a] && 0 !== b && (f = x(b / e, -1) + h[a]);\n        }\n        \"undefined\" === typeof f && (f = 1E4 <= Math.abs(b) ? x(b, -1) : x(b, -1, void 0, \"\"));\n        return f;\n      };\n\n      e.prototype.getSeriesExtremes = function () {\n        var c = this,\n            b = c.chart,\n            e;\n        t(this, \"getSeriesExtremes\", null, function () {\n          c.hasVisibleSeries = !1;\n          c.dataMin = c.dataMax = c.threshold = null;\n          c.softThreshold = !c.isXAxis;\n          c.stacking && c.stacking.buildStacks();\n          c.series.forEach(function (d) {\n            if (d.visible || !b.options.chart.ignoreHiddenSeries) {\n              var g = d.options,\n                  k = g.threshold;\n              c.hasVisibleSeries = !0;\n              c.positiveValuesOnly && 0 >= k && (k = null);\n\n              if (c.isXAxis) {\n                if (g = d.xData, g.length) {\n                  g = c.logarithmic ? g.filter(c.validatePositiveValue) : g;\n                  e = d.getXExtremes(g);\n                  var h = e.min;\n                  var a = e.max;\n                  l(h) || h instanceof Date || (g = g.filter(l), e = d.getXExtremes(g), h = e.min, a = e.max);\n                  g.length && (c.dataMin = Math.min(r(c.dataMin, h), h), c.dataMax = Math.max(r(c.dataMax, a), a));\n                }\n              } else if (d = d.applyExtremes(), l(d.dataMin) && (h = d.dataMin, c.dataMin = Math.min(r(c.dataMin, h), h)), l(d.dataMax) && (a = d.dataMax, c.dataMax = Math.max(r(c.dataMax, a), a)), q(k) && (c.threshold = k), !g.softThreshold || c.positiveValuesOnly) c.softThreshold = !1;\n            }\n          });\n        });\n        t(this, \"afterGetSeriesExtremes\");\n      };\n\n      e.prototype.translate = function (c, b, e, d, g, k) {\n        var h = this.linkedParent || this,\n            a = 1,\n            w = 0,\n            z = d ? h.oldTransA : h.transA;\n        d = d ? h.oldMin : h.min;\n        var r = h.minPixelPadding;\n        g = (h.isOrdinal || h.brokenAxis && h.brokenAxis.hasBreaks || h.logarithmic && g) && h.lin2val;\n        z || (z = h.transA);\n        e && (a *= -1, w = h.len);\n        h.reversed && (a *= -1, w -= a * (h.sector || h.len));\n        b ? (c = (c * a + w - r) / z + d, g && (c = h.lin2val(c))) : (g && (c = h.val2lin(c)), c = l(d) ? a * (c - d) * z + w + a * r + (l(k) ? z * k : 0) : void 0);\n        return c;\n      };\n\n      e.prototype.toPixels = function (c, b) {\n        return this.translate(c, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);\n      };\n\n      e.prototype.toValue = function (c, b) {\n        return this.translate(c - (b ? 0 : this.pos), !0, !this.horiz, null, !0);\n      };\n\n      e.prototype.getPlotLinePath = function (c) {\n        function b(b, c, e) {\n          if (\"pass\" !== f && b < c || b > e) f ? b = v(b, c, e) : q = !0;\n          return b;\n        }\n\n        var e = this,\n            d = e.chart,\n            g = e.left,\n            k = e.top,\n            h = c.old,\n            a = c.value,\n            m = c.translatedValue,\n            x = c.lineWidth,\n            f = c.force,\n            p,\n            B,\n            A,\n            M,\n            F = h && d.oldChartHeight || d.chartHeight,\n            u = h && d.oldChartWidth || d.chartWidth,\n            q,\n            N = e.transB;\n        c = {\n          value: a,\n          lineWidth: x,\n          old: h,\n          force: f,\n          acrossPanes: c.acrossPanes,\n          translatedValue: m\n        };\n        t(this, \"getPlotLinePath\", c, function (c) {\n          m = r(m, e.translate(a, null, null, h));\n          m = v(m, -1E5, 1E5);\n          p = A = Math.round(m + N);\n          B = M = Math.round(F - m - N);\n          l(m) ? e.horiz ? (B = k, M = F - e.bottom, p = A = b(p, g, g + e.width)) : (p = g, A = u - e.right, B = M = b(B, k, k + e.height)) : (q = !0, f = !1);\n          c.path = q && !f ? null : d.renderer.crispLine([[\"M\", p, B], [\"L\", A, M]], x || 1);\n        });\n        return c.path;\n      };\n\n      e.prototype.getLinearTickPositions = function (c, b, e) {\n        var d = L(Math.floor(b / c) * c);\n        e = L(Math.ceil(e / c) * c);\n        var g = [],\n            k;\n        L(d + c) === d && (k = 20);\n        if (this.single) return [b];\n\n        for (b = d; b <= e;) {\n          g.push(b);\n          b = L(b + c, k);\n          if (b === h) break;\n          var h = b;\n        }\n\n        return g;\n      };\n\n      e.prototype.getMinorTickInterval = function () {\n        var c = this.options;\n        return !0 === c.minorTicks ? r(c.minorTickInterval, \"auto\") : !1 === c.minorTicks ? null : c.minorTickInterval;\n      };\n\n      e.prototype.getMinorTickPositions = function () {\n        var c = this.options,\n            b = this.tickPositions,\n            e = this.minorTickInterval,\n            d = [],\n            g = this.pointRangePadding || 0,\n            k = this.min - g;\n        g = this.max + g;\n        var h = g - k;\n\n        if (h && h / e < this.len / 3) {\n          var a = this.logarithmic;\n          if (a) this.paddedTicks.forEach(function (b, c, g) {\n            c && d.push.apply(d, a.getLogTickPositions(e, g[c - 1], g[c], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) d = d.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(e), k, g, c.startOfWeek));else for (c = k + (b[0] - k) % e; c <= g && c !== d[0]; c += e) {\n            d.push(c);\n          }\n        }\n\n        0 !== d.length && this.trimTicks(d);\n        return d;\n      };\n\n      e.prototype.adjustForMinRange = function () {\n        var c = this.options,\n            b = this.min,\n            e = this.max,\n            d = this.logarithmic,\n            g,\n            k,\n            h,\n            a,\n            l;\n        this.isXAxis && \"undefined\" === typeof this.minRange && !d && (q(c.min) || q(c.max) ? this.minRange = null : (this.series.forEach(function (b) {\n          a = b.xData;\n\n          for (k = l = b.xIncrement ? 1 : a.length - 1; 0 < k; k--) {\n            if (h = a[k] - a[k - 1], \"undefined\" === typeof g || h < g) g = h;\n          }\n        }), this.minRange = Math.min(5 * g, this.dataMax - this.dataMin)));\n\n        if (e - b < this.minRange) {\n          var m = this.dataMax - this.dataMin >= this.minRange;\n          var x = this.minRange;\n          var f = (x - e + b) / 2;\n          f = [b - f, r(c.min, b - f)];\n          m && (f[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);\n          b = J(f);\n          e = [b + x, r(c.max, b + x)];\n          m && (e[2] = d ? d.log2lin(this.dataMax) : this.dataMax);\n          e = H(e);\n          e - b < x && (f[0] = e - x, f[1] = r(c.min, e - x), b = J(f));\n        }\n\n        this.min = b;\n        this.max = e;\n      };\n\n      e.prototype.getClosest = function () {\n        var c;\n        this.categories ? c = 1 : this.series.forEach(function (b) {\n          var e = b.closestPointRange,\n              d = b.visible || !b.chart.options.chart.ignoreHiddenSeries;\n          !b.noSharedTooltip && q(e) && d && (c = q(c) ? Math.min(c, e) : e);\n        });\n        return c;\n      };\n\n      e.prototype.nameToX = function (c) {\n        var b = m(this.categories),\n            e = b ? this.categories : this.names,\n            d = c.options.x;\n        c.series.requireSorting = !1;\n        q(d) || (d = !1 === this.options.uniqueNames ? c.series.autoIncrement() : b ? e.indexOf(c.name) : r(e.keys[c.name], -1));\n\n        if (-1 === d) {\n          if (!b) var g = e.length;\n        } else g = d;\n\n        \"undefined\" !== typeof g && (this.names[g] = c.name, this.names.keys[c.name] = g);\n        return g;\n      };\n\n      e.prototype.updateNames = function () {\n        var c = this,\n            b = this.names;\n        0 < b.length && (Object.keys(b.keys).forEach(function (c) {\n          delete b.keys[c];\n        }), b.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (b) {\n          b.xIncrement = null;\n          if (!b.points || b.isDirtyData) c.max = Math.max(c.max, b.xData.length - 1), b.processData(), b.generatePoints();\n          b.data.forEach(function (e, d) {\n            if (e && e.options && \"undefined\" !== typeof e.name) {\n              var g = c.nameToX(e);\n              \"undefined\" !== typeof g && g !== e.x && (e.x = g, b.xData[d] = g);\n            }\n          });\n        }));\n      };\n\n      e.prototype.setAxisTranslation = function (c) {\n        var b = this,\n            e = b.max - b.min,\n            d = b.axisPointRange || 0,\n            g = 0,\n            h = 0,\n            a = b.linkedParent,\n            l = !!b.categories,\n            m = b.transA,\n            x = b.isXAxis;\n\n        if (x || l || d) {\n          var f = b.getClosest();\n          a ? (g = a.minPointOffset, h = a.pointRangePadding) : b.series.forEach(function (c) {\n            var e = l ? 1 : x ? r(c.options.pointRange, f, 0) : b.axisPointRange || 0,\n                a = c.options.pointPlacement;\n            d = Math.max(d, e);\n            if (!b.single || l) c = c.is(\"xrange\") ? !x : x, g = Math.max(g, c && k(a) ? 0 : e / 2), h = Math.max(h, c && \"on\" === a ? 0 : e);\n          });\n          a = b.ordinal && b.ordinal.slope && f ? b.ordinal.slope / f : 1;\n          b.minPointOffset = g *= a;\n          b.pointRangePadding = h *= a;\n          b.pointRange = Math.min(d, b.single && l ? 1 : e);\n          x && (b.closestPointRange = f);\n        }\n\n        c && (b.oldTransA = m);\n        b.translationSlope = b.transA = m = b.staticScale || b.len / (e + h || 1);\n        b.transB = b.horiz ? b.left : b.bottom;\n        b.minPixelPadding = m * g;\n        t(this, \"afterSetAxisTranslation\");\n      };\n\n      e.prototype.minFromRange = function () {\n        return this.max - this.range;\n      };\n\n      e.prototype.setTickInterval = function (c) {\n        var b = this,\n            e = b.chart,\n            g = b.logarithmic,\n            k = b.options,\n            h = b.isXAxis,\n            a = b.isLinked,\n            m = k.maxPadding,\n            x = k.minPadding,\n            f = k.tickInterval,\n            p = k.tickPixelInterval,\n            B = b.categories,\n            A = l(b.threshold) ? b.threshold : null,\n            Q = b.softThreshold;\n        b.dateTime || B || a || this.getTickAmount();\n        var M = r(b.userMin, k.min);\n        var F = r(b.userMax, k.max);\n\n        if (a) {\n          b.linkedParent = e[b.coll][k.linkedTo];\n          var N = b.linkedParent.getExtremes();\n          b.min = r(N.min, N.dataMin);\n          b.max = r(N.max, N.dataMax);\n          k.type !== b.linkedParent.options.type && E(11, 1, e);\n        } else {\n          if (Q && q(A)) if (b.dataMin >= A) N = A, x = 0;else if (b.dataMax <= A) {\n            var v = A;\n            m = 0;\n          }\n          b.min = r(M, N, b.dataMin);\n          b.max = r(F, v, b.dataMax);\n        }\n\n        g && (b.positiveValuesOnly && !c && 0 >= Math.min(b.min, r(b.dataMin, b.min)) && E(10, 1, e), b.min = L(g.log2lin(b.min), 16), b.max = L(g.log2lin(b.max), 16));\n        b.range && q(b.max) && (b.userMin = b.min = M = Math.max(b.dataMin, b.minFromRange()), b.userMax = F = b.max, b.range = null);\n        t(b, \"foundExtremes\");\n        b.beforePadding && b.beforePadding();\n        b.adjustForMinRange();\n        !(B || b.axisPointRange || b.stacking && b.stacking.usePercentage || a) && q(b.min) && q(b.max) && (e = b.max - b.min) && (!q(M) && x && (b.min -= e * x), !q(F) && m && (b.max += e * m));\n        l(b.userMin) || (l(k.softMin) && k.softMin < b.min && (b.min = M = k.softMin), l(k.floor) && (b.min = Math.max(b.min, k.floor)));\n        l(b.userMax) || (l(k.softMax) && k.softMax > b.max && (b.max = F = k.softMax), l(k.ceiling) && (b.max = Math.min(b.max, k.ceiling)));\n        Q && q(b.dataMin) && (A = A || 0, !q(M) && b.min < A && b.dataMin >= A ? b.min = b.options.minRange ? Math.min(A, b.max - b.minRange) : A : !q(F) && b.max > A && b.dataMax <= A && (b.max = b.options.minRange ? Math.max(A, b.min + b.minRange) : A));\n        b.tickInterval = b.min === b.max || \"undefined\" === typeof b.min || \"undefined\" === typeof b.max ? 1 : a && !f && p === b.linkedParent.options.tickPixelInterval ? f = b.linkedParent.tickInterval : r(f, this.tickAmount ? (b.max - b.min) / Math.max(this.tickAmount - 1, 1) : void 0, B ? 1 : (b.max - b.min) * p / Math.max(b.len, p));\n        h && !c && b.series.forEach(function (c) {\n          c.processData(b.min !== b.oldMin || b.max !== b.oldMax);\n        });\n        b.setAxisTranslation(!0);\n        t(this, \"initialAxisTranslation\");\n        b.pointRange && !f && (b.tickInterval = Math.max(b.pointRange, b.tickInterval));\n        c = r(k.minTickInterval, b.dateTime && !b.series.some(function (b) {\n          return b.noSharedTooltip;\n        }) ? b.closestPointRange : 0);\n        !f && b.tickInterval < c && (b.tickInterval = c);\n        b.dateTime || b.logarithmic || f || (b.tickInterval = d(b.tickInterval, void 0, u(b.tickInterval), r(k.allowDecimals, .5 > b.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));\n        this.tickAmount || (b.tickInterval = b.unsquish());\n        this.setTickPositions();\n      };\n\n      e.prototype.setTickPositions = function () {\n        var c = this.options,\n            b = c.tickPositions;\n        var e = this.getMinorTickInterval();\n        var d = c.tickPositioner,\n            g = this.hasVerticalPanning(),\n            k = \"colorAxis\" === this.coll,\n            h = (k || !g) && c.startOnTick;\n        g = (k || !g) && c.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === c.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === e && this.tickInterval ? this.tickInterval / 5 : e;\n        this.single = this.min === this.max && q(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== c.allowDecimals);\n        this.tickPositions = e = b && b.slice();\n        !e && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? e = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, c.units), this.min, this.max, c.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (e = [this.min, this.max], E(19, !1, this.chart)), e.length > this.len && (e = [e[0], e.pop()], e[0] === e[1] && (e.length = 1)), this.tickPositions = e, d && (d = d.apply(this, [this.min, this.max]))) && (this.tickPositions = e = d);\n        this.paddedTicks = e.slice(0);\n        this.trimTicks(e, h, g);\n        this.isLinked || (this.single && 2 > e.length && !this.categories && !this.series.some(function (b) {\n          return b.is(\"heatmap\") && \"between\" === b.options.pointPlacement;\n        }) && (this.min -= .5, this.max += .5), b || d || this.adjustTickAmount());\n        t(this, \"afterSetTickPositions\");\n      };\n\n      e.prototype.trimTicks = function (c, b, e) {\n        var d = c[0],\n            g = c[c.length - 1],\n            k = !this.isOrdinal && this.minPointOffset || 0;\n        t(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (b && -Infinity !== d) this.min = d;else for (; this.min - k > c[0];) {\n            c.shift();\n          }\n          if (e) this.max = g;else for (; this.max + k < c[c.length - 1];) {\n            c.pop();\n          }\n          0 === c.length && q(d) && !this.options.tickPositions && c.push((g + d) / 2);\n        }\n      };\n\n      e.prototype.alignToOthers = function () {\n        var c = {},\n            b,\n            e = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === e.alignTicks || !1 === e.startOnTick || !1 === e.endOnTick || this.logarithmic || this.chart[this.coll].forEach(function (e) {\n          var d = e.options;\n          d = [e.horiz ? d.left : d.top, d.width, d.height, d.pane].join();\n          e.series.length && (c[d] ? b = !0 : c[d] = 1);\n        });\n        return b;\n      };\n\n      e.prototype.getTickAmount = function () {\n        var c = this.options,\n            b = c.tickAmount,\n            e = c.tickPixelInterval;\n        !q(c.tickInterval) && !b && this.len < e && !this.isRadial && !this.logarithmic && c.startOnTick && c.endOnTick && (b = 2);\n        !b && this.alignToOthers() && (b = Math.ceil(this.len / e) + 1);\n        4 > b && (this.finalTickAmt = b, b = 5);\n        this.tickAmount = b;\n      };\n\n      e.prototype.adjustTickAmount = function () {\n        var c = this.options,\n            b = this.tickInterval,\n            e = this.tickPositions,\n            d = this.tickAmount,\n            g = this.finalTickAmt,\n            k = e && e.length,\n            h = r(this.threshold, this.softThreshold ? 0 : null),\n            a;\n\n        if (this.hasData()) {\n          if (k < d) {\n            for (a = this.min; e.length < d;) {\n              e.length % 2 || a === h ? e.push(L(e[e.length - 1] + b)) : e.unshift(L(e[0] - b));\n            }\n\n            this.transA *= (k - 1) / (d - 1);\n            this.min = c.startOnTick ? e[0] : Math.min(this.min, e[0]);\n            this.max = c.endOnTick ? e[e.length - 1] : Math.max(this.max, e[e.length - 1]);\n          } else k > d && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (q(g)) {\n            for (b = c = e.length; b--;) {\n              (3 === g && 1 === b % 2 || 2 >= g && 0 < b && b < c - 1) && e.splice(b, 1);\n            }\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      };\n\n      e.prototype.setScale = function () {\n        var c,\n            b = !1,\n            e = !1;\n        this.series.forEach(function (c) {\n          var d;\n          b = b || c.isDirtyData || c.isDirty;\n          e = e || (null === (d = c.xAxis) || void 0 === d ? void 0 : d.isDirty) || !1;\n        });\n        this.oldMin = this.min;\n        this.oldMax = this.max;\n        this.oldAxisLength = this.len;\n        this.setAxisSize();\n        (c = this.len !== this.oldAxisLength) || b || e || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.oldUserMin = this.userMin, this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = c || this.min !== this.oldMin || this.max !== this.oldMax)) : this.stacking && this.stacking.cleanStacks();\n        b && this.panningState && (this.panningState.isDirty = !0);\n        t(this, \"afterSetScale\");\n      };\n\n      e.prototype.setExtremes = function (c, b, e, d, g) {\n        var k = this,\n            h = k.chart;\n        e = r(e, !0);\n        k.series.forEach(function (b) {\n          delete b.kdTree;\n        });\n        g = p(g, {\n          min: c,\n          max: b\n        });\n        t(k, \"setExtremes\", g, function () {\n          k.userMin = c;\n          k.userMax = b;\n          k.eventArgs = g;\n          e && h.redraw(d);\n        });\n      };\n\n      e.prototype.zoom = function (c, b) {\n        var e = this,\n            d = this.dataMin,\n            g = this.dataMax,\n            k = this.options,\n            h = Math.min(d, r(k.min, d)),\n            a = Math.max(g, r(k.max, g));\n        c = {\n          newMin: c,\n          newMax: b\n        };\n        t(this, \"zoom\", c, function (b) {\n          var c = b.newMin,\n              k = b.newMax;\n          if (c !== e.min || k !== e.max) e.allowZoomOutside || (q(d) && (c < h && (c = h), c > a && (c = a)), q(g) && (k < h && (k = h), k > a && (k = a))), e.displayBtn = \"undefined\" !== typeof c || \"undefined\" !== typeof k, e.setExtremes(c, k, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          b.zoomed = !0;\n        });\n        return c.zoomed;\n      };\n\n      e.prototype.setAxisSize = function () {\n        var c = this.chart,\n            b = this.options,\n            e = b.offsets || [0, 0, 0, 0],\n            d = this.horiz,\n            g = this.width = Math.round(A(r(b.width, c.plotWidth - e[3] + e[1]), c.plotWidth)),\n            k = this.height = Math.round(A(r(b.height, c.plotHeight - e[0] + e[2]), c.plotHeight)),\n            h = this.top = Math.round(A(r(b.top, c.plotTop + e[0]), c.plotHeight, c.plotTop));\n        b = this.left = Math.round(A(r(b.left, c.plotLeft + e[3]), c.plotWidth, c.plotLeft));\n        this.bottom = c.chartHeight - k - h;\n        this.right = c.chartWidth - g - b;\n        this.len = Math.max(d ? g : k, 0);\n        this.pos = d ? b : h;\n      };\n\n      e.prototype.getExtremes = function () {\n        var c = this.logarithmic;\n        return {\n          min: c ? L(c.lin2log(this.min)) : this.min,\n          max: c ? L(c.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      };\n\n      e.prototype.getThreshold = function (c) {\n        var b = this.logarithmic,\n            e = b ? b.lin2log(this.min) : this.min;\n        b = b ? b.lin2log(this.max) : this.max;\n        null === c || -Infinity === c ? c = e : Infinity === c ? c = b : e > c ? c = e : b < c && (c = b);\n        return this.translate(c, 0, 1, 0, 1);\n      };\n\n      e.prototype.autoLabelAlign = function (c) {\n        var b = (r(c, 0) - 90 * this.side + 720) % 360;\n        c = {\n          align: \"center\"\n        };\n        t(this, \"autoLabelAlign\", c, function (c) {\n          15 < b && 165 > b ? c.align = \"right\" : 195 < b && 345 > b && (c.align = \"left\");\n        });\n        return c.align;\n      };\n\n      e.prototype.tickSize = function (c) {\n        var b = this.options,\n            e = b[\"tick\" === c ? \"tickLength\" : \"minorTickLength\"],\n            d = r(b[\"tick\" === c ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === c && this.isXAxis && !this.categories ? 1 : 0);\n\n        if (d && e) {\n          \"inside\" === b[c + \"Position\"] && (e = -e);\n          var g = [e, d];\n        }\n\n        c = {\n          tickSize: g\n        };\n        t(this, \"afterTickSize\", c);\n        return c.tickSize;\n      };\n\n      e.prototype.labelMetrics = function () {\n        var c = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[c] && this.ticks[c].label);\n      };\n\n      e.prototype.unsquish = function () {\n        var c = this.options.labels,\n            b = this.horiz,\n            e = this.tickInterval,\n            d = e,\n            g = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / e),\n            k,\n            h = c.rotation,\n            a = this.labelMetrics(),\n            l,\n            m = Number.MAX_VALUE,\n            x,\n            f = this.max - this.min,\n            p = function p(b) {\n          var c = b / (g || 1);\n          c = 1 < c ? Math.ceil(c) : 1;\n          c * e > f && Infinity !== b && Infinity !== g && f && (c = Math.ceil(f / e));\n          return L(c * e);\n        };\n\n        b ? (x = !c.staggerLines && !c.step && (q(h) ? [h] : g < r(c.autoRotationLimit, 80) && c.autoRotation)) && x.forEach(function (b) {\n          if (b === h || b && -90 <= b && 90 >= b) {\n            l = p(Math.abs(a.h / Math.sin(F * b)));\n            var c = l + Math.abs(b / 360);\n            c < m && (m = c, k = b, d = l);\n          }\n        }) : c.step || (d = p(a.h));\n        this.autoRotation = x;\n        this.labelRotation = r(k, h);\n        return d;\n      };\n\n      e.prototype.getSlotWidth = function (c) {\n        var b,\n            e = this.chart,\n            d = this.horiz,\n            g = this.options.labels,\n            k = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            h = e.margin[3];\n        if (c && l(c.slotWidth)) return c.slotWidth;\n        if (d && g && 2 > (g.step || 0)) return g.rotation ? 0 : (this.staggerLines || 1) * this.len / k;\n\n        if (!d) {\n          c = null === (b = null === g || void 0 === g ? void 0 : g.style) || void 0 === b ? void 0 : b.width;\n          if (void 0 !== c) return parseInt(c, 10);\n          if (h) return h - e.spacing[3];\n        }\n\n        return .33 * e.chartWidth;\n      };\n\n      e.prototype.renderUnsquish = function () {\n        var c = this.chart,\n            b = c.renderer,\n            e = this.tickPositions,\n            d = this.ticks,\n            g = this.options.labels,\n            h = g && g.style || {},\n            a = this.horiz,\n            l = this.getSlotWidth(),\n            m = Math.max(1, Math.round(l - 2 * (g.padding || 5))),\n            r = {},\n            x = this.labelMetrics(),\n            f = g.style && g.style.textOverflow,\n            p = 0;\n        k(g.rotation) || (r.rotation = g.rotation || 0);\n        e.forEach(function (b) {\n          b = d[b];\n          b.movedLabel && b.replaceMovedLabel();\n          b && b.label && b.label.textPxLength > p && (p = b.label.textPxLength);\n        });\n        this.maxLabelLength = p;\n        if (this.autoRotation) p > m && p > x.h ? r.rotation = this.labelRotation : this.labelRotation = 0;else if (l) {\n          var B = m;\n\n          if (!f) {\n            var A = \"clip\";\n\n            for (m = e.length; !a && m--;) {\n              var t = e[m];\n              if (t = d[t].label) t.styles && \"ellipsis\" === t.styles.textOverflow ? t.css({\n                textOverflow: \"clip\"\n              }) : t.textPxLength > l && t.css({\n                width: l + \"px\"\n              }), t.getBBox().height > this.len / e.length - (x.h - x.f) && (t.specificTextOverflow = \"ellipsis\");\n            }\n          }\n        }\n        r.rotation && (B = p > .5 * c.chartHeight ? .33 * c.chartHeight : p, f || (A = \"ellipsis\"));\n        if (this.labelAlign = g.align || this.autoLabelAlign(this.labelRotation)) r.align = this.labelAlign;\n        e.forEach(function (b) {\n          var c = (b = d[b]) && b.label,\n              e = h.width,\n              g = {};\n          c && (c.attr(r), b.shortenLabel ? b.shortenLabel() : B && !e && \"nowrap\" !== h.whiteSpace && (B < c.textPxLength || \"SPAN\" === c.element.tagName) ? (g.width = B + \"px\", f || (g.textOverflow = c.specificTextOverflow || A), c.css(g)) : c.styles && c.styles.width && !g.width && !e && c.css({\n            width: null\n          }), delete c.specificTextOverflow, b.rotation = r.rotation);\n        }, this);\n        this.tickRotCorr = b.rotCorr(x.b, this.labelRotation || 0, 0 !== this.side);\n      };\n\n      e.prototype.hasData = function () {\n        return this.series.some(function (c) {\n          return c.hasData();\n        }) || this.options.showEmpty && q(this.min) && q(this.max);\n      };\n\n      e.prototype.addTitle = function (c) {\n        var b = this.chart.renderer,\n            e = this.horiz,\n            d = this.opposite,\n            k = this.options.title,\n            h,\n            a = this.chart.styledMode;\n        this.axisTitle || ((h = k.textAlign) || (h = (e ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: d ? \"right\" : \"left\",\n          middle: \"center\",\n          high: d ? \"left\" : \"right\"\n        })[k.align]), this.axisTitle = b.text(k.text, 0, 0, k.useHTML).attr({\n          zIndex: 7,\n          rotation: k.rotation || 0,\n          align: h\n        }).addClass(\"highcharts-axis-title\"), a || this.axisTitle.css(g(k.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        a || k.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        });\n        this.axisTitle[c ? \"show\" : \"hide\"](c);\n      };\n\n      e.prototype.generateTick = function (c) {\n        var b = this.ticks;\n        b[c] ? b[c].addLabel() : b[c] = new n(this, c);\n      };\n\n      e.prototype.getOffset = function () {\n        var c = this,\n            b = c.chart,\n            e = b.renderer,\n            d = c.options,\n            g = c.tickPositions,\n            k = c.ticks,\n            h = c.horiz,\n            a = c.side,\n            l = b.inverted && !c.isZAxis ? [1, 0, 3, 2][a] : a,\n            m,\n            f = 0,\n            p = 0,\n            B = d.title,\n            A = d.labels,\n            M = 0,\n            F = b.axisOffset;\n        b = b.clipOffset;\n        var u = [-1, 1, 1, -1][a],\n            N = d.className,\n            v = c.axisParent;\n        var I = c.hasData();\n        c.showAxis = m = I || r(d.showEmpty, !0);\n        c.staggerLines = c.horiz && A.staggerLines;\n        c.axisGroup || (c.gridGroup = e.g(\"grid\").attr({\n          zIndex: d.gridZIndex || 1\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \"-grid \" + (N || \"\")).add(v), c.axisGroup = e.g(\"axis\").attr({\n          zIndex: d.zIndex || 2\n        }).addClass(\"highcharts-\" + this.coll.toLowerCase() + \" \" + (N || \"\")).add(v), c.labelGroup = e.g(\"axis-labels\").attr({\n          zIndex: A.zIndex || 7\n        }).addClass(\"highcharts-\" + c.coll.toLowerCase() + \"-labels \" + (N || \"\")).add(v));\n        I || c.isLinked ? (g.forEach(function (b, e) {\n          c.generateTick(b, e);\n        }), c.renderUnsquish(), c.reserveSpaceDefault = 0 === a || 2 === a || {\n          1: \"left\",\n          3: \"right\"\n        }[a] === c.labelAlign, r(A.reserveSpace, \"center\" === c.labelAlign ? !0 : null, c.reserveSpaceDefault) && g.forEach(function (b) {\n          M = Math.max(k[b].getLabelSize(), M);\n        }), c.staggerLines && (M *= c.staggerLines), c.labelOffset = M * (c.opposite ? -1 : 1)) : x(k, function (b, c) {\n          b.destroy();\n          delete k[c];\n        });\n\n        if (B && B.text && !1 !== B.enabled && (c.addTitle(m), m && !1 !== B.reserveSpace)) {\n          c.titleOffset = f = c.axisTitle.getBBox()[h ? \"height\" : \"width\"];\n          var R = B.offset;\n          p = q(R) ? 0 : r(B.margin, h ? 5 : 10);\n        }\n\n        c.renderLine();\n        c.offset = u * r(d.offset, F[a] ? F[a] + (d.margin || 0) : 0);\n        c.tickRotCorr = c.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        e = 0 === a ? -c.labelMetrics().h : 2 === a ? c.tickRotCorr.y : 0;\n        p = Math.abs(M) + p;\n        M && (p = p - e + u * (h ? r(A.y, c.tickRotCorr.y + 8 * u) : A.x));\n        c.axisTitleMargin = r(R, p);\n        c.getMaxLabelDimensions && (c.maxLabelDimensions = c.getMaxLabelDimensions(k, g));\n        h = this.tickSize(\"tick\");\n        F[a] = Math.max(F[a], c.axisTitleMargin + f + u * c.offset, p, g && g.length && h ? h[0] + u * c.offset : 0);\n        d = d.offset ? 0 : 2 * Math.floor(c.axisLine.strokeWidth() / 2);\n        b[l] = Math.max(b[l], d);\n        t(this, \"afterGetOffset\");\n      };\n\n      e.prototype.getLinePath = function (c) {\n        var b = this.chart,\n            e = this.opposite,\n            d = this.offset,\n            g = this.horiz,\n            k = this.left + (e ? this.width : 0) + d;\n        d = b.chartHeight - this.bottom - (e ? this.height : 0) + d;\n        e && (c *= -1);\n        return b.renderer.crispLine([[\"M\", g ? this.left : k, g ? d : this.top], [\"L\", g ? b.chartWidth - this.right : k, g ? d : b.chartHeight - this.bottom]], c);\n      };\n\n      e.prototype.renderLine = function () {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      };\n\n      e.prototype.getTitlePosition = function () {\n        var c = this.horiz,\n            b = this.left,\n            e = this.top,\n            d = this.len,\n            g = this.options.title,\n            k = c ? b : e,\n            h = this.opposite,\n            a = this.offset,\n            l = g.x || 0,\n            m = g.y || 0,\n            r = this.axisTitle,\n            x = this.chart.renderer.fontMetrics(g.style && g.style.fontSize, r);\n        r = Math.max(r.getBBox(null, 0).height - x.h - 1, 0);\n        d = {\n          low: k + (c ? 0 : d),\n          middle: k + d / 2,\n          high: k + (c ? d : 0)\n        }[g.align];\n        b = (c ? e + this.height : b) + (c ? 1 : -1) * (h ? -1 : 1) * this.axisTitleMargin + [-r, r, x.f, -r][this.side];\n        c = {\n          x: c ? d + l : b + (h ? this.width : 0) + a + l,\n          y: c ? b + m - (h ? this.height : 0) + a : d + m\n        };\n        t(this, \"afterGetTitlePosition\", {\n          titlePosition: c\n        });\n        return c;\n      };\n\n      e.prototype.renderMinorTick = function (c) {\n        var b = this.chart.hasRendered && l(this.oldMin),\n            e = this.minorTicks;\n        e[c] || (e[c] = new n(this, c, \"minor\"));\n        b && e[c].isNew && e[c].render(null, !0);\n        e[c].render(null, !1, 1);\n      };\n\n      e.prototype.renderTick = function (c, b) {\n        var e = this.isLinked,\n            d = this.ticks,\n            g = this.chart.hasRendered && l(this.oldMin);\n        if (!e || c >= this.min && c <= this.max) d[c] || (d[c] = new n(this, c)), g && d[c].isNew && d[c].render(b, !0, -1), d[c].render(b);\n      };\n\n      e.prototype.render = function () {\n        var c = this,\n            b = c.chart,\n            e = c.logarithmic,\n            d = c.options,\n            g = c.isLinked,\n            k = c.tickPositions,\n            h = c.axisTitle,\n            m = c.ticks,\n            r = c.minorTicks,\n            f = c.alternateBands,\n            p = d.stackLabels,\n            B = d.alternateGridColor,\n            A = c.tickmarkOffset,\n            Q = c.axisLine,\n            F = c.showAxis,\n            u = C(b.renderer.globalAnimation),\n            q,\n            N;\n        c.labelEdge.length = 0;\n        c.overlap = !1;\n        [m, r, f].forEach(function (b) {\n          x(b, function (b) {\n            b.isActive = !1;\n          });\n        });\n        if (c.hasData() || g) c.minorTickInterval && !c.categories && c.getMinorTickPositions().forEach(function (b) {\n          c.renderMinorTick(b);\n        }), k.length && (k.forEach(function (b, e) {\n          c.renderTick(b, e);\n        }), A && (0 === c.min || c.single) && (m[-1] || (m[-1] = new n(c, -1, null, !0)), m[-1].render(-1))), B && k.forEach(function (d, g) {\n          N = \"undefined\" !== typeof k[g + 1] ? k[g + 1] + A : c.max - A;\n          0 === g % 2 && d < c.max && N <= c.max + (b.polar ? -A : A) && (f[d] || (f[d] = new a.PlotLineOrBand(c)), q = d + A, f[d].options = {\n            from: e ? e.lin2log(q) : q,\n            to: e ? e.lin2log(N) : N,\n            color: B,\n            className: \"highcharts-alternate-grid\"\n          }, f[d].render(), f[d].isActive = !0);\n        }), c._addedPlotLB || ((d.plotLines || []).concat(d.plotBands || []).forEach(function (b) {\n          c.addPlotBandOrLine(b);\n        }), c._addedPlotLB = !0);\n        [m, r, f].forEach(function (c) {\n          var e,\n              d = [],\n              g = u.duration;\n          x(c, function (b, c) {\n            b.isActive || (b.render(c, !1, 0), b.isActive = !1, d.push(c));\n          });\n          M(function () {\n            for (e = d.length; e--;) {\n              c[d[e]] && !c[d[e]].isActive && (c[d[e]].destroy(), delete c[d[e]]);\n            }\n          }, c !== f && b.hasRendered && g ? g : 0);\n        });\n        Q && (Q[Q.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(Q.strokeWidth())\n        }), Q.isPlaced = !0, Q[F ? \"show\" : \"hide\"](F));\n        h && F && (d = c.getTitlePosition(), l(d.y) ? (h[h.isNew ? \"attr\" : \"animate\"](d), h.isNew = !1) : (h.attr(\"y\", -9999), h.isNew = !0));\n        p && p.enabled && c.stacking && c.stacking.renderStackTotals();\n        c.isDirty = !1;\n        t(this, \"afterRender\");\n      };\n\n      e.prototype.redraw = function () {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (c) {\n          c.render();\n        }));\n        this.series.forEach(function (c) {\n          c.isDirty = !0;\n        });\n      };\n\n      e.prototype.getKeepProps = function () {\n        return this.keepProps || e.keepProps;\n      };\n\n      e.prototype.destroy = function (c) {\n        var b = this,\n            e = b.plotLinesAndBands,\n            d;\n        t(this, \"destroy\", {\n          keepEvents: c\n        });\n        c || N(b);\n        [b.ticks, b.minorTicks, b.alternateBands].forEach(function (b) {\n          K(b);\n        });\n        if (e) for (c = e.length; c--;) {\n          e[c].destroy();\n        }\n        \"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (c) {\n          b[c] && (b[c] = b[c].destroy());\n        });\n\n        for (d in b.plotLinesAndBandsGroups) {\n          b.plotLinesAndBandsGroups[d] = b.plotLinesAndBandsGroups[d].destroy();\n        }\n\n        x(b, function (c, e) {\n          -1 === b.getKeepProps().indexOf(e) && delete b[e];\n        });\n      };\n\n      e.prototype.drawCrosshair = function (c, b) {\n        var e = this.crosshair,\n            d = r(e.snap, !0),\n            g,\n            k = this.cross,\n            h = this.chart;\n        t(this, \"drawCrosshair\", {\n          e: c,\n          point: b\n        });\n        c || (c = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (q(b) || !d)) {\n          d ? q(b) && (g = r(\"colorAxis\" !== this.coll ? b.crosshairPos : null, this.isXAxis ? b.plotX : this.len - b.plotY)) : g = c && (this.horiz ? c.chartX - this.pos : this.len - c.chartY + this.pos);\n\n          if (q(g)) {\n            var a = {\n              value: b && (this.isXAxis ? b.x : r(b.stackY, b.y)),\n              translatedValue: g\n            };\n            h.polar && p(a, {\n              isCrosshair: !0,\n              chartX: c && c.chartX,\n              chartY: c && c.chartY,\n              point: b\n            });\n            a = this.getPlotLinePath(a) || null;\n          }\n\n          if (!q(a)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          d = this.categories && !this.isRadial;\n          k || (this.cross = k = h.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (d ? \"category \" : \"thin \") + e.className).attr({\n            zIndex: r(e.zIndex, 2)\n          }).add(), h.styledMode || (k.attr({\n            stroke: e.color || (d ? f.parse(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": r(e.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), e.dashStyle && k.attr({\n            dashstyle: e.dashStyle\n          })));\n          k.show().attr({\n            d: a\n          });\n          d && !e.width && k.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = c;\n        } else this.hideCrosshair();\n\n        t(this, \"afterDrawCrosshair\", {\n          e: c,\n          point: b\n        });\n      };\n\n      e.prototype.hideCrosshair = function () {\n        this.cross && this.cross.hide();\n        t(this, \"afterHideCrosshair\");\n      };\n\n      e.prototype.hasVerticalPanning = function () {\n        var c, b;\n        return /y/.test((null === (b = null === (c = this.chart.options.chart) || void 0 === c ? void 0 : c.panning) || void 0 === b ? void 0 : b.type) || \"\");\n      };\n\n      e.prototype.validatePositiveValue = function (c) {\n        return l(c) && 0 < c;\n      };\n\n      e.defaultOptions = {\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e. %b\"\n          },\n          week: {\n            main: \"%e. %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          indentation: 10,\n          x: 0,\n          style: {\n            color: \"#666666\",\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        showEmpty: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: \"#666666\"\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: \"#f2f2f2\",\n        minorGridLineWidth: 1,\n        minorTickColor: \"#999999\",\n        lineColor: \"#ccd6eb\",\n        lineWidth: 1,\n        gridLineColor: \"#e6e6e6\",\n        tickColor: \"#ccd6eb\"\n      };\n      e.defaultYAxisOptions = {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          animation: {},\n          allowOverlap: !1,\n          enabled: !1,\n          crop: !0,\n          overflow: \"justify\",\n          formatter: function formatter() {\n            var c = this.axis.chart.numberFormatter;\n            return c(this.total, -1);\n          },\n          style: {\n            color: \"#000000\",\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      };\n      e.defaultLeftAxisOptions = {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      };\n      e.defaultRightAxisOptions = {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      };\n      e.defaultBottomAxisOptions = {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      e.defaultTopAxisOptions = {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      e.keepProps = \"extKey hcEvents names series userMax userMin\".split(\" \");\n      return e;\n    }();\n\n    a.Axis = y;\n    return a.Axis;\n  });\n  O(n, \"Core/Axis/DateTimeAxis.js\", [n[\"Core/Axis/Axis.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = a.addEvent,\n        y = a.getMagnitude,\n        D = a.normalizeTickInterval,\n        G = a.timeUnits,\n        C = function () {\n      function a(a) {\n        this.axis = a;\n      }\n\n      a.prototype.normalizeTimeTickInterval = function (a, f) {\n        var v = f || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n        f = v[v.length - 1];\n        var q = G[f[0]],\n            H = f[1],\n            E;\n\n        for (E = 0; E < v.length && !(f = v[E], q = G[f[0]], H = f[1], v[E + 1] && a <= (q * H[H.length - 1] + G[v[E + 1][0]]) / 2); E++) {\n          ;\n        }\n\n        q === G.year && a < 5 * q && (H = [1, 2, 5]);\n        a = D(a / q, H, \"year\" === f[0] ? Math.max(y(a / q), 1) : 1);\n        return {\n          unitRange: q,\n          count: a,\n          unitName: f[0]\n        };\n      };\n\n      return a;\n    }();\n\n    a = function () {\n      function a() {}\n\n      a.compose = function (a) {\n        a.keepProps.push(\"dateTime\");\n\n        a.prototype.getTimeTicks = function () {\n          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n        };\n\n        n(a, \"init\", function (a) {\n          \"datetime\" !== a.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new C(this));\n        });\n      };\n\n      a.AdditionsClass = C;\n      return a;\n    }();\n\n    a.compose(f);\n    return a;\n  });\n  O(n, \"Core/Axis/LogarithmicAxis.js\", [n[\"Core/Axis/Axis.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = a.addEvent,\n        y = a.getMagnitude,\n        D = a.normalizeTickInterval,\n        G = a.pick,\n        C = function () {\n      function a(a) {\n        this.axis = a;\n      }\n\n      a.prototype.getLogTickPositions = function (a, f, n, q) {\n        var v = this.axis,\n            E = v.len,\n            p = v.options,\n            t = [];\n        q || (this.minorAutoInterval = void 0);\n        if (.5 <= a) a = Math.round(a), t = v.getLinearTickPositions(a, f, n);else if (.08 <= a) {\n          p = Math.floor(f);\n          var I, u;\n\n          for (E = .3 < a ? [1, 2, 4] : .15 < a ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; p < n + 1 && !u; p++) {\n            var m = E.length;\n\n            for (I = 0; I < m && !u; I++) {\n              var h = this.log2lin(this.lin2log(p) * E[I]);\n              h > f && (!q || l <= n) && \"undefined\" !== typeof l && t.push(l);\n              l > n && (u = !0);\n              var l = h;\n            }\n          }\n        } else f = this.lin2log(f), n = this.lin2log(n), a = q ? v.getMinorTickInterval() : p.tickInterval, a = G(\"auto\" === a ? null : a, this.minorAutoInterval, p.tickPixelInterval / (q ? 5 : 1) * (n - f) / ((q ? E / v.tickPositions.length : E) || 1)), a = D(a, void 0, y(a)), t = v.getLinearTickPositions(a, f, n).map(this.log2lin), q || (this.minorAutoInterval = a / 5);\n        q || (v.tickInterval = a);\n        return t;\n      };\n\n      a.prototype.lin2log = function (a) {\n        return Math.pow(10, a);\n      };\n\n      a.prototype.log2lin = function (a) {\n        return Math.log(a) / Math.LN10;\n      };\n\n      return a;\n    }();\n\n    a = function () {\n      function a() {}\n\n      a.compose = function (a) {\n        a.keepProps.push(\"logarithmic\");\n        var f = a.prototype,\n            H = C.prototype;\n        f.log2lin = H.log2lin;\n        f.lin2log = H.lin2log;\n        n(a, \"init\", function (a) {\n          var f = this.logarithmic;\n          \"logarithmic\" !== a.userOptions.type ? this.logarithmic = void 0 : (f || (f = this.logarithmic = new C(this)), this.log2lin !== f.log2lin && (f.log2lin = this.log2lin.bind(this)), this.lin2log !== f.lin2log && (f.lin2log = this.lin2log.bind(this)));\n        });\n        n(a, \"afterInit\", function () {\n          var a = this.logarithmic;\n          a && (this.lin2val = function (f) {\n            return a.lin2log(f);\n          }, this.val2lin = function (f) {\n            return a.log2lin(f);\n          });\n        });\n      };\n\n      return a;\n    }();\n\n    a.compose(f);\n    return a;\n  });\n  O(n, \"Core/Axis/PlotLineOrBand.js\", [n[\"Core/Axis/Axis.js\"], n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a, n) {\n    var y = n.arrayMax,\n        D = n.arrayMin,\n        G = n.defined,\n        C = n.destroyObjectProperties,\n        J = n.erase,\n        H = n.extend,\n        v = n.merge,\n        L = n.objectEach,\n        q = n.pick,\n        K = function () {\n      function f(a, f) {\n        this.axis = a;\n        f && (this.options = f, this.id = f.id);\n      }\n\n      f.prototype.render = function () {\n        a.fireEvent(this, \"render\");\n        var f = this,\n            t = f.axis,\n            I = t.horiz,\n            u = t.logarithmic,\n            m = f.options,\n            h = m.label,\n            l = f.label,\n            k = m.to,\n            g = m.from,\n            d = m.value,\n            x = G(g) && G(k),\n            r = G(d),\n            A = f.svgElem,\n            N = !A,\n            B = [],\n            M = m.color,\n            R = q(m.zIndex, 0),\n            F = m.events;\n        B = {\n          \"class\": \"highcharts-plot-\" + (x ? \"band \" : \"line \") + (m.className || \"\")\n        };\n        var e = {},\n            c = t.chart.renderer,\n            b = x ? \"bands\" : \"lines\";\n        u && (g = u.log2lin(g), k = u.log2lin(k), d = u.log2lin(d));\n        t.chart.styledMode || (r ? (B.stroke = M || \"#999999\", B[\"stroke-width\"] = q(m.width, 1), m.dashStyle && (B.dashstyle = m.dashStyle)) : x && (B.fill = M || \"#e6ebf5\", m.borderWidth && (B.stroke = m.borderColor, B[\"stroke-width\"] = m.borderWidth)));\n        e.zIndex = R;\n        b += \"-\" + R;\n        (u = t.plotLinesAndBandsGroups[b]) || (t.plotLinesAndBandsGroups[b] = u = c.g(\"plot-\" + b).attr(e).add());\n        N && (f.svgElem = A = c.path().attr(B).add(u));\n        if (r) B = t.getPlotLinePath({\n          value: d,\n          lineWidth: A.strokeWidth(),\n          acrossPanes: m.acrossPanes\n        });else if (x) B = t.getPlotBandPath(g, k, m);else return;\n        !f.eventsAdded && F && (L(F, function (b, c) {\n          A.on(c, function (b) {\n            F[c].apply(f, [b]);\n          });\n        }), f.eventsAdded = !0);\n        (N || !A.d) && B && B.length ? A.attr({\n          d: B\n        }) : A && (B ? (A.show(!0), A.animate({\n          d: B\n        })) : A.d && (A.hide(), l && (f.label = l = l.destroy())));\n        h && (G(h.text) || G(h.formatter)) && B && B.length && 0 < t.width && 0 < t.height && !B.isFlat ? (h = v({\n          align: I && x && \"center\",\n          x: I ? !x && 4 : 10,\n          verticalAlign: !I && x && \"middle\",\n          y: I ? x ? 16 : 10 : x ? 6 : -4,\n          rotation: I && !x && 90\n        }, h), this.renderLabel(h, B, x, R)) : l && l.hide();\n        return f;\n      };\n\n      f.prototype.renderLabel = function (a, f, q, u) {\n        var m = this.label,\n            h = this.axis.chart.renderer;\n        m || (m = {\n          align: a.textAlign || a.align,\n          rotation: a.rotation,\n          \"class\": \"highcharts-plot-\" + (q ? \"band\" : \"line\") + \"-label \" + (a.className || \"\")\n        }, m.zIndex = u, u = this.getLabelText(a), this.label = m = h.text(u, 0, 0, a.useHTML).attr(m).add(), this.axis.chart.styledMode || m.css(a.style));\n        h = f.xBounds || [f[0][1], f[1][1], q ? f[2][1] : f[0][1]];\n        f = f.yBounds || [f[0][2], f[1][2], q ? f[2][2] : f[0][2]];\n        q = D(h);\n        u = D(f);\n        m.align(a, !1, {\n          x: q,\n          y: u,\n          width: y(h) - q,\n          height: y(f) - u\n        });\n        m.show(!0);\n      };\n\n      f.prototype.getLabelText = function (a) {\n        return G(a.formatter) ? a.formatter.call(this) : a.text;\n      };\n\n      f.prototype.destroy = function () {\n        J(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        C(this);\n      };\n\n      return f;\n    }();\n\n    H(f.prototype, {\n      getPlotBandPath: function getPlotBandPath(a, f) {\n        var p = this.getPlotLinePath({\n          value: f,\n          force: !0,\n          acrossPanes: this.options.acrossPanes\n        }),\n            q = this.getPlotLinePath({\n          value: a,\n          force: !0,\n          acrossPanes: this.options.acrossPanes\n        }),\n            u = [],\n            m = this.horiz,\n            h = 1;\n        a = a < this.min && f < this.min || a > this.max && f > this.max;\n\n        if (q && p) {\n          if (a) {\n            var l = q.toString() === p.toString();\n            h = 0;\n          }\n\n          for (a = 0; a < q.length; a += 2) {\n            f = q[a];\n            var k = q[a + 1],\n                g = p[a],\n                d = p[a + 1];\n            \"M\" !== f[0] && \"L\" !== f[0] || \"M\" !== k[0] && \"L\" !== k[0] || \"M\" !== g[0] && \"L\" !== g[0] || \"M\" !== d[0] && \"L\" !== d[0] || (m && g[1] === f[1] ? (g[1] += h, d[1] += h) : m || g[2] !== f[2] || (g[2] += h, d[2] += h), u.push([\"M\", f[1], f[2]], [\"L\", k[1], k[2]], [\"L\", d[1], d[2]], [\"L\", g[1], g[2]], [\"Z\"]));\n            u.isFlat = l;\n          }\n        }\n\n        return u;\n      },\n      addPlotBand: function addPlotBand(a) {\n        return this.addPlotBandOrLine(a, \"plotBands\");\n      },\n      addPlotLine: function addPlotLine(a) {\n        return this.addPlotBandOrLine(a, \"plotLines\");\n      },\n      addPlotBandOrLine: function addPlotBandOrLine(a, f) {\n        var p = new K(this, a).render(),\n            q = this.userOptions;\n\n        if (p) {\n          if (f) {\n            var u = q[f] || [];\n            u.push(a);\n            q[f] = u;\n          }\n\n          this.plotLinesAndBands.push(p);\n          this._addedPlotLB = !0;\n        }\n\n        return p;\n      },\n      removePlotBandOrLine: function removePlotBandOrLine(a) {\n        for (var f = this.plotLinesAndBands, t = this.options, q = this.userOptions, u = f.length; u--;) {\n          f[u].id === a && f[u].destroy();\n        }\n\n        [t.plotLines || [], q.plotLines || [], t.plotBands || [], q.plotBands || []].forEach(function (f) {\n          for (u = f.length; u--;) {\n            (f[u] || {}).id === a && J(f, f[u]);\n          }\n        });\n      },\n      removePlotBand: function removePlotBand(a) {\n        this.removePlotBandOrLine(a);\n      },\n      removePlotLine: function removePlotLine(a) {\n        this.removePlotBandOrLine(a);\n      }\n    });\n    a.PlotLineOrBand = K;\n    return a.PlotLineOrBand;\n  });\n  O(n, \"Core/Tooltip.js\", [n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = f.doc,\n        y = a.clamp,\n        D = a.css,\n        G = a.defined,\n        C = a.discardElement,\n        J = a.extend,\n        H = a.fireEvent,\n        v = a.format,\n        L = a.isNumber,\n        q = a.isString,\n        K = a.merge,\n        E = a.pick,\n        p = a.splat,\n        t = a.syncTimeout,\n        I = a.timeUnits;\n    \"\";\n\n    var u = function () {\n      function m(h, a) {\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.chart = h;\n        this.init(h, a);\n      }\n\n      m.prototype.applyFilter = function () {\n        var h = this.chart;\n        h.renderer.definition({\n          tagName: \"filter\",\n          id: \"drop-shadow-\" + h.index,\n          opacity: .5,\n          children: [{\n            tagName: \"feGaussianBlur\",\n            \"in\": \"SourceAlpha\",\n            stdDeviation: 1\n          }, {\n            tagName: \"feOffset\",\n            dx: 1,\n            dy: 1\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              type: \"linear\",\n              slope: .3\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              \"in\": \"SourceGraphic\"\n            }]\n          }]\n        });\n        h.renderer.definition({\n          tagName: \"style\",\n          textContent: \".highcharts-tooltip-\" + h.index + \"{filter:url(#drop-shadow-\" + h.index + \")}\"\n        });\n      };\n\n      m.prototype.bodyFormatter = function (h) {\n        return h.map(function (h) {\n          var k = h.series.tooltipOptions;\n          return (k[(h.point.formatPrefix || \"point\") + \"Formatter\"] || h.point.tooltipFormatter).call(h.point, k[(h.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      };\n\n      m.prototype.cleanSplit = function (h) {\n        this.chart.series.forEach(function (a) {\n          var k = a && a.tt;\n          k && (!k.isActive || h ? a.tt = k.destroy() : k.isActive = !1);\n        });\n      };\n\n      m.prototype.defaultFormatter = function (h) {\n        var a = this.points || p(this);\n        var k = [h.tooltipFooterHeaderFormatter(a[0])];\n        k = k.concat(h.bodyFormatter(a));\n        k.push(h.tooltipFooterHeaderFormatter(a[0], !0));\n        return k;\n      };\n\n      m.prototype.destroy = function () {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), C(this.container));\n        a.clearTimeout(this.hideTimer);\n        a.clearTimeout(this.tooltipTimeout);\n      };\n\n      m.prototype.getAnchor = function (h, a) {\n        var k = this.chart,\n            g = k.pointer,\n            d = k.inverted,\n            l = k.plotTop,\n            f = k.plotLeft,\n            m = 0,\n            t = 0,\n            B,\n            M;\n        h = p(h);\n        this.followPointer && a ? (\"undefined\" === typeof a.chartX && (a = g.normalize(a)), h = [a.chartX - f, a.chartY - l]) : h[0].tooltipPos ? h = h[0].tooltipPos : (h.forEach(function (g) {\n          B = g.series.yAxis;\n          M = g.series.xAxis;\n          m += g.plotX + (!d && M ? M.left - f : 0);\n          t += (g.plotLow ? (g.plotLow + g.plotHigh) / 2 : g.plotY) + (!d && B ? B.top - l : 0);\n        }), m /= h.length, t /= h.length, h = [d ? k.plotWidth - t : m, this.shared && !d && 1 < h.length && a ? a.chartY - l : d ? k.plotHeight - m : t]);\n        return h.map(Math.round);\n      };\n\n      m.prototype.getDateFormat = function (h, a, k, g) {\n        var d = this.chart.time,\n            l = d.dateFormat(\"%m-%d %H:%M:%S.%L\", a),\n            f = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            m = \"millisecond\";\n\n        for (p in I) {\n          if (h === I.week && +d.dateFormat(\"%w\", a) === k && \"00:00:00.000\" === l.substr(6)) {\n            var p = \"week\";\n            break;\n          }\n\n          if (I[p] > h) {\n            p = m;\n            break;\n          }\n\n          if (f[p] && l.substr(f[p]) !== \"01-01 00:00:00.000\".substr(f[p])) break;\n          \"week\" !== p && (m = p);\n        }\n\n        if (p) var B = d.resolveDTLFormat(g[p]).main;\n        return B;\n      };\n\n      m.prototype.getLabel = function () {\n        var h,\n            a,\n            k = this,\n            g = this.chart.renderer,\n            d = this.chart.styledMode,\n            m = this.options,\n            r = \"tooltip\" + (G(m.className) ? \" \" + m.className : \"\"),\n            p = (null === (h = m.style) || void 0 === h ? void 0 : h.pointerEvents) || (!this.followPointer && m.stickOnContact ? \"auto\" : \"none\"),\n            t;\n\n        h = function h() {\n          k.inContact = !0;\n        };\n\n        var B = function B() {\n          var e = k.chart.hoverSeries;\n          k.inContact = !1;\n          if (e && e.onMouseOut) e.onMouseOut();\n        };\n\n        if (!this.label) {\n          this.outside && (this.container = t = f.doc.createElement(\"div\"), t.className = \"highcharts-tooltip-container\", D(t, {\n            position: \"absolute\",\n            top: \"1px\",\n            pointerEvents: p,\n            zIndex: 3\n          }), f.doc.body.appendChild(t), this.renderer = g = new f.Renderer(t, 0, 0, null === (a = this.chart.options.chart) || void 0 === a ? void 0 : a.style, void 0, void 0, g.styledMode));\n          this.split ? this.label = g.g(r) : (this.label = g.label(\"\", 0, 0, m.shape || \"callout\", null, null, m.useHTML, null, r).attr({\n            padding: m.padding,\n            r: m.borderRadius\n          }), d || this.label.attr({\n            fill: m.backgroundColor,\n            \"stroke-width\": m.borderWidth\n          }).css(m.style).css({\n            pointerEvents: p\n          }).shadow(m.shadow));\n          d && (this.applyFilter(), this.label.addClass(\"highcharts-tooltip-\" + this.chart.index));\n\n          if (k.outside && !k.split) {\n            var M = this.label,\n                q = M.xSetter,\n                F = M.ySetter;\n\n            M.xSetter = function (e) {\n              q.call(M, k.distance);\n              t.style.left = e + \"px\";\n            };\n\n            M.ySetter = function (e) {\n              F.call(M, k.distance);\n              t.style.top = e + \"px\";\n            };\n          }\n\n          this.label.on(\"mouseenter\", h).on(\"mouseleave\", B).attr({\n            zIndex: 8\n          }).add();\n        }\n\n        return this.label;\n      };\n\n      m.prototype.getPosition = function (a, l, k) {\n        var g = this.chart,\n            d = this.distance,\n            h = {},\n            f = g.inverted && k.h || 0,\n            m,\n            p = this.outside,\n            B = p ? n.documentElement.clientWidth - 2 * d : g.chartWidth,\n            M = p ? Math.max(n.body.scrollHeight, n.documentElement.scrollHeight, n.body.offsetHeight, n.documentElement.offsetHeight, n.documentElement.clientHeight) : g.chartHeight,\n            t = g.pointer.getChartPosition(),\n            F = g.containerScaling,\n            e = function e(b) {\n          return F ? b * F.scaleX : b;\n        },\n            c = function c(b) {\n          return F ? b * F.scaleY : b;\n        },\n            b = function b(_b) {\n          var h = \"x\" === _b;\n          return [_b, h ? B : M, h ? a : l].concat(p ? [h ? e(a) : c(l), h ? t.left - d + e(k.plotX + g.plotLeft) : t.top - d + c(k.plotY + g.plotTop), 0, h ? B : M] : [h ? a : l, h ? k.plotX + g.plotLeft : k.plotY + g.plotTop, h ? g.plotLeft : g.plotTop, h ? g.plotLeft + g.plotWidth : g.plotTop + g.plotHeight]);\n        },\n            z = b(\"y\"),\n            w = b(\"x\"),\n            q = !this.followPointer && E(k.ttBelow, !g.inverted === !!k.negative),\n            u = function u(b, g, k, a, l, m, r) {\n          var x = \"y\" === b ? c(d) : e(d),\n              w = (k - a) / 2,\n              p = a < l - d,\n              B = l + d + a < g,\n              z = l - x - k + w;\n          l = l + x - w;\n          if (q && B) h[b] = l;else if (!q && p) h[b] = z;else if (p) h[b] = Math.min(r - a, 0 > z - f ? z : z - f);else if (B) h[b] = Math.max(m, l + f + k > g ? l : l + f);else return !1;\n        },\n            v = function v(b, c, e, g, k) {\n          var a;\n          k < d || k > c - d ? a = !1 : h[b] = k < e / 2 ? 1 : k > c - g / 2 ? c - g - 2 : k - e / 2;\n          return a;\n        },\n            I = function I(b) {\n          var c = z;\n          z = w;\n          w = c;\n          m = b;\n        },\n            H = function H() {\n          !1 !== u.apply(0, z) ? !1 !== v.apply(0, w) || m || (I(!0), H()) : m ? h.x = h.y = 0 : (I(!0), H());\n        };\n\n        (g.inverted || 1 < this.len) && I();\n        H();\n        return h;\n      };\n\n      m.prototype.getXDateFormat = function (a, l, k) {\n        l = l.dateTimeLabelFormats;\n        var g = k && k.closestPointRange;\n        return (g ? this.getDateFormat(g, a.x, k.options.startOfWeek, l) : l.day) || l.year;\n      };\n\n      m.prototype.hide = function (h) {\n        var l = this;\n        a.clearTimeout(this.hideTimer);\n        h = E(h, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = t(function () {\n          l.getLabel().fadeOut(h ? void 0 : h);\n          l.isHidden = !0;\n        }, h));\n      };\n\n      m.prototype.init = function (a, l) {\n        this.chart = a;\n        this.options = l;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = l.split && !a.inverted && !a.polar;\n        this.shared = l.shared || this.split;\n        this.outside = E(l.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));\n      };\n\n      m.prototype.isStickyOnContact = function () {\n        return !(this.followPointer || !this.options.stickOnContact || !this.inContact);\n      };\n\n      m.prototype.move = function (h, l, k, g) {\n        var d = this,\n            f = d.now,\n            m = !1 !== d.options.animation && !d.isHidden && (1 < Math.abs(h - f.x) || 1 < Math.abs(l - f.y)),\n            p = d.followPointer || 1 < d.len;\n        J(f, {\n          x: m ? (2 * f.x + h) / 3 : h,\n          y: m ? (f.y + l) / 2 : l,\n          anchorX: p ? void 0 : m ? (2 * f.anchorX + k) / 3 : k,\n          anchorY: p ? void 0 : m ? (f.anchorY + g) / 2 : g\n        });\n        d.getLabel().attr(f);\n        d.drawTracker();\n        m && (a.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          d && d.move(h, l, k, g);\n        }, 32));\n      };\n\n      m.prototype.refresh = function (h, l) {\n        var k = this.chart,\n            g = this.options,\n            d = h,\n            f = {},\n            m = [],\n            A = g.formatter || this.defaultFormatter;\n        f = this.shared;\n        var t = k.styledMode;\n\n        if (g.enabled) {\n          a.clearTimeout(this.hideTimer);\n          this.followPointer = p(d)[0].series.tooltipOptions.followPointer;\n          var B = this.getAnchor(d, l);\n          l = B[0];\n          var M = B[1];\n          !f || d.series && d.series.noSharedTooltip ? f = d.getLabelConfig() : (k.pointer.applyInactiveState(d), d.forEach(function (d) {\n            d.setState(\"hover\");\n            m.push(d.getLabelConfig());\n          }), f = {\n            x: d[0].category,\n            y: d[0].y\n          }, f.points = m, d = d[0]);\n          this.len = m.length;\n          k = A.call(f, this);\n          A = d.series;\n          this.distance = E(A.tooltipOptions.distance, 16);\n          !1 === k ? this.hide() : (this.split ? this.renderSplit(k, p(h)) : (h = this.getLabel(), g.style.width && !t || h.css({\n            width: this.chart.spacingBox.width + \"px\"\n          }), h.attr({\n            text: k && k.join ? k.join(\"\") : k\n          }), h.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + E(d.colorIndex, A.colorIndex)), t || h.attr({\n            stroke: g.borderColor || d.color || A.color || \"#666666\"\n          }), this.updatePosition({\n            plotX: l,\n            plotY: M,\n            negative: d.negative,\n            ttBelow: d.ttBelow,\n            h: B[2] || 0\n          })), this.isHidden && this.label && this.label.attr({\n            opacity: 1\n          }).show(), this.isHidden = !1);\n          H(this, \"refresh\");\n        }\n      };\n\n      m.prototype.renderSplit = function (a, l) {\n        function k(b, c, e, d, g) {\n          void 0 === g && (g = !0);\n          e ? (c = H ? 0 : G, b = y(b - d / 2, n.left, n.right - d)) : (c -= K, b = g ? b - d - z : b + z, b = y(b, g ? b : n.left, n.right));\n          return {\n            x: b,\n            y: c\n          };\n        }\n\n        var g = this,\n            d = g.chart,\n            h = g.chart,\n            m = h.plotHeight,\n            p = h.plotLeft,\n            t = h.plotTop,\n            B = h.pointer,\n            M = h.renderer,\n            u = h.scrollablePixelsY,\n            F = void 0 === u ? 0 : u;\n        u = h.scrollingContainer;\n        u = void 0 === u ? {\n          scrollLeft: 0,\n          scrollTop: 0\n        } : u;\n        var e = u.scrollLeft,\n            c = u.scrollTop,\n            b = h.styledMode,\n            z = g.distance,\n            w = g.options,\n            v = g.options.positioner,\n            n = {\n          left: e,\n          right: e + h.chartWidth,\n          top: c,\n          bottom: c + h.chartHeight\n        },\n            I = g.getLabel(),\n            H = !(!d.xAxis[0] || !d.xAxis[0].opposite),\n            K = t + c,\n            C = 0,\n            G = m - F;\n        q(a) && (a = [!1, a]);\n        a = a.slice(0, l.length + 1).reduce(function (e, d, a) {\n          if (!1 !== d && \"\" !== d) {\n            a = l[a - 1] || {\n              isHeader: !0,\n              plotX: l[0].plotX,\n              plotY: m,\n              series: {}\n            };\n            var h = a.isHeader,\n                f = h ? g : a.series,\n                r = f.tt,\n                x = a.isHeader;\n            var B = a.series;\n            var A = \"highcharts-color-\" + E(a.colorIndex, B.colorIndex, \"none\");\n            r || (r = {\n              padding: w.padding,\n              r: w.borderRadius\n            }, b || (r.fill = w.backgroundColor, r[\"stroke-width\"] = w.borderWidth), r = M.label(\"\", 0, 0, w[x ? \"headerShape\" : \"shape\"] || \"callout\", void 0, void 0, w.useHTML).addClass((x ? \"highcharts-tooltip-header \" : \"\") + \"highcharts-tooltip-box \" + A).attr(r).add(I));\n            r.isActive = !0;\n            r.attr({\n              text: d\n            });\n            b || r.css(w.style).shadow(w.shadow).attr({\n              stroke: w.borderColor || a.color || B.color || \"#333333\"\n            });\n            d = f.tt = r;\n            x = d.getBBox();\n            f = x.width + d.strokeWidth();\n            h && (C = x.height, G += C, H && (K -= C));\n            B = a.plotX;\n            B = void 0 === B ? 0 : B;\n            A = a.plotY;\n            A = void 0 === A ? 0 : A;\n            var Q = a.series;\n\n            if (a.isHeader) {\n              B = p + B;\n              var u = t + m / 2;\n            } else r = Q.xAxis, Q = Q.yAxis, B = r.pos + y(B, -z, r.len + z), Q.pos + A >= c + t && Q.pos + A <= c + t + m - F && (u = Q.pos + A);\n\n            B = y(B, n.left - z, n.right + z);\n            \"number\" === typeof u ? (x = x.height + 1, A = v ? v.call(g, f, x, a) : k(B, u, h, f), e.push({\n              align: v ? 0 : void 0,\n              anchorX: B,\n              anchorY: u,\n              boxWidth: f,\n              point: a,\n              rank: E(A.rank, h ? 1 : 0),\n              size: x,\n              target: A.y,\n              tt: d,\n              x: A.x\n            })) : d.isActive = !1;\n          }\n\n          return e;\n        }, []);\n        !v && a.some(function (b) {\n          return b.x < n.left;\n        }) && (a = a.map(function (b) {\n          var c = k(b.anchorX, b.anchorY, b.point.isHeader, b.boxWidth, !1);\n          return J(b, {\n            target: c.y,\n            x: c.x\n          });\n        }));\n        g.cleanSplit();\n        f.distribute(a, G);\n        a.forEach(function (b) {\n          var c = b.pos;\n          b.tt.attr({\n            visibility: \"undefined\" === typeof c ? \"hidden\" : \"inherit\",\n            x: b.x,\n            y: c + K,\n            anchorX: b.anchorX,\n            anchorY: b.anchorY\n          });\n        });\n        a = g.container;\n        d = g.renderer;\n        g.outside && a && d && (h = I.getBBox(), d.setSize(h.width + h.x, h.height + h.y, !1), B = B.getChartPosition(), a.style.left = B.left + \"px\", a.style.top = B.top + \"px\");\n      };\n\n      m.prototype.drawTracker = function () {\n        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {\n          var a = this.chart,\n              l = this.label,\n              k = a.hoverPoint;\n\n          if (l && k) {\n            var g = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n            k = this.getAnchor(k);\n            var d = l.getBBox();\n            k[0] += a.plotLeft - l.translateX;\n            k[1] += a.plotTop - l.translateY;\n            g.x = Math.min(0, k[0]);\n            g.y = Math.min(0, k[1]);\n            g.width = 0 > k[0] ? Math.max(Math.abs(k[0]), d.width - k[0]) : Math.max(Math.abs(k[0]), d.width);\n            g.height = 0 > k[1] ? Math.max(Math.abs(k[1]), d.height - Math.abs(k[1])) : Math.max(Math.abs(k[1]), d.height);\n            this.tracker ? this.tracker.attr(g) : (this.tracker = l.renderer.rect(g).addClass(\"highcharts-tracker\").add(l), a.styledMode || this.tracker.attr({\n              fill: \"rgba(0,0,0,0)\"\n            }));\n          }\n        }\n      };\n\n      m.prototype.styledModeFormat = function (a) {\n        return a.replace('style=\"font-size: 10px\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex}\"');\n      };\n\n      m.prototype.tooltipFooterHeaderFormatter = function (a, l) {\n        var k = l ? \"footer\" : \"header\",\n            g = a.series,\n            d = g.tooltipOptions,\n            h = d.xDateFormat,\n            f = g.xAxis,\n            m = f && \"datetime\" === f.options.type && L(a.key),\n            p = d[k + \"Format\"];\n        l = {\n          isFooter: l,\n          labelConfig: a\n        };\n        H(this, \"headerFormatter\", l, function (k) {\n          m && !h && (h = this.getXDateFormat(a, d, f));\n          m && h && (a.point && a.point.tooltipDateKeys || [\"key\"]).forEach(function (d) {\n            p = p.replace(\"{point.\" + d + \"}\", \"{point.\" + d + \":\" + h + \"}\");\n          });\n          g.chart.styledMode && (p = this.styledModeFormat(p));\n          k.text = v(p, {\n            point: a,\n            series: g\n          }, this.chart);\n        });\n        return l.text;\n      };\n\n      m.prototype.update = function (a) {\n        this.destroy();\n        K(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, K(!0, this.options, a));\n      };\n\n      m.prototype.updatePosition = function (a) {\n        var h = this.chart,\n            k = h.pointer,\n            g = this.getLabel(),\n            d = a.plotX + h.plotLeft,\n            f = a.plotY + h.plotTop;\n        k = k.getChartPosition();\n        a = (this.options.positioner || this.getPosition).call(this, g.width, g.height, a);\n\n        if (this.outside) {\n          var m = (this.options.borderWidth || 0) + 2 * this.distance;\n          this.renderer.setSize(g.width + m, g.height + m, !1);\n          if (h = h.containerScaling) D(this.container, {\n            transform: \"scale(\" + h.scaleX + \", \" + h.scaleY + \")\"\n          }), d *= h.scaleX, f *= h.scaleY;\n          d += k.left - a.x;\n          f += k.top - a.y;\n        }\n\n        this.move(Math.round(a.x), Math.round(a.y || 0), d, f);\n      };\n\n      return m;\n    }();\n\n    f.Tooltip = u;\n    return f.Tooltip;\n  });\n  O(n, \"Core/Pointer.js\", [n[\"Core/Color.js\"], n[\"Core/Globals.js\"], n[\"Core/Tooltip.js\"], n[\"Core/Utilities.js\"]], function (f, a, n, y) {\n    var D = f.parse,\n        G = a.charts,\n        C = a.noop,\n        J = y.addEvent,\n        H = y.attr,\n        v = y.css,\n        L = y.defined,\n        q = y.extend,\n        K = y.find,\n        E = y.fireEvent,\n        p = y.isNumber,\n        t = y.isObject,\n        I = y.objectEach,\n        u = y.offset,\n        m = y.pick,\n        h = y.splat;\n    \"\";\n\n    f = function () {\n      function l(a, g) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.chart = a;\n        this.hasDragged = !1;\n        this.options = g;\n\n        this.unbindContainerMouseLeave = function () {};\n\n        this.unbindContainerMouseEnter = function () {};\n\n        this.init(a, g);\n      }\n\n      l.prototype.applyInactiveState = function (a) {\n        var g = [],\n            d;\n        (a || []).forEach(function (a) {\n          d = a.series;\n          g.push(d);\n          d.linkedParent && g.push(d.linkedParent);\n          d.linkedSeries && (g = g.concat(d.linkedSeries));\n          d.navigatorSeries && g.push(d.navigatorSeries);\n        });\n        this.chart.series.forEach(function (d) {\n          -1 === g.indexOf(d) ? d.setState(\"inactive\", !0) : d.options.inactiveOtherPoints && d.setAllPointsToState(\"inactive\");\n        });\n      };\n\n      l.prototype.destroy = function () {\n        var k = this;\n        \"undefined\" !== typeof k.unDocMouseMove && k.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        a.chartCount || (a.unbindDocumentMouseUp && (a.unbindDocumentMouseUp = a.unbindDocumentMouseUp()), a.unbindDocumentTouchEnd && (a.unbindDocumentTouchEnd = a.unbindDocumentTouchEnd()));\n        clearInterval(k.tooltipTimeout);\n        I(k, function (g, d) {\n          k[d] = void 0;\n        });\n      };\n\n      l.prototype.drag = function (a) {\n        var g = this.chart,\n            d = g.options.chart,\n            k = a.chartX,\n            h = a.chartY,\n            l = this.zoomHor,\n            f = this.zoomVert,\n            m = g.plotLeft,\n            p = g.plotTop,\n            u = g.plotWidth,\n            F = g.plotHeight,\n            e = this.selectionMarker,\n            c = this.mouseDownX || 0,\n            b = this.mouseDownY || 0,\n            z = t(d.panning) ? d.panning && d.panning.enabled : d.panning,\n            w = d.panKey && a[d.panKey + \"Key\"];\n        if (!e || !e.touch) if (k < m ? k = m : k > m + u && (k = m + u), h < p ? h = p : h > p + F && (h = p + F), this.hasDragged = Math.sqrt(Math.pow(c - k, 2) + Math.pow(b - h, 2)), 10 < this.hasDragged) {\n          var q = g.isInsidePlot(c - m, b - p);\n          g.hasCartesianSeries && (this.zoomX || this.zoomY) && q && !w && !e && (this.selectionMarker = e = g.renderer.rect(m, p, l ? 1 : u, f ? 1 : F, 0).attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), g.styledMode || e.attr({\n            fill: d.selectionMarkerFill || D(\"#335cad\").setOpacity(.25).get()\n          }));\n          e && l && (k -= c, e.attr({\n            width: Math.abs(k),\n            x: (0 < k ? 0 : k) + c\n          }));\n          e && f && (k = h - b, e.attr({\n            height: Math.abs(k),\n            y: (0 < k ? 0 : k) + b\n          }));\n          q && !e && z && g.pan(a, d.panning);\n        }\n      };\n\n      l.prototype.dragStart = function (a) {\n        var g = this.chart;\n        g.mouseIsDown = a.type;\n        g.cancelClick = !1;\n        g.mouseDownX = this.mouseDownX = a.chartX;\n        g.mouseDownY = this.mouseDownY = a.chartY;\n      };\n\n      l.prototype.drop = function (a) {\n        var g = this,\n            d = this.chart,\n            k = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var h = {\n            originalEvent: a,\n            xAxis: [],\n            yAxis: []\n          },\n              l = this.selectionMarker,\n              f = l.attr ? l.attr(\"x\") : l.x,\n              m = l.attr ? l.attr(\"y\") : l.y,\n              t = l.attr ? l.attr(\"width\") : l.width,\n              u = l.attr ? l.attr(\"height\") : l.height,\n              F;\n          if (this.hasDragged || k) d.axes.forEach(function (e) {\n            if (e.zoomEnabled && L(e.min) && (k || g[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[e.coll]]) && p(f) && p(m)) {\n              var c = e.horiz,\n                  b = \"touchend\" === a.type ? e.minPixelPadding : 0,\n                  d = e.toValue((c ? f : m) + b);\n              c = e.toValue((c ? f + t : m + u) - b);\n              h[e.coll].push({\n                axis: e,\n                min: Math.min(d, c),\n                max: Math.max(d, c)\n              });\n              F = !0;\n            }\n          }), F && E(d, \"selection\", h, function (e) {\n            d.zoom(q(e, k ? {\n              animation: !1\n            } : null));\n          });\n          p(d.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          k && this.scaleGroups();\n        }\n\n        d && p(d.index) && (v(d.container, {\n          cursor: d._cursor\n        }), d.cancelClick = 10 < this.hasDragged, d.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      };\n\n      l.prototype.findNearestKDPoint = function (a, g, d) {\n        var k = this.chart,\n            h = k.hoverPoint;\n        k = k.tooltip;\n        if (h && k && k.isStickyOnContact()) return h;\n        var l;\n        a.forEach(function (a) {\n          var k = !(a.noSharedTooltip && g) && 0 > a.options.findNearestPointBy.indexOf(\"y\");\n          a = a.searchPoint(d, k);\n\n          if ((k = t(a, !0)) && !(k = !t(l, !0))) {\n            k = l.distX - a.distX;\n            var h = l.dist - a.dist,\n                f = (a.series.group && a.series.group.zIndex) - (l.series.group && l.series.group.zIndex);\n            k = 0 < (0 !== k && g ? k : 0 !== h ? h : 0 !== f ? f : l.series.index > a.series.index ? -1 : 1);\n          }\n\n          k && (l = a);\n        });\n        return l;\n      };\n\n      l.prototype.getChartCoordinatesFromPoint = function (a, g) {\n        var d = a.series,\n            k = d.xAxis;\n        d = d.yAxis;\n        var h = m(a.clientX, a.plotX),\n            l = a.shapeArgs;\n        if (k && d) return g ? {\n          chartX: k.len + k.pos - h,\n          chartY: d.len + d.pos - a.plotY\n        } : {\n          chartX: h + k.pos,\n          chartY: a.plotY + d.pos\n        };\n        if (l && l.x && l.y) return {\n          chartX: l.x,\n          chartY: l.y\n        };\n      };\n\n      l.prototype.getChartPosition = function () {\n        return this.chartPosition || (this.chartPosition = u(this.chart.container));\n      };\n\n      l.prototype.getCoordinates = function (a) {\n        var g = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (d) {\n          g[d.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: d,\n            value: d.toValue(a[d.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return g;\n      };\n\n      l.prototype.getHoverData = function (a, g, d, h, l, f) {\n        var k,\n            r = [];\n        h = !(!h || !a);\n        var p = g && !g.stickyTracking,\n            x = {\n          chartX: f ? f.chartX : void 0,\n          chartY: f ? f.chartY : void 0,\n          shared: l\n        };\n        E(this, \"beforeGetHoverData\", x);\n        p = p ? [g] : d.filter(function (d) {\n          return x.filter ? x.filter(d) : d.visible && !(!l && d.directTouch) && m(d.options.enableMouseTracking, !0) && d.stickyTracking;\n        });\n        g = (k = h || !f ? a : this.findNearestKDPoint(p, l, f)) && k.series;\n        k && (l && !g.noSharedTooltip ? (p = d.filter(function (d) {\n          return x.filter ? x.filter(d) : d.visible && !(!l && d.directTouch) && m(d.options.enableMouseTracking, !0) && !d.noSharedTooltip;\n        }), p.forEach(function (d) {\n          var e = K(d.points, function (c) {\n            return c.x === k.x && !c.isNull;\n          });\n          t(e) && (d.chart.isBoosting && (e = d.getPoint(e)), r.push(e));\n        })) : r.push(k));\n        x = {\n          hoverPoint: k\n        };\n        E(this, \"afterGetHoverData\", x);\n        return {\n          hoverPoint: x.hoverPoint,\n          hoverSeries: g,\n          hoverPoints: r\n        };\n      };\n\n      l.prototype.getPointFromEvent = function (a) {\n        a = a.target;\n\n        for (var g; a && !g;) {\n          g = a.point, a = a.parentNode;\n        }\n\n        return g;\n      };\n\n      l.prototype.onTrackerMouseOut = function (a) {\n        a = a.relatedTarget || a.toElement;\n        var g = this.chart.hoverSeries;\n        this.isDirectTouch = !1;\n        if (!(!g || !a || g.stickyTracking || this.inClass(a, \"highcharts-tooltip\") || this.inClass(a, \"highcharts-series-\" + g.index) && this.inClass(a, \"highcharts-tracker\"))) g.onMouseOut();\n      };\n\n      l.prototype.inClass = function (a, g) {\n        for (var d; a;) {\n          if (d = H(a, \"class\")) {\n            if (-1 !== d.indexOf(g)) return !0;\n            if (-1 !== d.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          a = a.parentNode;\n        }\n      };\n\n      l.prototype.init = function (a, g) {\n        this.options = g;\n        this.chart = a;\n        this.runChartClick = g.chart.events && !!g.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        n && (a.tooltip = new n(a, g.tooltip), this.followTouchMove = m(g.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      };\n\n      l.prototype.normalize = function (a, g) {\n        var d = a.touches,\n            k = d ? d.length ? d.item(0) : m(d.changedTouches, a.changedTouches)[0] : a;\n        g || (g = this.getChartPosition());\n        d = k.pageX - g.left;\n        g = k.pageY - g.top;\n        if (k = this.chart.containerScaling) d /= k.scaleX, g /= k.scaleY;\n        return q(a, {\n          chartX: Math.round(d),\n          chartY: Math.round(g)\n        });\n      };\n\n      l.prototype.onContainerClick = function (a) {\n        var g = this.chart,\n            d = g.hoverPoint;\n        a = this.normalize(a);\n        var k = g.plotLeft,\n            h = g.plotTop;\n        g.cancelClick || (d && this.inClass(a.target, \"highcharts-tracker\") ? (E(d.series, \"click\", q(a, {\n          point: d\n        })), g.hoverPoint && d.firePointEvent(\"click\", a)) : (q(a, this.getCoordinates(a)), g.isInsidePlot(a.chartX - k, a.chartY - h) && E(g, \"click\", a)));\n      };\n\n      l.prototype.onContainerMouseDown = function (k) {\n        var g = 1 === ((k.buttons || k.button) & 1);\n        k = this.normalize(k);\n        if (a.isFirefox && 0 !== k.button) this.onContainerMouseMove(k);\n        if (\"undefined\" === typeof k.button || g) this.zoomOption(k), g && k.preventDefault && k.preventDefault(), this.dragStart(k);\n      };\n\n      l.prototype.onContainerMouseLeave = function (k) {\n        var g = G[m(a.hoverChartIndex, -1)],\n            d = this.chart.tooltip;\n        k = this.normalize(k);\n        g && (k.relatedTarget || k.toElement) && (g.pointer.reset(), g.pointer.chartPosition = void 0);\n        d && !d.isHidden && this.reset();\n      };\n\n      l.prototype.onContainerMouseEnter = function (a) {\n        delete this.chartPosition;\n      };\n\n      l.prototype.onContainerMouseMove = function (a) {\n        var g = this.chart;\n        a = this.normalize(a);\n        this.setHoverChartIndex();\n        a.preventDefault || (a.returnValue = !1);\n        \"mousedown\" === g.mouseIsDown && this.drag(a);\n        g.openMenu || !this.inClass(a.target, \"highcharts-tracker\") && !g.isInsidePlot(a.chartX - g.plotLeft, a.chartY - g.plotTop) || this.runPointActions(a);\n      };\n\n      l.prototype.onDocumentTouchEnd = function (k) {\n        G[a.hoverChartIndex] && G[a.hoverChartIndex].pointer.drop(k);\n      };\n\n      l.prototype.onContainerTouchMove = function (a) {\n        this.touch(a);\n      };\n\n      l.prototype.onContainerTouchStart = function (a) {\n        this.zoomOption(a);\n        this.touch(a, !0);\n      };\n\n      l.prototype.onDocumentMouseMove = function (a) {\n        var g = this.chart,\n            d = this.chartPosition;\n        a = this.normalize(a, d);\n        var h = g.tooltip;\n        !d || h && h.isStickyOnContact() || g.isInsidePlot(a.chartX - g.plotLeft, a.chartY - g.plotTop) || this.inClass(a.target, \"highcharts-tracker\") || this.reset();\n      };\n\n      l.prototype.onDocumentMouseUp = function (h) {\n        var g = G[m(a.hoverChartIndex, -1)];\n        g && g.pointer.drop(h);\n      };\n\n      l.prototype.pinch = function (a) {\n        var g = this,\n            d = g.chart,\n            h = g.pinchDown,\n            k = a.touches || [],\n            l = k.length,\n            f = g.lastValidTouch,\n            p = g.hasZoom,\n            t = g.selectionMarker,\n            u = {},\n            F = 1 === l && (g.inClass(a.target, \"highcharts-tracker\") && d.runTrackerClick || g.runChartClick),\n            e = {};\n        1 < l && (g.initiated = !0);\n        p && g.initiated && !F && a.preventDefault();\n        [].map.call(k, function (c) {\n          return g.normalize(c);\n        });\n        \"touchstart\" === a.type ? ([].forEach.call(k, function (c, b) {\n          h[b] = {\n            chartX: c.chartX,\n            chartY: c.chartY\n          };\n        }), f.x = [h[0].chartX, h[1] && h[1].chartX], f.y = [h[0].chartY, h[1] && h[1].chartY], d.axes.forEach(function (c) {\n          if (c.zoomEnabled) {\n            var b = d.bounds[c.horiz ? \"h\" : \"v\"],\n                e = c.minPixelPadding,\n                g = c.toPixels(Math.min(m(c.options.min, c.dataMin), c.dataMin)),\n                a = c.toPixels(Math.max(m(c.options.max, c.dataMax), c.dataMax)),\n                h = Math.max(g, a);\n            b.min = Math.min(c.pos, Math.min(g, a) - e);\n            b.max = Math.max(c.pos + c.len, h + e);\n          }\n        }), g.res = !0) : g.followTouchMove && 1 === l ? this.runPointActions(g.normalize(a)) : h.length && (t || (g.selectionMarker = t = q({\n          destroy: C,\n          touch: !0\n        }, d.plotBox)), g.pinchTranslate(h, k, u, t, e, f), g.hasPinched = p, g.scaleGroups(u, e), g.res && (g.res = !1, this.reset(!1, 0)));\n      };\n\n      l.prototype.pinchTranslate = function (a, g, d, h, l, f) {\n        this.zoomHor && this.pinchTranslateDirection(!0, a, g, d, h, l, f);\n        this.zoomVert && this.pinchTranslateDirection(!1, a, g, d, h, l, f);\n      };\n\n      l.prototype.pinchTranslateDirection = function (a, g, d, h, l, f, m, p) {\n        var k = this.chart,\n            r = a ? \"x\" : \"y\",\n            x = a ? \"X\" : \"Y\",\n            e = \"chart\" + x,\n            c = a ? \"width\" : \"height\",\n            b = k[\"plot\" + (a ? \"Left\" : \"Top\")],\n            B,\n            w,\n            t = p || 1,\n            A = k.inverted,\n            u = k.bounds[a ? \"h\" : \"v\"],\n            q = 1 === g.length,\n            v = g[0][e],\n            n = d[0][e],\n            I = !q && g[1][e],\n            N = !q && d[1][e];\n\n        d = function d() {\n          \"number\" === typeof N && 20 < Math.abs(v - I) && (t = p || Math.abs(n - N) / Math.abs(v - I));\n          w = (b - n) / t + v;\n          B = k[\"plot\" + (a ? \"Width\" : \"Height\")] / t;\n        };\n\n        d();\n        g = w;\n\n        if (g < u.min) {\n          g = u.min;\n          var H = !0;\n        } else g + B > u.max && (g = u.max - B, H = !0);\n\n        H ? (n -= .8 * (n - m[r][0]), \"number\" === typeof N && (N -= .8 * (N - m[r][1])), d()) : m[r] = [n, N];\n        A || (f[r] = w - b, f[c] = B);\n        f = A ? 1 / t : t;\n        l[c] = B;\n        l[r] = g;\n        h[A ? a ? \"scaleY\" : \"scaleX\" : \"scale\" + x] = t;\n        h[\"translate\" + x] = f * b + (n - f * v);\n      };\n\n      l.prototype.reset = function (a, g) {\n        var d = this.chart,\n            k = d.hoverSeries,\n            l = d.hoverPoint,\n            f = d.hoverPoints,\n            m = d.tooltip,\n            p = m && m.shared ? f : l;\n        a && p && h(p).forEach(function (d) {\n          d.series.isCartesian && \"undefined\" === typeof d.plotX && (a = !1);\n        });\n        if (a) m && p && h(p).length && (m.refresh(p), m.shared && f ? f.forEach(function (d) {\n          d.setState(d.state, !0);\n          d.series.isCartesian && (d.series.xAxis.crosshair && d.series.xAxis.drawCrosshair(null, d), d.series.yAxis.crosshair && d.series.yAxis.drawCrosshair(null, d));\n        }) : l && (l.setState(l.state, !0), d.axes.forEach(function (d) {\n          d.crosshair && l.series[d.coll] === d && d.drawCrosshair(null, l);\n        })));else {\n          if (l) l.onMouseOut();\n          f && f.forEach(function (d) {\n            d.setState();\n          });\n          if (k) k.onMouseOut();\n          m && m.hide(g);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          d.axes.forEach(function (d) {\n            d.hideCrosshair();\n          });\n          this.hoverX = d.hoverPoints = d.hoverPoint = null;\n        }\n      };\n\n      l.prototype.runPointActions = function (h, g) {\n        var d = this.chart,\n            k = d.tooltip && d.tooltip.options.enabled ? d.tooltip : void 0,\n            l = k ? k.shared : !1,\n            f = g || d.hoverPoint,\n            p = f && f.series || d.hoverSeries;\n        p = this.getHoverData(f, p, d.series, (!h || \"touchmove\" !== h.type) && (!!g || p && p.directTouch && this.isDirectTouch), l, h);\n        f = p.hoverPoint;\n        var B = p.hoverPoints;\n        g = (p = p.hoverSeries) && p.tooltipOptions.followPointer;\n        l = l && p && !p.noSharedTooltip;\n\n        if (f && (f !== d.hoverPoint || k && k.isHidden)) {\n          (d.hoverPoints || []).forEach(function (d) {\n            -1 === B.indexOf(d) && d.setState();\n          });\n          if (d.hoverSeries !== p) p.onMouseOver();\n          this.applyInactiveState(B);\n          (B || []).forEach(function (d) {\n            d.setState(\"hover\");\n          });\n          d.hoverPoint && d.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!f.series) return;\n          d.hoverPoints = B;\n          d.hoverPoint = f;\n          f.firePointEvent(\"mouseOver\");\n          k && k.refresh(l ? B : f, h);\n        } else g && k && !k.isHidden && (f = k.getAnchor([{}], h), k.updatePosition({\n          plotX: f[0],\n          plotY: f[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = J(d.container.ownerDocument, \"mousemove\", function (d) {\n          var g = G[a.hoverChartIndex];\n          if (g) g.pointer.onDocumentMouseMove(d);\n        }));\n        d.axes.forEach(function (g) {\n          var a = m((g.crosshair || {}).snap, !0),\n              k;\n          a && ((k = d.hoverPoint) && k.series[g.coll] === g || (k = K(B, function (e) {\n            return e.series[g.coll] === g;\n          })));\n          k || !a ? g.drawCrosshair(h, k) : g.hideCrosshair();\n        });\n      };\n\n      l.prototype.scaleGroups = function (a, g) {\n        var d = this.chart,\n            h;\n        d.series.forEach(function (k) {\n          h = a || k.getPlotBox();\n          k.xAxis && k.xAxis.zoomEnabled && k.group && (k.group.attr(h), k.markerGroup && (k.markerGroup.attr(h), k.markerGroup.clip(g ? d.clipRect : null)), k.dataLabelsGroup && k.dataLabelsGroup.attr(h));\n        });\n        d.clipRect.attr(g || d.clipBox);\n      };\n\n      l.prototype.setDOMEvents = function () {\n        var h = this.chart.container,\n            g = h.ownerDocument;\n        h.onmousedown = this.onContainerMouseDown.bind(this);\n        h.onmousemove = this.onContainerMouseMove.bind(this);\n        h.onclick = this.onContainerClick.bind(this);\n        this.unbindContainerMouseEnter = J(h, \"mouseenter\", this.onContainerMouseEnter.bind(this));\n        this.unbindContainerMouseLeave = J(h, \"mouseleave\", this.onContainerMouseLeave.bind(this));\n        a.unbindDocumentMouseUp || (a.unbindDocumentMouseUp = J(g, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n        a.hasTouch && (J(h, \"touchstart\", this.onContainerTouchStart.bind(this)), J(h, \"touchmove\", this.onContainerTouchMove.bind(this)), a.unbindDocumentTouchEnd || (a.unbindDocumentTouchEnd = J(g, \"touchend\", this.onDocumentTouchEnd.bind(this))));\n      };\n\n      l.prototype.setHoverChartIndex = function () {\n        var h = this.chart,\n            g = a.charts[m(a.hoverChartIndex, -1)];\n        if (g && g !== h) g.pointer.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        g && g.mouseIsDown || (a.hoverChartIndex = h.index);\n      };\n\n      l.prototype.touch = function (a, g) {\n        var d = this.chart,\n            h;\n        this.setHoverChartIndex();\n        if (1 === a.touches.length) {\n          if (a = this.normalize(a), (h = d.isInsidePlot(a.chartX - d.plotLeft, a.chartY - d.plotTop)) && !d.openMenu) {\n            g && this.runPointActions(a);\n\n            if (\"touchmove\" === a.type) {\n              g = this.pinchDown;\n              var k = g[0] ? 4 <= Math.sqrt(Math.pow(g[0].chartX - a.chartX, 2) + Math.pow(g[0].chartY - a.chartY, 2)) : !1;\n            }\n\n            m(k, !0) && this.pinch(a);\n          } else g && this.reset();\n        } else 2 === a.touches.length && this.pinch(a);\n      };\n\n      l.prototype.zoomOption = function (a) {\n        var g = this.chart,\n            d = g.options.chart,\n            h = d.zoomType || \"\";\n        g = g.inverted;\n        /touch/.test(a.type) && (h = m(d.pinchType, h));\n        this.zoomX = a = /x/.test(h);\n        this.zoomY = h = /y/.test(h);\n        this.zoomHor = a && !g || h && g;\n        this.zoomVert = h && !g || a && g;\n        this.hasZoom = a || h;\n      };\n\n      return l;\n    }();\n\n    return a.Pointer = f;\n  });\n  O(n, \"Core/MSPointer.js\", [n[\"Core/Globals.js\"], n[\"Core/Pointer.js\"], n[\"Core/Utilities.js\"]], function (f, a, n) {\n    function y() {\n      var a = [];\n\n      a.item = function (a) {\n        return this[a];\n      };\n\n      q(E, function (f) {\n        a.push({\n          pageX: f.pageX,\n          pageY: f.pageY,\n          target: f.target\n        });\n      });\n      return a;\n    }\n\n    function D(a, p, u, m) {\n      \"touch\" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !C[f.hoverChartIndex] || (m(a), m = C[f.hoverChartIndex].pointer, m[p]({\n        type: u,\n        target: a.currentTarget,\n        preventDefault: H,\n        touches: y()\n      }));\n    }\n\n    var G = this && this.__extends || function () {\n      var _a2 = function a(f, p) {\n        _a2 = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, h) {\n          a.__proto__ = h;\n        } || function (a, h) {\n          for (var l in h) {\n            h.hasOwnProperty(l) && (a[l] = h[l]);\n          }\n        };\n\n        return _a2(f, p);\n      };\n\n      return function (f, p) {\n        function m() {\n          this.constructor = f;\n        }\n\n        _a2(f, p);\n\n        f.prototype = null === p ? Object.create(p) : (m.prototype = p.prototype, new m());\n      };\n    }(),\n        C = f.charts,\n        J = f.doc,\n        H = f.noop,\n        v = n.addEvent,\n        L = n.css,\n        q = n.objectEach,\n        K = n.removeEvent,\n        E = {},\n        p = !!f.win.PointerEvent;\n\n    return function (a) {\n      function f() {\n        return null !== a && a.apply(this, arguments) || this;\n      }\n\n      G(f, a);\n\n      f.prototype.batchMSEvents = function (a) {\n        a(this.chart.container, p ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n        a(this.chart.container, p ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n        a(J, p ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n      };\n\n      f.prototype.destroy = function () {\n        this.batchMSEvents(K);\n        a.prototype.destroy.call(this);\n      };\n\n      f.prototype.init = function (f, m) {\n        a.prototype.init.call(this, f, m);\n        this.hasZoom && L(f.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      };\n\n      f.prototype.onContainerPointerDown = function (a) {\n        D(a, \"onContainerTouchStart\", \"touchstart\", function (a) {\n          E[a.pointerId] = {\n            pageX: a.pageX,\n            pageY: a.pageY,\n            target: a.currentTarget\n          };\n        });\n      };\n\n      f.prototype.onContainerPointerMove = function (a) {\n        D(a, \"onContainerTouchMove\", \"touchmove\", function (a) {\n          E[a.pointerId] = {\n            pageX: a.pageX,\n            pageY: a.pageY\n          };\n          E[a.pointerId].target || (E[a.pointerId].target = a.currentTarget);\n        });\n      };\n\n      f.prototype.onDocumentPointerUp = function (a) {\n        D(a, \"onDocumentTouchEnd\", \"touchend\", function (a) {\n          delete E[a.pointerId];\n        });\n      };\n\n      f.prototype.setDOMEvents = function () {\n        a.prototype.setDOMEvents.call(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(v);\n      };\n\n      return f;\n    }(a);\n  });\n  O(n, \"Core/Legend.js\", [n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = a.addEvent,\n        y = a.animObject,\n        D = a.css,\n        G = a.defined,\n        C = a.discardElement,\n        J = a.find,\n        H = a.fireEvent,\n        v = a.format,\n        L = a.isNumber,\n        q = a.merge,\n        K = a.pick,\n        E = a.relativeLength,\n        p = a.setAnimation,\n        t = a.stableSort,\n        I = a.syncTimeout;\n    a = a.wrap;\n\n    var u = f.isFirefox,\n        m = f.marginNames,\n        h = f.win,\n        l = function () {\n      function a(a, d) {\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = {};\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = a;\n        this.init(a, d);\n      }\n\n      a.prototype.init = function (a, d) {\n        this.chart = a;\n        this.setOptions(d);\n        d.enabled && (this.render(), n(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = n(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      };\n\n      a.prototype.setOptions = function (a) {\n        var d = K(a.padding, 8);\n        this.options = a;\n        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = q(this.itemStyle, a.itemHiddenStyle));\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.itemMarginBottom = a.itemMarginBottom || 0;\n        this.padding = d;\n        this.initialItemY = d - 5;\n        this.symbolWidth = K(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n        this.baseline = void 0;\n      };\n\n      a.prototype.update = function (a, d) {\n        var g = this.chart;\n        this.setOptions(q(!0, this.options, a));\n        this.destroy();\n        g.isDirtyLegend = g.isDirtyBox = !0;\n        K(d, !0) && g.redraw();\n        H(this, \"afterUpdate\");\n      };\n\n      a.prototype.colorizeItem = function (a, d) {\n        a.legendGroup[d ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var g = this.options,\n              h = a.legendItem,\n              k = a.legendLine,\n              f = a.legendSymbol,\n              l = this.itemHiddenStyle.color;\n          g = d ? g.itemStyle.color : l;\n          var m = d ? a.color || l : l,\n              p = a.options && a.options.marker,\n              t = {\n            fill: m\n          };\n          h && h.css({\n            fill: g,\n            color: g\n          });\n          k && k.attr({\n            stroke: m\n          });\n          f && (p && f.isMarker && (t = a.pointAttribs(), d || (t.stroke = t.fill = l)), f.attr(t));\n        }\n\n        H(this, \"afterColorizeItem\", {\n          item: a,\n          visible: d\n        });\n      };\n\n      a.prototype.positionItems = function () {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      };\n\n      a.prototype.positionItem = function (a) {\n        var d = this,\n            g = this.options,\n            h = g.symbolPadding,\n            k = !g.rtl,\n            f = a._legendItemPos;\n        g = f[0];\n        f = f[1];\n        var l = a.checkbox,\n            m = a.legendGroup;\n        m && m.element && (h = {\n          translateX: k ? g : this.legendWidth - g - 2 * h - 4,\n          translateY: f\n        }, k = function k() {\n          H(d, \"afterPositionItem\", {\n            item: a\n          });\n        }, G(m.translateY) ? m.animate(h, void 0, k) : (m.attr(h), k()));\n        l && (l.x = g, l.y = f);\n      };\n\n      a.prototype.destroyItem = function (a) {\n        var d = a.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (d) {\n          a[d] && (a[d] = a[d].destroy());\n        });\n        d && C(a.checkbox);\n      };\n\n      a.prototype.destroy = function () {\n        function a(d) {\n          this[d] && (this[d] = this[d].destroy());\n        }\n\n        this.getAllItems().forEach(function (d) {\n          [\"legendItem\", \"legendGroup\"].forEach(a, d);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(a, this);\n        this.display = null;\n      };\n\n      a.prototype.positionCheckboxes = function () {\n        var a = this.group && this.group.alignAttr,\n            d = this.clipHeight || this.legendHeight,\n            h = this.titleHeight;\n\n        if (a) {\n          var k = a.translateY;\n          this.allItems.forEach(function (g) {\n            var f = g.checkbox;\n\n            if (f) {\n              var l = k + h + f.y + (this.scrollOffset || 0) + 3;\n              D(f, {\n                left: a.translateX + g.checkboxOffset + f.x - 20 + \"px\",\n                top: l + \"px\",\n                display: this.proximate || l > k - 6 && l < k + d - 6 ? \"\" : \"none\"\n              });\n            }\n          }, this);\n        }\n      };\n\n      a.prototype.renderTitle = function () {\n        var a = this.options,\n            d = this.padding,\n            h = a.title,\n            k = 0;\n        h.text && (this.title || (this.title = this.chart.renderer.label(h.text, d - 3, d - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(h.style), this.title.add(this.group)), h.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), a = this.title.getBBox(), k = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: k\n        }));\n        this.titleHeight = k;\n      };\n\n      a.prototype.setText = function (a) {\n        var d = this.options;\n        a.legendItem.attr({\n          text: d.labelFormat ? v(d.labelFormat, a, this.chart) : d.labelFormatter.call(a)\n        });\n      };\n\n      a.prototype.renderItem = function (a) {\n        var d = this.chart,\n            g = d.renderer,\n            h = this.options,\n            k = this.symbolWidth,\n            f = h.symbolPadding,\n            l = this.itemStyle,\n            m = this.itemHiddenStyle,\n            p = \"horizontal\" === h.layout ? K(h.itemDistance, 20) : 0,\n            t = !h.rtl,\n            e = a.legendItem,\n            c = !a.series,\n            b = !c && a.series.drawLegendSymbol ? a.series : a,\n            z = b.options;\n        z = this.createCheckboxForItem && z && z.showCheckbox;\n        p = k + f + p + (z ? 20 : 0);\n        var w = h.useHTML,\n            u = a.options.className;\n        e || (a.legendGroup = g.g(\"legend-item\").addClass(\"highcharts-\" + b.type + \"-series highcharts-color-\" + a.colorIndex + (u ? \" \" + u : \"\") + (c ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = e = g.text(\"\", t ? k + f : -f, this.baseline || 0, w), d.styledMode || e.css(q(a.visible ? l : m)), e.attr({\n          align: t ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (this.fontMetrics = g.fontMetrics(d.styledMode ? 12 : l.fontSize, e), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, e.attr(\"y\", this.baseline)), this.symbolHeight = h.symbolHeight || this.fontMetrics.f, b.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, e, w));\n        z && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);\n        this.colorizeItem(a, a.visible);\n        !d.styledMode && l.width || e.css({\n          width: (h.itemWidth || this.widthOption || d.spacingBox.width) - p + \"px\"\n        });\n        this.setText(a);\n        d = e.getBBox();\n        a.itemWidth = a.checkboxOffset = h.itemWidth || a.legendItemWidth || d.width + p;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || d.height || this.symbolHeight);\n      };\n\n      a.prototype.layoutItem = function (a) {\n        var d = this.options,\n            g = this.padding,\n            h = \"horizontal\" === d.layout,\n            k = a.itemHeight,\n            f = this.itemMarginBottom,\n            l = this.itemMarginTop,\n            m = h ? K(d.itemDistance, 20) : 0,\n            p = this.maxLegendWidth;\n        d = d.alignColumns && this.totalItemWidth > p ? this.maxItemWidth : a.itemWidth;\n        h && this.itemX - g + d > p && (this.itemX = g, this.lastLineHeight && (this.itemY += l + this.lastLineHeight + f), this.lastLineHeight = 0);\n        this.lastItemY = l + this.itemY + f;\n        this.lastLineHeight = Math.max(k, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        h ? this.itemX += d : (this.itemY += l + k + f, this.lastLineHeight = k);\n        this.offsetWidth = this.widthOption || Math.max((h ? this.itemX - g - (a.checkbox ? 0 : m) : d) + g, this.offsetWidth);\n      };\n\n      a.prototype.getAllItems = function () {\n        var a = [];\n        this.chart.series.forEach(function (d) {\n          var g = d && d.options;\n          d && K(g.showInLegend, G(g.linkedTo) ? !1 : void 0, !0) && (a = a.concat(d.legendItems || (\"point\" === g.legendType ? d.data : d)));\n        });\n        H(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      };\n\n      a.prototype.getAlignment = function () {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      };\n\n      a.prototype.adjustMargins = function (a, d) {\n        var g = this.chart,\n            h = this.options,\n            k = this.getAlignment();\n        k && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (f, l) {\n          f.test(k) && !G(a[l]) && (g[m[l]] = Math.max(g[m[l]], g.legend[(l + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][l] * h[l % 2 ? \"x\" : \"y\"] + K(h.margin, 12) + d[l] + (g.titleOffset[l] || 0)));\n        });\n      };\n\n      a.prototype.proximatePositions = function () {\n        var a = this.chart,\n            d = [],\n            h = \"left\" === this.options.align;\n        this.allItems.forEach(function (g) {\n          var k;\n          var l = h;\n\n          if (g.yAxis) {\n            g.xAxis.options.reversed && (l = !l);\n            g.points && (k = J(l ? g.points : g.points.slice(0).reverse(), function (d) {\n              return L(d.plotY);\n            }));\n            l = this.itemMarginTop + g.legendItem.getBBox().height + this.itemMarginBottom;\n            var f = g.yAxis.top - a.plotTop;\n            g.visible ? (k = k ? k.plotY : g.yAxis.height, k += f - .3 * l) : k = f + g.yAxis.height;\n            d.push({\n              target: k,\n              size: l,\n              item: g\n            });\n          }\n        }, this);\n        f.distribute(d, a.plotHeight);\n        d.forEach(function (d) {\n          d.item._legendItemPos[1] = a.plotTop - a.spacing[0] + d.pos;\n        });\n      };\n\n      a.prototype.render = function () {\n        var a = this.chart,\n            d = a.renderer,\n            h = this.group,\n            k = this.box,\n            l = this.options,\n            f = this.padding;\n        this.itemX = f;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = E(l.width, a.spacingBox.width - f);\n        var m = a.spacingBox.width - 2 * f - l.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (m /= 2);\n        this.maxLegendWidth = this.widthOption || m;\n        h || (this.group = h = d.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = d.g().attr({\n          zIndex: 1\n        }).add(h), this.scrollGroup = d.g().add(this.contentGroup));\n        this.renderTitle();\n        var p = this.getAllItems();\n        t(p, function (d, e) {\n          return (d.options && d.options.legendIndex || 0) - (e.options && e.options.legendIndex || 0);\n        });\n        l.reversed && p.reverse();\n        this.allItems = p;\n        this.display = m = !!p.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        p.forEach(this.renderItem, this);\n        p.forEach(this.layoutItem, this);\n        p = (this.widthOption || this.offsetWidth) + f;\n        var q = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        q = this.handleOverflow(q);\n        q += f;\n        k || (this.box = k = d.rect().addClass(\"highcharts-legend-box\").attr({\n          r: l.borderRadius\n        }).add(h), k.isNew = !0);\n        a.styledMode || k.attr({\n          stroke: l.borderColor,\n          \"stroke-width\": l.borderWidth || 0,\n          fill: l.backgroundColor || \"none\"\n        }).shadow(l.shadow);\n        0 < p && 0 < q && (k[k.isNew ? \"attr\" : \"animate\"](k.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: p,\n          height: q\n        }, k.strokeWidth())), k.isNew = !1);\n        k[m ? \"show\" : \"hide\"]();\n        a.styledMode && \"none\" === h.getStyle(\"display\") && (p = q = 0);\n        this.legendWidth = p;\n        this.legendHeight = q;\n        m && this.align();\n        this.proximate || this.positionItems();\n        H(this, \"afterRender\");\n      };\n\n      a.prototype.align = function (a) {\n        void 0 === a && (a = this.chart.spacingBox);\n        var d = this.chart,\n            g = this.options,\n            h = a.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < d.titleOffset[0] ? h += d.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < d.titleOffset[2] && (h -= d.titleOffset[2]);\n        h !== a.y && (a = q(a, {\n          y: h\n        }));\n        this.group.align(q(g, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? \"top\" : g.verticalAlign\n        }), !0, a);\n      };\n\n      a.prototype.handleOverflow = function (a) {\n        var d = this,\n            g = this.chart,\n            h = g.renderer,\n            k = this.options,\n            l = k.y,\n            f = this.padding;\n        l = g.spacingBox.height + (\"top\" === k.verticalAlign ? -l : l) - f;\n\n        var m = k.maxHeight,\n            p,\n            t = this.clipRect,\n            e = k.navigation,\n            c = K(e.animation, !0),\n            b = e.arrowSize || 12,\n            z = this.nav,\n            w = this.pages,\n            q,\n            u = this.allItems,\n            n = function n(b) {\n          \"number\" === typeof b ? t.attr({\n            height: b\n          }) : t && (d.clipRect = t.destroy(), d.contentGroup.clip());\n          d.contentGroup.div && (d.contentGroup.div.style.clip = b ? \"rect(\" + f + \"px,9999px,\" + (f + b) + \"px,0)\" : \"auto\");\n        },\n            v = function v(c) {\n          d[c] = h.circle(0, 0, 1.3 * b).translate(b / 2, b / 2).add(z);\n          g.styledMode || d[c].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n          return d[c];\n        };\n\n        \"horizontal\" !== k.layout || \"middle\" === k.verticalAlign || k.floating || (l /= 2);\n        m && (l = Math.min(l, m));\n        w.length = 0;\n        a > l && !1 !== e.enabled ? (this.clipHeight = p = Math.max(l - 20 - this.titleHeight - f, 0), this.currentPage = K(this.currentPage, 1), this.fullHeight = a, u.forEach(function (b, c) {\n          var e = b._legendItemPos[1],\n              d = Math.round(b.legendItem.getBBox().height),\n              a = w.length;\n          if (!a || e - w[a - 1] > p && (q || e) !== w[a - 1]) w.push(q || e), a++;\n          b.pageIx = a - 1;\n          q && (u[c - 1].pageIx = a - 1);\n          c === u.length - 1 && e + d - w[a - 1] > p && e !== q && (w.push(e), b.pageIx = a);\n          e !== q && (q = e);\n        }), t || (t = d.clipRect = h.clipRect(0, f, 9999, 0), d.contentGroup.clip(t)), n(p), z || (this.nav = z = h.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = h.symbol(\"triangle\", 0, 0, b, b).add(z), v(\"upTracker\").on(\"click\", function () {\n          d.scroll(-1, c);\n        }), this.pager = h.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), g.styledMode || this.pager.css(e.style), this.pager.add(z), this.down = h.symbol(\"triangle-down\", 0, 0, b, b).add(z), v(\"downTracker\").on(\"click\", function () {\n          d.scroll(1, c);\n        })), d.scroll(0), a = l) : z && (n(), this.nav = z.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      };\n\n      a.prototype.scroll = function (a, d) {\n        var g = this,\n            h = this.chart,\n            k = this.pages,\n            l = k.length,\n            f = this.currentPage + a;\n        a = this.clipHeight;\n        var m = this.options.navigation,\n            t = this.pager,\n            q = this.padding;\n        f > l && (f = l);\n        0 < f && (\"undefined\" !== typeof d && p(d, h), this.nav.attr({\n          translateX: q,\n          translateY: a + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), [this.up, this.upTracker].forEach(function (e) {\n          e.attr({\n            \"class\": 1 === f ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), t.attr({\n          text: f + \"/\" + l\n        }), [this.down, this.downTracker].forEach(function (e) {\n          e.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": f === l ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), h.styledMode || (this.up.attr({\n          fill: 1 === f ? m.inactiveColor : m.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === f ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: f === l ? m.inactiveColor : m.activeColor\n        }), this.downTracker.css({\n          cursor: f === l ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -k[f - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = f, this.positionCheckboxes(), d = y(K(d, h.renderer.globalAnimation, !0)), I(function () {\n          H(g, \"afterScroll\", {\n            currentPage: f\n          });\n        }, d.duration));\n      };\n\n      return a;\n    }();\n\n    (/Trident\\/7\\.0/.test(h.navigator && h.navigator.userAgent) || u) && a(l.prototype, \"positionItem\", function (a, g) {\n      var d = this,\n          h = function h() {\n        g._legendItemPos && a.call(d, g);\n      };\n\n      h();\n      d.bubbleLegend || setTimeout(h);\n    });\n    f.Legend = l;\n    return f.Legend;\n  });\n  O(n, \"Core/Chart/Chart.js\", [n[\"Core/Axis/Axis.js\"], n[\"Core/Globals.js\"], n[\"Core/Legend.js\"], n[\"Core/MSPointer.js\"], n[\"Core/Options.js\"], n[\"Core/Pointer.js\"], n[\"Core/Time.js\"], n[\"Core/Utilities.js\"]], function (f, a, n, y, D, G, C, J) {\n    var H = a.charts,\n        v = a.doc,\n        L = a.seriesTypes,\n        q = a.win,\n        K = D.defaultOptions,\n        E = J.addEvent,\n        p = J.animate,\n        t = J.animObject,\n        I = J.attr,\n        u = J.createElement,\n        m = J.css,\n        h = J.defined,\n        l = J.discardElement,\n        k = J.erase,\n        g = J.error,\n        d = J.extend,\n        x = J.find,\n        r = J.fireEvent,\n        A = J.getStyle,\n        N = J.isArray,\n        B = J.isFunction,\n        M = J.isNumber,\n        R = J.isObject,\n        F = J.isString,\n        e = J.merge,\n        c = J.numberFormat,\n        b = J.objectEach,\n        z = J.pick,\n        w = J.pInt,\n        P = J.relativeLength,\n        Z = J.removeEvent,\n        W = J.setAnimation,\n        aa = J.splat,\n        X = J.syncTimeout,\n        ba = J.uniqueKey,\n        ca = a.marginNames,\n        Y = function () {\n      function D(b, c, e) {\n        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;\n        this.getArgs(b, c, e);\n      }\n\n      D.prototype.getArgs = function (b, c, e) {\n        F(b) || b.nodeName ? (this.renderTo = b, this.init(c, e)) : this.init(b, c);\n      };\n\n      D.prototype.init = function (d, g) {\n        var h,\n            k = d.series,\n            l = d.plotOptions || {};\n        r(this, \"init\", {\n          args: arguments\n        }, function () {\n          d.series = null;\n          h = e(K, d);\n          var f = h.chart || {};\n          b(h.plotOptions, function (b, c) {\n            R(b) && (b.tooltip = l[c] && e(l[c].tooltip) || void 0);\n          });\n          h.tooltip.userOptions = d.chart && d.chart.forExport && d.tooltip.userOptions || d.tooltip;\n          h.series = d.series = k;\n          this.userOptions = d;\n          var m = f.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = g;\n          this.isResizing = 0;\n          this.options = h;\n          this.axes = [];\n          this.series = [];\n          this.time = d.time && Object.keys(d.time).length ? new C(d.time) : a.time;\n          this.numberFormatter = f.numberFormatter || c;\n          this.styledMode = f.styledMode;\n          this.hasCartesianSeries = f.showAxes;\n          var p = this;\n          p.index = H.length;\n          H.push(p);\n          a.chartCount++;\n          m && b(m, function (b, c) {\n            B(b) && E(p, c, b);\n          });\n          p.xAxis = [];\n          p.yAxis = [];\n          p.pointCount = p.colorCounter = p.symbolCounter = 0;\n          r(p, \"afterInit\");\n          p.firstRender();\n        });\n      };\n\n      D.prototype.initSeries = function (b) {\n        var c = this.options.chart;\n        c = b.type || c.type || c.defaultSeriesType;\n        var e = L[c];\n        e || g(17, !0, this, {\n          missingModuleFor: c\n        });\n        c = new e();\n        c.init(this, b);\n        return c;\n      };\n\n      D.prototype.setSeriesData = function () {\n        this.getSeriesOrderByLinks().forEach(function (b) {\n          b.points || b.data || !b.enabledDataSorting || b.setData(b.options.data, !1);\n        });\n      };\n\n      D.prototype.getSeriesOrderByLinks = function () {\n        return this.series.concat().sort(function (b, c) {\n          return b.linkedSeries.length || c.linkedSeries.length ? c.linkedSeries.length - b.linkedSeries.length : 0;\n        });\n      };\n\n      D.prototype.orderSeries = function (b) {\n        var c = this.series;\n\n        for (b = b || 0; b < c.length; b++) {\n          c[b] && (c[b].index = b, c[b].name = c[b].getName());\n        }\n      };\n\n      D.prototype.isInsidePlot = function (b, c, e) {\n        var d = e ? c : b;\n        b = e ? b : c;\n        d = {\n          x: d,\n          y: b,\n          isInsidePlot: 0 <= d && d <= this.plotWidth && 0 <= b && b <= this.plotHeight\n        };\n        r(this, \"afterIsInsidePlot\", d);\n        return d.isInsidePlot;\n      };\n\n      D.prototype.redraw = function (b) {\n        r(this, \"beforeRedraw\");\n        var c = this,\n            e = c.axes,\n            a = c.series,\n            g = c.pointer,\n            h = c.legend,\n            k = c.userOptions.legend,\n            l = c.isDirtyLegend,\n            f = c.hasCartesianSeries,\n            m = c.isDirtyBox,\n            p = c.renderer,\n            w = p.isHidden(),\n            z = [];\n        c.setResponsive && c.setResponsive(!1);\n        W(c.hasRendered ? b : !1, c);\n        w && c.temporaryDisplay();\n        c.layOutTitles();\n\n        for (b = a.length; b--;) {\n          var t = a[b];\n\n          if (t.options.stacking) {\n            var B = !0;\n\n            if (t.isDirty) {\n              var q = !0;\n              break;\n            }\n          }\n        }\n\n        if (q) for (b = a.length; b--;) {\n          t = a[b], t.options.stacking && (t.isDirty = !0);\n        }\n        a.forEach(function (b) {\n          b.isDirty && (\"point\" === b.options.legendType ? (b.updateTotals && b.updateTotals(), l = !0) : k && (k.labelFormatter || k.labelFormat) && (l = !0));\n          b.isDirtyData && r(b, \"updatedData\");\n        });\n        l && h && h.options.enabled && (h.render(), c.isDirtyLegend = !1);\n        B && c.getStacks();\n        f && e.forEach(function (b) {\n          c.isResizing && M(b.min) || (b.updateNames(), b.setScale());\n        });\n        c.getMargins();\n        f && (e.forEach(function (b) {\n          b.isDirty && (m = !0);\n        }), e.forEach(function (b) {\n          var c = b.min + \",\" + b.max;\n          b.extKey !== c && (b.extKey = c, z.push(function () {\n            r(b, \"afterSetExtremes\", d(b.eventArgs, b.getExtremes()));\n            delete b.eventArgs;\n          }));\n          (m || B) && b.redraw();\n        }));\n        m && c.drawChartBox();\n        r(c, \"predraw\");\n        a.forEach(function (b) {\n          (m || b.isDirty) && b.visible && b.redraw();\n          b.isDirtyData = !1;\n        });\n        g && g.reset(!0);\n        p.draw();\n        r(c, \"redraw\");\n        r(c, \"render\");\n        w && c.temporaryDisplay(!0);\n        z.forEach(function (b) {\n          b.call();\n        });\n      };\n\n      D.prototype.get = function (b) {\n        function c(c) {\n          return c.id === b || c.options && c.options.id === b;\n        }\n\n        var e = this.series,\n            d;\n        var a = x(this.axes, c) || x(this.series, c);\n\n        for (d = 0; !a && d < e.length; d++) {\n          a = x(e[d].points || [], c);\n        }\n\n        return a;\n      };\n\n      D.prototype.getAxes = function () {\n        var b = this,\n            c = this.options,\n            e = c.xAxis = aa(c.xAxis || {});\n        c = c.yAxis = aa(c.yAxis || {});\n        r(this, \"getAxes\");\n        e.forEach(function (b, c) {\n          b.index = c;\n          b.isX = !0;\n        });\n        c.forEach(function (b, c) {\n          b.index = c;\n        });\n        e.concat(c).forEach(function (c) {\n          new f(b, c);\n        });\n        r(this, \"afterGetAxes\");\n      };\n\n      D.prototype.getSelectedPoints = function () {\n        var b = [];\n        this.series.forEach(function (c) {\n          b = b.concat(c.getPointsCollection().filter(function (b) {\n            return z(b.selectedStaging, b.selected);\n          }));\n        });\n        return b;\n      };\n\n      D.prototype.getSelectedSeries = function () {\n        return this.series.filter(function (b) {\n          return b.selected;\n        });\n      };\n\n      D.prototype.setTitle = function (b, c, e) {\n        this.applyDescription(\"title\", b);\n        this.applyDescription(\"subtitle\", c);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(e);\n      };\n\n      D.prototype.applyDescription = function (b, c) {\n        var d = this,\n            a = \"title\" === b ? {\n          color: \"#333333\",\n          fontSize: this.options.isStock ? \"16px\" : \"18px\"\n        } : {\n          color: \"#666666\"\n        };\n        a = this.options[b] = e(!this.styledMode && {\n          style: a\n        }, this.options[b], c);\n        var g = this[b];\n        g && c && (this[b] = g = g.destroy());\n        a && !g && (g = this.renderer.text(a.text, 0, 0, a.useHTML).attr({\n          align: a.align,\n          \"class\": \"highcharts-\" + b,\n          zIndex: a.zIndex || 4\n        }).add(), g.update = function (c) {\n          d[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[b]](c);\n        }, this.styledMode || g.css(a.style), this[b] = g);\n      };\n\n      D.prototype.layOutTitles = function (b) {\n        var c = [0, 0, 0],\n            e = this.renderer,\n            a = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (b) {\n          var g = this[b],\n              h = this.options[b],\n              k = h.verticalAlign || \"top\";\n          b = \"title\" === b ? -3 : \"top\" === k ? c[0] + 2 : 0;\n\n          if (g) {\n            if (!this.styledMode) var l = h.style.fontSize;\n            l = e.fontMetrics(l, g).b;\n            g.css({\n              width: (h.width || a.width + (h.widthAdjust || 0)) + \"px\"\n            });\n            var f = Math.round(g.getBBox(h.useHTML).height);\n            g.align(d({\n              y: \"bottom\" === k ? l : b + l,\n              height: f\n            }, h), !1, \"spacingBox\");\n            h.floating || (\"top\" === k ? c[0] = Math.ceil(c[0] + f) : \"bottom\" === k && (c[2] = Math.ceil(c[2] + f)));\n          }\n        }, this);\n        c[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (c[0] += this.options.title.margin);\n        c[2] && \"bottom\" === this.options.caption.verticalAlign && (c[2] += this.options.caption.margin);\n        var g = !this.titleOffset || this.titleOffset.join(\",\") !== c.join(\",\");\n        this.titleOffset = c;\n        r(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && g && (this.isDirtyBox = this.isDirtyLegend = g, this.hasRendered && z(b, !0) && this.isDirtyBox && this.redraw());\n      };\n\n      D.prototype.getChartSize = function () {\n        var b = this.options.chart,\n            c = b.width;\n        b = b.height;\n        var e = this.renderTo;\n        h(c) || (this.containerWidth = A(e, \"width\"));\n        h(b) || (this.containerHeight = A(e, \"height\"));\n        this.chartWidth = Math.max(0, c || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, P(b, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      };\n\n      D.prototype.temporaryDisplay = function (b) {\n        var c = this.renderTo;\n        if (b) for (; c && c.style;) {\n          c.hcOrigStyle && (m(c, c.hcOrigStyle), delete c.hcOrigStyle), c.hcOrigDetached && (v.body.removeChild(c), c.hcOrigDetached = !1), c = c.parentNode;\n        } else for (; c && c.style;) {\n          v.body.contains(c) || c.parentNode || (c.hcOrigDetached = !0, v.body.appendChild(c));\n          if (\"none\" === A(c, \"display\", !1) || c.hcOricDetached) c.hcOrigStyle = {\n            display: c.style.display,\n            height: c.style.height,\n            overflow: c.style.overflow\n          }, b = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, c !== this.renderTo && (b.height = 0), m(c, b), c.offsetWidth || c.style.setProperty(\"display\", \"block\", \"important\");\n          c = c.parentNode;\n          if (c === v.body) break;\n        }\n      };\n\n      D.prototype.setClassName = function (b) {\n        this.container.className = \"highcharts-container \" + (b || \"\");\n      };\n\n      D.prototype.getContainer = function () {\n        var b = this.options,\n            c = b.chart;\n        var e = this.renderTo;\n        var h = ba(),\n            k,\n            l;\n        e || (this.renderTo = e = c.renderTo);\n        F(e) && (this.renderTo = e = v.getElementById(e));\n        e || g(13, !0, this);\n        var f = w(I(e, \"data-highcharts-chart\"));\n        M(f) && H[f] && H[f].hasRendered && H[f].destroy();\n        I(e, \"data-highcharts-chart\", this.index);\n        e.innerHTML = \"\";\n        c.skipClone || e.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        f = this.chartWidth;\n        var p = this.chartHeight;\n        m(e, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (k = d({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: f + \"px\",\n          height: p + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n          userSelect: \"none\"\n        }, c.style));\n        this.container = e = u(\"div\", {\n          id: h\n        }, k, e);\n        this._cursor = e.style.cursor;\n        this.renderer = new (a[c.renderer] || a.Renderer)(e, f, p, null, c.forExport, b.exporting && b.exporting.allowHTML, this.styledMode);\n        W(void 0, this);\n        this.setClassName(c.className);\n        if (this.styledMode) for (l in b.defs) {\n          this.renderer.definition(b.defs[l]);\n        } else this.renderer.setStyle(c.style);\n        this.renderer.chartIndex = this.index;\n        r(this, \"afterGetContainer\");\n      };\n\n      D.prototype.getMargins = function (b) {\n        var c = this.spacing,\n            e = this.margin,\n            d = this.titleOffset;\n        this.resetMargins();\n        d[0] && !h(e[0]) && (this.plotTop = Math.max(this.plotTop, d[0] + c[0]));\n        d[2] && !h(e[2]) && (this.marginBottom = Math.max(this.marginBottom, d[2] + c[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(e, c);\n        r(this, \"getMargins\");\n        b || this.getAxisMargins();\n      };\n\n      D.prototype.getAxisMargins = function () {\n        var b = this,\n            c = b.axisOffset = [0, 0, 0, 0],\n            e = b.colorAxis,\n            d = b.margin,\n            a = function a(b) {\n          b.forEach(function (b) {\n            b.visible && b.getOffset();\n          });\n        };\n\n        b.hasCartesianSeries ? a(b.axes) : e && e.length && a(e);\n        ca.forEach(function (e, a) {\n          h(d[a]) || (b[e] += c[a]);\n        });\n        b.setChartSize();\n      };\n\n      D.prototype.reflow = function (b) {\n        var c = this,\n            e = c.options.chart,\n            d = c.renderTo,\n            a = h(e.width) && h(e.height),\n            g = e.width || A(d, \"width\");\n        e = e.height || A(d, \"height\");\n        d = b ? b.target : q;\n\n        if (!a && !c.isPrinting && g && e && (d === q || d === v)) {\n          if (g !== c.containerWidth || e !== c.containerHeight) J.clearTimeout(c.reflowTimeout), c.reflowTimeout = X(function () {\n            c.container && c.setSize(void 0, void 0, !1);\n          }, b ? 100 : 0);\n          c.containerWidth = g;\n          c.containerHeight = e;\n        }\n      };\n\n      D.prototype.setReflow = function (b) {\n        var c = this;\n        !1 === b || this.unbindReflow ? !1 === b && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = E(q, \"resize\", function (b) {\n          c.options && c.reflow(b);\n        }), E(this, \"destroy\", this.unbindReflow));\n      };\n\n      D.prototype.setSize = function (b, c, e) {\n        var d = this,\n            a = d.renderer;\n        d.isResizing += 1;\n        W(e, d);\n        e = a.globalAnimation;\n        d.oldChartHeight = d.chartHeight;\n        d.oldChartWidth = d.chartWidth;\n        \"undefined\" !== typeof b && (d.options.chart.width = b);\n        \"undefined\" !== typeof c && (d.options.chart.height = c);\n        d.getChartSize();\n        d.styledMode || (e ? p : m)(d.container, {\n          width: d.chartWidth + \"px\",\n          height: d.chartHeight + \"px\"\n        }, e);\n        d.setChartSize(!0);\n        a.setSize(d.chartWidth, d.chartHeight, e);\n        d.axes.forEach(function (b) {\n          b.isDirty = !0;\n          b.setScale();\n        });\n        d.isDirtyLegend = !0;\n        d.isDirtyBox = !0;\n        d.layOutTitles();\n        d.getMargins();\n        d.redraw(e);\n        d.oldChartHeight = null;\n        r(d, \"resize\");\n        X(function () {\n          d && r(d, \"endResize\", null, function () {\n            --d.isResizing;\n          });\n        }, t(e).duration);\n      };\n\n      D.prototype.setChartSize = function (b) {\n        var c = this.inverted,\n            e = this.renderer,\n            d = this.chartWidth,\n            a = this.chartHeight,\n            g = this.options.chart,\n            h = this.spacing,\n            k = this.clipOffset,\n            f,\n            l,\n            m,\n            p;\n        this.plotLeft = f = Math.round(this.plotLeft);\n        this.plotTop = l = Math.round(this.plotTop);\n        this.plotWidth = m = Math.max(0, Math.round(d - f - this.marginRight));\n        this.plotHeight = p = Math.max(0, Math.round(a - l - this.marginBottom));\n        this.plotSizeX = c ? p : m;\n        this.plotSizeY = c ? m : p;\n        this.plotBorderWidth = g.plotBorderWidth || 0;\n        this.spacingBox = e.spacingBox = {\n          x: h[3],\n          y: h[0],\n          width: d - h[3] - h[1],\n          height: a - h[0] - h[2]\n        };\n        this.plotBox = e.plotBox = {\n          x: f,\n          y: l,\n          width: m,\n          height: p\n        };\n        d = 2 * Math.floor(this.plotBorderWidth / 2);\n        c = Math.ceil(Math.max(d, k[3]) / 2);\n        e = Math.ceil(Math.max(d, k[0]) / 2);\n        this.clipBox = {\n          x: c,\n          y: e,\n          width: Math.floor(this.plotSizeX - Math.max(d, k[1]) / 2 - c),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(d, k[2]) / 2 - e))\n        };\n        b || this.axes.forEach(function (b) {\n          b.setAxisSize();\n          b.setAxisTranslation();\n        });\n        r(this, \"afterSetChartSize\", {\n          skipAxes: b\n        });\n      };\n\n      D.prototype.resetMargins = function () {\n        r(this, \"resetMargins\");\n        var b = this,\n            c = b.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (e) {\n          var d = c[e],\n              a = R(d) ? d : [d, d, d, d];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (d, g) {\n            b[e][g] = z(c[e + d], a[g]);\n          });\n        });\n        ca.forEach(function (c, e) {\n          b[c] = z(b.margin[e], b.spacing[e]);\n        });\n        b.axisOffset = [0, 0, 0, 0];\n        b.clipOffset = [0, 0, 0, 0];\n      };\n\n      D.prototype.drawChartBox = function () {\n        var b = this.options.chart,\n            c = this.renderer,\n            e = this.chartWidth,\n            d = this.chartHeight,\n            a = this.chartBackground,\n            g = this.plotBackground,\n            h = this.plotBorder,\n            k = this.styledMode,\n            f = this.plotBGImage,\n            l = b.backgroundColor,\n            m = b.plotBackgroundColor,\n            p = b.plotBackgroundImage,\n            w,\n            z = this.plotLeft,\n            t = this.plotTop,\n            B = this.plotWidth,\n            q = this.plotHeight,\n            x = this.plotBox,\n            u = this.clipRect,\n            A = this.clipBox,\n            F = \"animate\";\n        a || (this.chartBackground = a = c.rect().addClass(\"highcharts-background\").add(), F = \"attr\");\n        if (k) var n = w = a.strokeWidth();else {\n          n = b.borderWidth || 0;\n          w = n + (b.shadow ? 8 : 0);\n          l = {\n            fill: l || \"none\"\n          };\n          if (n || a[\"stroke-width\"]) l.stroke = b.borderColor, l[\"stroke-width\"] = n;\n          a.attr(l).shadow(b.shadow);\n        }\n        a[F]({\n          x: w / 2,\n          y: w / 2,\n          width: e - w - n % 2,\n          height: d - w - n % 2,\n          r: b.borderRadius\n        });\n        F = \"animate\";\n        g || (F = \"attr\", this.plotBackground = g = c.rect().addClass(\"highcharts-plot-background\").add());\n        g[F](x);\n        k || (g.attr({\n          fill: m || \"none\"\n        }).shadow(b.plotShadow), p && (f ? (p !== f.attr(\"href\") && f.attr(\"href\", p), f.animate(x)) : this.plotBGImage = c.image(p, z, t, B, q).add()));\n        u ? u.animate({\n          width: A.width,\n          height: A.height\n        }) : this.clipRect = c.clipRect(A);\n        F = \"animate\";\n        h || (F = \"attr\", this.plotBorder = h = c.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        k || h.attr({\n          stroke: b.plotBorderColor,\n          \"stroke-width\": b.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        h[F](h.crisp({\n          x: z,\n          y: t,\n          width: B,\n          height: q\n        }, -h.strokeWidth()));\n        this.isDirtyBox = !1;\n        r(this, \"afterDrawChartBox\");\n      };\n\n      D.prototype.propFromSeries = function () {\n        var b = this,\n            c = b.options.chart,\n            e,\n            d = b.options.series,\n            a,\n            g;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (h) {\n          e = L[c.type || c.defaultSeriesType];\n          g = c[h] || e && e.prototype[h];\n\n          for (a = d && d.length; !g && a--;) {\n            (e = L[d[a].type]) && e.prototype[h] && (g = !0);\n          }\n\n          b[h] = g;\n        });\n      };\n\n      D.prototype.linkSeries = function () {\n        var b = this,\n            c = b.series;\n        c.forEach(function (b) {\n          b.linkedSeries.length = 0;\n        });\n        c.forEach(function (c) {\n          var e = c.options.linkedTo;\n          F(e) && (e = \":previous\" === e ? b.series[c.index - 1] : b.get(e)) && e.linkedParent !== c && (e.linkedSeries.push(c), c.linkedParent = e, e.enabledDataSorting && c.setDataSortingOptions(), c.visible = z(c.options.visible, e.options.visible, c.visible));\n        });\n        r(this, \"afterLinkSeries\");\n      };\n\n      D.prototype.renderSeries = function () {\n        this.series.forEach(function (b) {\n          b.translate();\n          b.render();\n        });\n      };\n\n      D.prototype.renderLabels = function () {\n        var b = this,\n            c = b.options.labels;\n        c.items && c.items.forEach(function (e) {\n          var a = d(c.style, e.style),\n              g = w(a.left) + b.plotLeft,\n              h = w(a.top) + b.plotTop + 12;\n          delete a.left;\n          delete a.top;\n          b.renderer.text(e.html, g, h).attr({\n            zIndex: 2\n          }).css(a).add();\n        });\n      };\n\n      D.prototype.render = function () {\n        var b = this.axes,\n            c = this.colorAxis,\n            e = this.renderer,\n            d = this.options,\n            a = 0,\n            g = function g(b) {\n          b.forEach(function (b) {\n            b.visible && b.render();\n          });\n        };\n\n        this.setTitle();\n        this.legend = new n(this, d.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        d = this.plotWidth;\n        b.some(function (b) {\n          if (b.horiz && b.visible && b.options.labels.enabled && b.series.length) return a = 21, !0;\n        });\n        var h = this.plotHeight = Math.max(this.plotHeight - a, 0);\n        b.forEach(function (b) {\n          b.setScale();\n        });\n        this.getAxisMargins();\n        var k = 1.1 < d / this.plotWidth;\n        var l = 1.05 < h / this.plotHeight;\n        if (k || l) b.forEach(function (b) {\n          (b.horiz && k || !b.horiz && l) && b.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? g(b) : c && c.length && g(c);\n        this.seriesGroup || (this.seriesGroup = e.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.updateContainerScaling();\n        this.hasRendered = !0;\n      };\n\n      D.prototype.addCredits = function (b) {\n        var c = this,\n            d = e(!0, this.options.credits, b);\n        d.enabled && !this.credits && (this.credits = this.renderer.text(d.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          d.href && (q.location.href = d.href);\n        }).attr({\n          align: d.position.align,\n          zIndex: 8\n        }), c.styledMode || this.credits.css(d.style), this.credits.add().align(d.position), this.credits.update = function (b) {\n          c.credits = c.credits.destroy();\n          c.addCredits(b);\n        });\n      };\n\n      D.prototype.updateContainerScaling = function () {\n        var b = this.container;\n\n        if (2 < b.offsetWidth && 2 < b.offsetHeight && b.getBoundingClientRect) {\n          var c = b.getBoundingClientRect(),\n              e = c.width / b.offsetWidth;\n          b = c.height / b.offsetHeight;\n          1 !== e || 1 !== b ? this.containerScaling = {\n            scaleX: e,\n            scaleY: b\n          } : delete this.containerScaling;\n        }\n      };\n\n      D.prototype.destroy = function () {\n        var c = this,\n            e = c.axes,\n            d = c.series,\n            g = c.container,\n            h,\n            f = g && g.parentNode;\n        r(c, \"destroy\");\n        c.renderer.forExport ? k(H, c) : H[c.index] = void 0;\n        a.chartCount--;\n        c.renderTo.removeAttribute(\"data-highcharts-chart\");\n        Z(c);\n\n        for (h = e.length; h--;) {\n          e[h] = e[h].destroy();\n        }\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (h = d.length; h--;) {\n          d[h] = d[h].destroy();\n        }\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (b) {\n          var e = c[b];\n          e && e.destroy && (c[b] = e.destroy());\n        });\n        g && (g.innerHTML = \"\", Z(g), f && l(g));\n        b(c, function (b, e) {\n          delete c[e];\n        });\n      };\n\n      D.prototype.firstRender = function () {\n        var b = this,\n            c = b.options;\n\n        if (!b.isReadyToRender || b.isReadyToRender()) {\n          b.getContainer();\n          b.resetMargins();\n          b.setChartSize();\n          b.propFromSeries();\n          b.getAxes();\n          (N(c.series) ? c.series : []).forEach(function (c) {\n            b.initSeries(c);\n          });\n          b.linkSeries();\n          b.setSeriesData();\n          r(b, \"beforeRender\");\n          G && (b.pointer = a.hasTouch || !q.PointerEvent && !q.MSPointerEvent ? new G(b, c) : new y(b, c));\n          b.render();\n          if (!b.renderer.imgCount && !b.hasLoaded) b.onload();\n          b.temporaryDisplay(!0);\n        }\n      };\n\n      D.prototype.onload = function () {\n        this.callbacks.concat([this.callback]).forEach(function (b) {\n          b && \"undefined\" !== typeof this.index && b.apply(this, [this]);\n        }, this);\n        r(this, \"load\");\n        r(this, \"render\");\n        h(this.index) && this.setReflow(this.options.chart.reflow);\n        this.hasLoaded = !0;\n      };\n\n      return D;\n    }();\n\n    Y.prototype.callbacks = [];\n\n    a.chart = function (b, c, e) {\n      return new Y(b, c, e);\n    };\n\n    return a.Chart = Y;\n  });\n  O(n, \"Extensions/ScrollablePlotArea.js\", [n[\"Core/Chart/Chart.js\"], n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a, n) {\n    var y = n.addEvent,\n        D = n.createElement,\n        G = n.pick,\n        C = n.stop;\n    \"\";\n    y(f, \"afterSetChartSize\", function (f) {\n      var n = this.options.chart.scrollablePlotArea,\n          v = n && n.minWidth;\n      n = n && n.minHeight;\n\n      if (!this.renderer.forExport) {\n        if (v) {\n          if (this.scrollablePixelsX = v = Math.max(0, v - this.chartWidth)) {\n            this.plotWidth += v;\n            this.inverted ? (this.clipBox.height += v, this.plotBox.height += v) : (this.clipBox.width += v, this.plotBox.width += v);\n            var C = {\n              1: {\n                name: \"right\",\n                value: v\n              }\n            };\n          }\n        } else n && (this.scrollablePixelsY = v = Math.max(0, n - this.chartHeight)) && (this.plotHeight += v, this.inverted ? (this.clipBox.width += v, this.plotBox.width += v) : (this.clipBox.height += v, this.plotBox.height += v), C = {\n          2: {\n            name: \"bottom\",\n            value: v\n          }\n        });\n\n        C && !f.skipAxes && this.axes.forEach(function (f) {\n          C[f.side] ? f.getPlotLinePath = function () {\n            var q = C[f.side].name,\n                n = this[q];\n            this[q] = n - C[f.side].value;\n            var p = a.Axis.prototype.getPlotLinePath.apply(this, arguments);\n            this[q] = n;\n            return p;\n          } : (f.setAxisSize(), f.setAxisTranslation());\n        });\n      }\n    });\n    y(f, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    f.prototype.setUpScrolling = function () {\n      var a = this,\n          f = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (f.overflowX = \"auto\");\n      this.scrollablePixelsY && (f.overflowY = \"auto\");\n      this.scrollingParent = D(\"div\", {\n        className: \"highcharts-scrolling-parent\"\n      }, {\n        position: \"relative\"\n      }, this.renderTo);\n      this.scrollingContainer = D(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, f, this.scrollingParent);\n      y(this.scrollingContainer, \"scroll\", function () {\n        a.pointer && delete a.pointer.chartPosition;\n      });\n      this.innerContainer = D(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    f.prototype.moveFixedElements = function () {\n      var a = this.container,\n          f = this.fixedRenderer,\n          n = \".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n          C;\n      this.scrollablePixelsX && !this.inverted ? C = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? C = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? C = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (C = \".highcharts-yaxis\");\n      n.push(C, C + \"-labels\");\n      n.forEach(function (q) {\n        [].forEach.call(a.querySelectorAll(q), function (a) {\n          (a.namespaceURI === f.SVG_NS ? f.box : f.box.parentNode).appendChild(a);\n          a.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n\n    f.prototype.applyFixed = function () {\n      var f,\n          n,\n          v = !this.fixedDiv,\n          L = this.options.chart.scrollablePlotArea;\n      v ? (this.fixedDiv = D(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: 2,\n        top: 0\n      }, null, !0), null === (f = this.scrollingContainer) || void 0 === f ? void 0 : f.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = f = new a.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight, null === (n = this.options.chart) || void 0 === n ? void 0 : n.style), this.scrollableMask = f.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": G(L.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), this.moveFixedElements(), y(this, \"afterShowResetZoom\", this.moveFixedElements), y(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      n = this.chartWidth + (this.scrollablePixelsX || 0);\n      f = this.chartHeight + (this.scrollablePixelsY || 0);\n      C(this.container);\n      this.container.style.width = n + \"px\";\n      this.container.style.height = f + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: n,\n        height: f,\n        viewBox: [0, 0, n, f].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: n,\n        height: f\n      });\n      this.scrollingContainer.style.height = this.chartHeight + \"px\";\n      v && (L.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * L.scrollPositionX), L.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * L.scrollPositionY));\n      f = this.axisOffset;\n      v = this.plotTop - f[0] - 1;\n      L = this.plotLeft - f[3] - 1;\n      n = this.plotTop + this.plotHeight + f[2] + 1;\n      f = this.plotLeft + this.plotWidth + f[1] + 1;\n      var q = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n          K = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      v = this.scrollablePixelsX ? [[\"M\", 0, v], [\"L\", this.plotLeft - 1, v], [\"L\", this.plotLeft - 1, n], [\"L\", 0, n], [\"Z\"], [\"M\", q, v], [\"L\", this.chartWidth, v], [\"L\", this.chartWidth, n], [\"L\", q, n], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", L, 0], [\"L\", L, this.plotTop - 1], [\"L\", f, this.plotTop - 1], [\"L\", f, 0], [\"Z\"], [\"M\", L, K], [\"L\", L, this.chartHeight], [\"L\", f, this.chartHeight], [\"L\", f, K], [\"Z\"]] : [[\"M\", 0, 0]];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: v\n      });\n    };\n  });\n  O(n, \"Core/Axis/StackingAxis.js\", [n[\"Core/Utilities.js\"]], function (f) {\n    var a = f.addEvent,\n        n = f.destroyObjectProperties,\n        y = f.fireEvent,\n        D = f.getDeferredAnimation,\n        G = f.objectEach,\n        C = f.pick,\n        J = function () {\n      function a(a) {\n        this.oldStacks = {};\n        this.stacks = {};\n        this.stacksTouched = 0;\n        this.axis = a;\n      }\n\n      a.prototype.buildStacks = function () {\n        var a = this.axis,\n            f = a.series,\n            q = C(a.options.reversedStacks, !0),\n            n = f.length,\n            E;\n\n        if (!a.isXAxis) {\n          this.usePercentage = !1;\n\n          for (E = n; E--;) {\n            var p = f[q ? E : n - E - 1];\n            p.setStackedPoints();\n            p.setGroupedPoints();\n          }\n\n          for (E = 0; E < n; E++) {\n            f[E].modifyStacks();\n          }\n\n          y(a, \"afterBuildStacks\");\n        }\n      };\n\n      a.prototype.cleanStacks = function () {\n        if (!this.axis.isXAxis) {\n          if (this.oldStacks) var a = this.stacks = this.oldStacks;\n          G(a, function (a) {\n            G(a, function (a) {\n              a.cumulative = a.total;\n            });\n          });\n        }\n      };\n\n      a.prototype.resetStacks = function () {\n        var a = this,\n            f = a.stacks;\n        a.axis.isXAxis || G(f, function (f) {\n          G(f, function (q, n) {\n            q.touched < a.stacksTouched ? (q.destroy(), delete f[n]) : (q.total = null, q.cumulative = null);\n          });\n        });\n      };\n\n      a.prototype.renderStackTotals = function () {\n        var a = this.axis,\n            f = a.chart,\n            q = f.renderer,\n            n = this.stacks;\n        a = D(f, a.options.stackLabels.animation);\n        var E = this.stackTotalGroup = this.stackTotalGroup || q.g(\"stack-labels\").attr({\n          visibility: \"visible\",\n          zIndex: 6,\n          opacity: 0\n        }).add();\n        E.translate(f.plotLeft, f.plotTop);\n        G(n, function (a) {\n          G(a, function (a) {\n            a.render(E);\n          });\n        });\n        E.animate({\n          opacity: 1\n        }, a);\n      };\n\n      return a;\n    }();\n\n    return function () {\n      function f() {}\n\n      f.compose = function (n) {\n        a(n, \"init\", f.onInit);\n        a(n, \"destroy\", f.onDestroy);\n      };\n\n      f.onDestroy = function () {\n        var a = this.stacking;\n\n        if (a) {\n          var f = a.stacks;\n          G(f, function (a, v) {\n            n(a);\n            f[v] = null;\n          });\n          a && a.stackTotalGroup && a.stackTotalGroup.destroy();\n        }\n      };\n\n      f.onInit = function () {\n        this.stacking || (this.stacking = new J(this));\n      };\n\n      return f;\n    }();\n  });\n  O(n, \"Mixins/LegendSymbol.js\", [n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = a.merge,\n        y = a.pick;\n    return f.LegendSymbolMixin = {\n      drawRectangle: function drawRectangle(a, f) {\n        var n = a.symbolHeight,\n            D = a.options.squareSymbol;\n        f.legendSymbol = this.chart.renderer.rect(D ? (a.symbolWidth - n) / 2 : 0, a.baseline - n + 1, D ? n : a.symbolWidth, n, y(a.options.symbolRadius, n / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(f.legendGroup);\n      },\n      drawLineMarker: function drawLineMarker(a) {\n        var f = this.options,\n            C = f.marker,\n            D = a.symbolWidth,\n            H = a.symbolHeight,\n            v = H / 2,\n            L = this.chart.renderer,\n            q = this.legendGroup;\n        a = a.baseline - Math.round(.3 * a.fontMetrics.b);\n        var K = {};\n        this.chart.styledMode || (K = {\n          \"stroke-width\": f.lineWidth || 0\n        }, f.dashStyle && (K.dashstyle = f.dashStyle));\n        this.legendLine = L.path([[\"M\", 0, a], [\"L\", D, a]]).addClass(\"highcharts-graph\").attr(K).add(q);\n        C && !1 !== C.enabled && D && (f = Math.min(y(C.radius, v), v), 0 === this.symbol.indexOf(\"url\") && (C = n(C, {\n          width: H,\n          height: H\n        }), f = 0), this.legendSymbol = C = L.symbol(this.symbol, D / 2 - f, a - f, 2 * f, 2 * f, C).addClass(\"highcharts-point\").add(q), C.isMarker = !0);\n      }\n    };\n  });\n  O(n, \"Core/Series/Point.js\", [n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = a.animObject,\n        y = a.defined,\n        D = a.erase,\n        G = a.extend,\n        C = a.fireEvent,\n        J = a.format,\n        H = a.getNestedProperty,\n        v = a.isArray,\n        L = a.isNumber,\n        q = a.isObject,\n        K = a.syncTimeout,\n        E = a.pick,\n        p = a.removeEvent,\n        t = a.uniqueKey;\n    \"\";\n\n    a = function () {\n      function a() {\n        this.colorIndex = this.category = void 0;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n\n      a.prototype.animateBeforeDestroy = function () {\n        var a = this,\n            f = {\n          x: a.startXPos,\n          opacity: 0\n        },\n            h,\n            l = a.getGraphicalProps();\n        l.singular.forEach(function (k) {\n          h = \"dataLabel\" === k;\n          a[k] = a[k].animate(h ? {\n            x: a[k].startXPos,\n            y: a[k].startYPos,\n            opacity: 0\n          } : f);\n        });\n        l.plural.forEach(function (h) {\n          a[h].forEach(function (g) {\n            g.element && g.animate(G({\n              x: a.startXPos\n            }, g.startYPos ? {\n              x: g.startXPos,\n              y: g.startYPos\n            } : {}));\n          });\n        });\n      };\n\n      a.prototype.applyOptions = function (f, m) {\n        var h = this.series,\n            l = h.options.pointValKey || h.pointValKey;\n        f = a.prototype.optionsToObject.call(this, f);\n        G(this, f);\n        this.options = this.options ? G(this.options, f) : f;\n        f.group && delete this.group;\n        f.dataLabels && delete this.dataLabels;\n        l && (this.y = a.prototype.getNestedProperty.call(this, l));\n        this.formatPrefix = (this.isNull = E(this.isValid && !this.isValid(), null === this.x || !L(this.y))) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && \"undefined\" === typeof m && h.xAxis && h.xAxis.hasNames && (this.x = h.xAxis.nameToX(this));\n        \"undefined\" === typeof this.x && h && (this.x = \"undefined\" === typeof m ? h.autoIncrement(this) : m);\n        return this;\n      };\n\n      a.prototype.destroy = function () {\n        function a() {\n          if (f.graphic || f.dataLabel || f.dataLabels) p(f), f.destroyElements();\n\n          for (d in f) {\n            f[d] = null;\n          }\n        }\n\n        var f = this,\n            h = f.series,\n            l = h.chart;\n        h = h.options.dataSorting;\n        var k = l.hoverPoints,\n            g = n(f.series.chart.renderer.globalAnimation),\n            d;\n        f.legendItem && l.legend.destroyItem(f);\n        k && (f.setState(), D(k, f), k.length || (l.hoverPoints = null));\n        if (f === l.hoverPoint) f.onMouseOut();\n        h && h.enabled ? (this.animateBeforeDestroy(), K(a, g.duration)) : a();\n        l.pointCount--;\n      };\n\n      a.prototype.destroyElements = function (a) {\n        var f = this;\n        a = f.getGraphicalProps(a);\n        a.singular.forEach(function (a) {\n          f[a] = f[a].destroy();\n        });\n        a.plural.forEach(function (a) {\n          f[a].forEach(function (a) {\n            a.element && a.destroy();\n          });\n          delete f[a];\n        });\n      };\n\n      a.prototype.firePointEvent = function (a, f, h) {\n        var l = this,\n            k = this.series.options;\n        (k.point.events[a] || l.options && l.options.events && l.options.events[a]) && l.importEvents();\n        \"click\" === a && k.allowPointSelect && (h = function h(a) {\n          l.select && l.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        C(l, a, f, h);\n      };\n\n      a.prototype.getClassName = function () {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      };\n\n      a.prototype.getGraphicalProps = function (a) {\n        var f = this,\n            h = [],\n            l,\n            k = {\n          singular: [],\n          plural: []\n        };\n        a = a || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        a.graphic && h.push(\"graphic\", \"shadowGroup\");\n        a.dataLabel && h.push(\"dataLabel\", \"dataLabelUpper\", \"connector\");\n\n        for (l = h.length; l--;) {\n          var g = h[l];\n          f[g] && k.singular.push(g);\n        }\n\n        [\"dataLabel\", \"connector\"].forEach(function (d) {\n          var g = d + \"s\";\n          a[d] && f[g] && k.plural.push(g);\n        });\n        return k;\n      };\n\n      a.prototype.getLabelConfig = function () {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      };\n\n      a.prototype.getNestedProperty = function (a) {\n        if (a) return 0 === a.indexOf(\"custom.\") ? H(a, this.options) : this[a];\n      };\n\n      a.prototype.getZone = function () {\n        var a = this.series,\n            f = a.zones;\n        a = a.zoneAxis || \"y\";\n        var h = 0,\n            l;\n\n        for (l = f[h]; this[a] >= l.value;) {\n          l = f[++h];\n        }\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = l && l.color && !this.options.color ? l.color : this.nonZonedColor;\n        return l;\n      };\n\n      a.prototype.hasNewShapeType = function () {\n        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n      };\n\n      a.prototype.init = function (a, f, h) {\n        this.series = a;\n        this.applyOptions(f, h);\n        this.id = y(this.id) ? this.id : t();\n        this.resolveColor();\n        a.chart.pointCount++;\n        C(this, \"afterInit\");\n        return this;\n      };\n\n      a.prototype.optionsToObject = function (f) {\n        var m = {},\n            h = this.series,\n            l = h.options.keys,\n            k = l || h.pointArrayMap || [\"y\"],\n            g = k.length,\n            d = 0,\n            p = 0;\n        if (L(f) || null === f) m[k[0]] = f;else if (v(f)) for (!l && f.length > g && (h = typeof f[0], \"string\" === h ? m.name = f[0] : \"number\" === h && (m.x = f[0]), d++); p < g;) {\n          l && \"undefined\" === typeof f[d] || (0 < k[p].indexOf(\".\") ? a.prototype.setNestedProperty(m, f[d], k[p]) : m[k[p]] = f[d]), d++, p++;\n        } else \"object\" === typeof f && (m = f, f.dataLabels && (h._hasPointLabels = !0), f.marker && (h._hasPointMarkers = !0));\n        return m;\n      };\n\n      a.prototype.resolveColor = function () {\n        var a = this.series;\n        var f = a.chart.options.chart.colorCount;\n        var h = a.chart.styledMode;\n        delete this.nonZonedColor;\n        h || this.options.color || (this.color = a.color);\n        a.options.colorByPoint ? (h || (f = a.options.colors || a.chart.options.colors, this.color = this.color || f[a.colorCounter], f = f.length), h = a.colorCounter, a.colorCounter++, a.colorCounter === f && (a.colorCounter = 0)) : h = a.colorIndex;\n        this.colorIndex = E(this.colorIndex, h);\n      };\n\n      a.prototype.setNestedProperty = function (a, f, h) {\n        h.split(\".\").reduce(function (a, h, g, d) {\n          a[h] = d.length - 1 === g ? f : q(a[h], !0) ? a[h] : {};\n          return a[h];\n        }, a);\n        return a;\n      };\n\n      a.prototype.tooltipFormatter = function (a) {\n        var f = this.series,\n            h = f.tooltipOptions,\n            l = E(h.valueDecimals, \"\"),\n            k = h.valuePrefix || \"\",\n            g = h.valueSuffix || \"\";\n        f.chart.styledMode && (a = f.chart.tooltip.styledModeFormat(a));\n        (f.pointArrayMap || [\"y\"]).forEach(function (d) {\n          d = \"{point.\" + d;\n          if (k || g) a = a.replace(RegExp(d + \"}\", \"g\"), k + d + \"}\" + g);\n          a = a.replace(RegExp(d + \"}\", \"g\"), d + \":,.\" + l + \"f}\");\n        });\n        return J(a, {\n          point: this,\n          series: this.series\n        }, f.chart);\n      };\n\n      return a;\n    }();\n\n    return f.Point = a;\n  });\n  O(n, \"Core/Series/Series.js\", [n[\"Core/Globals.js\"], n[\"Mixins/LegendSymbol.js\"], n[\"Core/Options.js\"], n[\"Core/Series/Point.js\"], n[\"Core/Renderer/SVG/SVGElement.js\"], n[\"Core/Utilities.js\"]], function (f, a, n, y, D, G) {\n    var C = n.defaultOptions,\n        J = G.addEvent,\n        H = G.animObject,\n        v = G.arrayMax,\n        L = G.arrayMin,\n        q = G.clamp,\n        K = G.correctFloat,\n        E = G.defined,\n        p = G.erase,\n        t = G.error,\n        I = G.extend,\n        u = G.find,\n        m = G.fireEvent,\n        h = G.getNestedProperty,\n        l = G.isArray,\n        k = G.isFunction,\n        g = G.isNumber,\n        d = G.isString,\n        x = G.merge,\n        r = G.objectEach,\n        A = G.pick,\n        N = G.removeEvent;\n    n = G.seriesType;\n    var B = G.splat,\n        M = G.syncTimeout;\n    \"\";\n    var R = f.seriesTypes,\n        F = f.win;\n    f.Series = n(\"line\", null, {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        defer: !0,\n        formatter: function formatter() {\n          var e = this.series.chart.numberFormatter;\n          return \"number\" !== typeof this.y ? \"\" : e(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 50\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    }, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      isCartesian: !0,\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: y,\n      requireSorting: !0,\n      sorted: !0,\n      init: function init(e, c) {\n        m(this, \"init\", {\n          options: c\n        });\n        var b = this,\n            a = e.series,\n            d;\n        this.eventOptions = this.eventOptions || {};\n        this.eventsToUnbind = [];\n        b.chart = e;\n        b.options = c = b.setOptions(c);\n        b.linkedSeries = [];\n        b.bindAxes();\n        I(b, {\n          name: c.name,\n          state: \"\",\n          visible: !1 !== c.visible,\n          selected: !0 === c.selected\n        });\n        var g = c.events;\n        r(g, function (c, e) {\n          k(c) && b.eventOptions[e] !== c && (k(b.eventOptions[e]) && N(b, e, b.eventOptions[e]), b.eventOptions[e] = c, J(b, e, c));\n        });\n        if (g && g.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) e.runTrackerClick = !0;\n        b.getColor();\n        b.getSymbol();\n        b.parallelArrays.forEach(function (c) {\n          b[c + \"Data\"] || (b[c + \"Data\"] = []);\n        });\n        b.isCartesian && (e.hasCartesianSeries = !0);\n        a.length && (d = a[a.length - 1]);\n        b._i = A(d && d._i, -1) + 1;\n        b.opacity = b.options.opacity;\n        e.orderSeries(this.insert(a));\n        c.dataSorting && c.dataSorting.enabled ? b.setDataSortingOptions() : b.points || b.data || b.setData(c.data, !1);\n        m(this, \"afterInit\");\n      },\n      is: function is(e) {\n        return R[e] && this instanceof R[e];\n      },\n      insert: function insert(e) {\n        var c = this.options.index,\n            b;\n\n        if (g(c)) {\n          for (b = e.length; b--;) {\n            if (c >= A(e[b].options.index, e[b]._i)) {\n              e.splice(b + 1, 0, this);\n              break;\n            }\n          }\n\n          -1 === b && e.unshift(this);\n          b += 1;\n        } else e.push(this);\n\n        return A(b, e.length - 1);\n      },\n      bindAxes: function bindAxes() {\n        var e = this,\n            c = e.options,\n            b = e.chart,\n            a;\n        m(this, \"bindAxes\", null, function () {\n          (e.axisTypes || []).forEach(function (d) {\n            b[d].forEach(function (b) {\n              a = b.options;\n              if (c[d] === a.index || \"undefined\" !== typeof c[d] && c[d] === a.id || \"undefined\" === typeof c[d] && 0 === a.index) e.insert(b.series), e[d] = b, b.isDirty = !0;\n            });\n            e[d] || e.optionalAxis === d || t(18, !0, b);\n          });\n        });\n        m(this, \"afterBindAxes\");\n      },\n      updateParallelArrays: function updateParallelArrays(e, c) {\n        var b = e.series,\n            a = arguments,\n            d = g(c) ? function (a) {\n          var d = \"y\" === a && b.toYData ? b.toYData(e) : e[a];\n          b[a + \"Data\"][c] = d;\n        } : function (e) {\n          Array.prototype[c].apply(b[e + \"Data\"], Array.prototype.slice.call(a, 2));\n        };\n        b.parallelArrays.forEach(d);\n      },\n      hasData: function hasData() {\n        return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      },\n      autoIncrement: function autoIncrement() {\n        var e = this.options,\n            c = this.xIncrement,\n            b,\n            a = e.pointIntervalUnit,\n            d = this.chart.time;\n        c = A(c, e.pointStart, 0);\n        this.pointInterval = b = A(this.pointInterval, e.pointInterval, 1);\n        a && (e = new d.Date(c), \"day\" === a ? d.set(\"Date\", e, d.get(\"Date\", e) + b) : \"month\" === a ? d.set(\"Month\", e, d.get(\"Month\", e) + b) : \"year\" === a && d.set(\"FullYear\", e, d.get(\"FullYear\", e) + b), b = e.getTime() - c);\n        this.xIncrement = c + b;\n        return c;\n      },\n      setDataSortingOptions: function setDataSortingOptions() {\n        var e = this.options;\n        I(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        });\n        E(e.pointRange) || (e.pointRange = 1);\n      },\n      setOptions: function setOptions(e) {\n        var c = this.chart,\n            b = c.options,\n            a = b.plotOptions,\n            d = c.userOptions || {};\n        e = x(e);\n        c = c.styledMode;\n        var g = {\n          plotOptions: a,\n          userOptions: e\n        };\n        m(this, \"setOptions\", g);\n        var h = g.plotOptions[this.type],\n            f = d.plotOptions || {};\n        this.userOptions = g.userOptions;\n        d = x(h, a.series, d.plotOptions && d.plotOptions[this.type], e);\n        this.tooltipOptions = x(C.tooltip, C.plotOptions.series && C.plotOptions.series.tooltip, C.plotOptions[this.type].tooltip, b.tooltip.userOptions, a.series && a.series.tooltip, a[this.type].tooltip, e.tooltip);\n        this.stickyTracking = A(e.stickyTracking, f[this.type] && f[this.type].stickyTracking, f.series && f.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : d.stickyTracking);\n        null === h.marker && delete d.marker;\n        this.zoneAxis = d.zoneAxis;\n        b = this.zones = (d.zones || []).slice();\n        !d.negativeColor && !d.negativeFillColor || d.zones || (a = {\n          value: d[this.zoneAxis + \"Threshold\"] || d.threshold || 0,\n          className: \"highcharts-negative\"\n        }, c || (a.color = d.negativeColor, a.fillColor = d.negativeFillColor), b.push(a));\n        b.length && E(b[b.length - 1].value) && b.push(c ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        m(this, \"afterSetOptions\", {\n          options: d\n        });\n        return d;\n      },\n      getName: function getName() {\n        return A(this.options.name, \"Series \" + (this.index + 1));\n      },\n      getCyclic: function getCyclic(e, c, b) {\n        var a = this.chart,\n            d = this.userOptions,\n            g = e + \"Index\",\n            h = e + \"Counter\",\n            f = b ? b.length : A(a.options.chart[e + \"Count\"], a[e + \"Count\"]);\n\n        if (!c) {\n          var k = A(d[g], d[\"_\" + g]);\n          E(k) || (a.series.length || (a[h] = 0), d[\"_\" + g] = k = a[h] % f, a[h] += 1);\n          b && (c = b[k]);\n        }\n\n        \"undefined\" !== typeof k && (this[g] = k);\n        this[e] = c;\n      },\n      getColor: function getColor() {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || C.plotOptions[this.type].color, this.chart.options.colors);\n      },\n      getPointsCollection: function getPointsCollection() {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      },\n      getSymbol: function getSymbol() {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      },\n      findPointIndex: function findPointIndex(e, c) {\n        var b = e.id,\n            a = e.x,\n            d = this.points,\n            h,\n            f = this.options.dataSorting;\n        if (b) var k = this.chart.get(b);else if (this.linkedParent || this.enabledDataSorting) {\n          var l = f && f.matchByName ? \"name\" : \"index\";\n          k = u(d, function (b) {\n            return !b.touched && b[l] === e[l];\n          });\n          if (!k) return;\n        }\n\n        if (k) {\n          var m = k && k.index;\n          \"undefined\" !== typeof m && (h = !0);\n        }\n\n        \"undefined\" === typeof m && g(a) && (m = this.xData.indexOf(a, c));\n        -1 !== m && \"undefined\" !== typeof m && this.cropped && (m = m >= this.cropStart ? m - this.cropStart : m);\n        !h && d[m] && d[m].touched && (m = void 0);\n        return m;\n      },\n      drawLegendSymbol: a.drawLineMarker,\n      updateData: function updateData(e, c) {\n        var b = this.options,\n            a = b.dataSorting,\n            d = this.points,\n            h = [],\n            f,\n            k,\n            l,\n            m = this.requireSorting,\n            p = e.length === d.length,\n            r = !0;\n        this.xIncrement = null;\n        e.forEach(function (c, e) {\n          var k = E(c) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, c) || {};\n          var w = k.x;\n\n          if (k.id || g(w)) {\n            if (w = this.findPointIndex(k, l), -1 === w || \"undefined\" === typeof w ? h.push(c) : d[w] && c !== b.data[w] ? (d[w].update(c, !1, null, !1), d[w].touched = !0, m && (l = w + 1)) : d[w] && (d[w].touched = !0), !p || e !== w || a && a.enabled || this.hasDerivedData) f = !0;\n          } else h.push(c);\n        }, this);\n        if (f) for (e = d.length; e--;) {\n          (k = d[e]) && !k.touched && k.remove && k.remove(!1, c);\n        } else !p || a && a.enabled ? r = !1 : (e.forEach(function (b, c) {\n          d[c].update && b !== d[c].y && d[c].update(b, !1, null, !1);\n        }), h.length = 0);\n        d.forEach(function (b) {\n          b && (b.touched = !1);\n        });\n        if (!r) return !1;\n        h.forEach(function (b) {\n          this.addPoint(b, !1, null, null, !1);\n        }, this);\n        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = v(this.xData), this.autoIncrement());\n        return !0;\n      },\n      setData: function setData(e, c, b, a) {\n        var h = this,\n            f = h.points,\n            k = f && f.length || 0,\n            m,\n            p = h.options,\n            r = h.chart,\n            B = p.dataSorting,\n            z = null,\n            n = h.xAxis;\n        z = p.turboThreshold;\n        var q = this.xData,\n            x = this.yData,\n            F = (m = h.pointArrayMap) && m.length,\n            M = p.keys,\n            v = 0,\n            u = 1,\n            I;\n        e = e || [];\n        m = e.length;\n        c = A(c, !0);\n        B && B.enabled && (e = this.sortData(e));\n        !1 !== a && m && k && !h.cropped && !h.hasGroupedData && h.visible && !h.isSeriesBoosting && (I = this.updateData(e, b));\n\n        if (!I) {\n          h.xIncrement = null;\n          h.colorCounter = 0;\n          this.parallelArrays.forEach(function (b) {\n            h[b + \"Data\"].length = 0;\n          });\n          if (z && m > z) {\n            if (z = h.getFirstValidPoint(e), g(z)) for (b = 0; b < m; b++) {\n              q[b] = this.autoIncrement(), x[b] = e[b];\n            } else if (l(z)) {\n              if (F) for (b = 0; b < m; b++) {\n                a = e[b], q[b] = a[0], x[b] = a.slice(1, F + 1);\n              } else for (M && (v = M.indexOf(\"x\"), u = M.indexOf(\"y\"), v = 0 <= v ? v : 0, u = 0 <= u ? u : 1), b = 0; b < m; b++) {\n                a = e[b], q[b] = a[v], x[b] = a[u];\n              }\n            } else t(12, !1, r);\n          } else for (b = 0; b < m; b++) {\n            \"undefined\" !== typeof e[b] && (a = {\n              series: h\n            }, h.pointClass.prototype.applyOptions.apply(a, [e[b]]), h.updateParallelArrays(a, b));\n          }\n          x && d(x[0]) && t(14, !0, r);\n          h.data = [];\n          h.options.data = h.userOptions.data = e;\n\n          for (b = k; b--;) {\n            f[b] && f[b].destroy && f[b].destroy();\n          }\n\n          n && (n.minRange = n.userMinRange);\n          h.isDirty = r.isDirtyBox = !0;\n          h.isDirtyData = !!f;\n          b = !1;\n        }\n\n        \"point\" === p.legendType && (this.processData(), this.generatePoints());\n        c && r.redraw(b);\n      },\n      sortData: function sortData(e) {\n        var c = this,\n            b = c.options.dataSorting.sortKey || \"y\",\n            a = function a(b, c) {\n          return E(c) && b.pointClass.prototype.optionsToObject.call({\n            series: b\n          }, c) || {};\n        };\n\n        e.forEach(function (b, d) {\n          e[d] = a(c, b);\n          e[d].index = d;\n        }, this);\n        e.concat().sort(function (c, e) {\n          c = h(b, c);\n          e = h(b, e);\n          return e < c ? -1 : e > c ? 1 : 0;\n        }).forEach(function (b, c) {\n          b.x = c;\n        }, this);\n        c.linkedSeries && c.linkedSeries.forEach(function (b) {\n          var c = b.options,\n              d = c.data;\n          c.dataSorting && c.dataSorting.enabled || !d || (d.forEach(function (c, g) {\n            d[g] = a(b, c);\n            e[g] && (d[g].x = e[g].x, d[g].index = g);\n          }), b.setData(d, !1));\n        });\n        return e;\n      },\n      getProcessedData: function getProcessedData(e) {\n        var c = this.xData,\n            b = this.yData,\n            a = c.length;\n        var d = 0;\n        var g = this.xAxis,\n            h = this.options;\n        var f = h.cropThreshold;\n        var k = e || this.getExtremesFromAll || h.getExtremesFromAll,\n            l = this.isCartesian;\n        e = g && g.val2lin;\n        h = !(!g || !g.logarithmic);\n        var m = this.requireSorting;\n\n        if (g) {\n          g = g.getExtremes();\n          var p = g.min;\n          var r = g.max;\n        }\n\n        if (l && this.sorted && !k && (!f || a > f || this.forceCrop)) if (c[a - 1] < p || c[0] > r) c = [], b = [];else if (this.yData && (c[0] < p || c[a - 1] > r)) {\n          d = this.cropData(this.xData, this.yData, p, r);\n          c = d.xData;\n          b = d.yData;\n          d = d.start;\n          var B = !0;\n        }\n\n        for (f = c.length || 1; --f;) {\n          if (a = h ? e(c[f]) - e(c[f - 1]) : c[f] - c[f - 1], 0 < a && (\"undefined\" === typeof n || a < n)) var n = a;else 0 > a && m && (t(15, !1, this.chart), m = !1);\n        }\n\n        return {\n          xData: c,\n          yData: b,\n          cropped: B,\n          cropStart: d,\n          closestPointRange: n\n        };\n      },\n      processData: function processData(e) {\n        var c = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !c.isDirty && !this.yAxis.isDirty && !e) return !1;\n        e = this.getProcessedData();\n        this.cropped = e.cropped;\n        this.cropStart = e.cropStart;\n        this.processedXData = e.xData;\n        this.processedYData = e.yData;\n        this.closestPointRange = this.basePointRange = e.closestPointRange;\n      },\n      cropData: function cropData(e, c, b, a, d) {\n        var g = e.length,\n            h = 0,\n            f = g,\n            k;\n        d = A(d, this.cropShoulder);\n\n        for (k = 0; k < g; k++) {\n          if (e[k] >= b) {\n            h = Math.max(0, k - d);\n            break;\n          }\n        }\n\n        for (b = k; b < g; b++) {\n          if (e[b] > a) {\n            f = b + d;\n            break;\n          }\n        }\n\n        return {\n          xData: e.slice(h, f),\n          yData: c.slice(h, f),\n          start: h,\n          end: f\n        };\n      },\n      generatePoints: function generatePoints() {\n        var e = this.options,\n            c = e.data,\n            b = this.data,\n            a,\n            d = this.processedXData,\n            g = this.processedYData,\n            h = this.pointClass,\n            f = d.length,\n            k = this.cropStart || 0,\n            l = this.hasGroupedData;\n        e = e.keys;\n        var p = [],\n            r;\n        b || l || (b = [], b.length = c.length, b = this.data = b);\n        e && l && (this.options.keys = !1);\n\n        for (r = 0; r < f; r++) {\n          var t = k + r;\n\n          if (l) {\n            var n = new h().init(this, [d[r]].concat(B(g[r])));\n            n.dataGroup = this.groupMap[r];\n            n.dataGroup.options && (n.options = n.dataGroup.options, I(n, n.dataGroup.options), delete n.dataLabels);\n          } else (n = b[t]) || \"undefined\" === typeof c[t] || (b[t] = n = new h().init(this, c[t], d[r]));\n\n          n && (n.index = t, p[r] = n);\n        }\n\n        this.options.keys = e;\n        if (b && (f !== (a = b.length) || l)) for (r = 0; r < a; r++) {\n          r !== k || l || (r += f), b[r] && (b[r].destroyElements(), b[r].plotX = void 0);\n        }\n        this.data = b;\n        this.points = p;\n        m(this, \"afterGeneratePoints\");\n      },\n      getXExtremes: function getXExtremes(e) {\n        return {\n          min: L(e),\n          max: v(e)\n        };\n      },\n      getExtremes: function getExtremes(e, c) {\n        var b = this.xAxis,\n            a = this.yAxis,\n            d = this.processedXData || this.xData,\n            h = [],\n            f = 0,\n            k = 0;\n        var p = 0;\n        var r = this.requireSorting ? this.cropShoulder : 0,\n            t = a ? a.positiveValuesOnly : !1,\n            B;\n        e = e || this.stackedYData || this.processedYData || [];\n        a = e.length;\n        b && (p = b.getExtremes(), k = p.min, p = p.max);\n\n        for (B = 0; B < a; B++) {\n          var n = d[B];\n          var q = e[B];\n          var x = (g(q) || l(q)) && (q.length || 0 < q || !t);\n          n = c || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !b || (d[B + r] || n) >= k && (d[B - r] || n) <= p;\n          if (x && n) if (x = q.length) for (; x--;) {\n            g(q[x]) && (h[f++] = q[x]);\n          } else h[f++] = q;\n        }\n\n        e = {\n          dataMin: L(h),\n          dataMax: v(h)\n        };\n        m(this, \"afterGetExtremes\", {\n          dataExtremes: e\n        });\n        return e;\n      },\n      applyExtremes: function applyExtremes() {\n        var e = this.getExtremes();\n        this.dataMin = e.dataMin;\n        this.dataMax = e.dataMax;\n        return e;\n      },\n      getFirstValidPoint: function getFirstValidPoint(e) {\n        for (var c = null, b = e.length, a = 0; null === c && a < b;) {\n          c = e[a], a++;\n        }\n\n        return c;\n      },\n      translate: function translate() {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var e = this.options,\n            c = e.stacking,\n            b = this.xAxis,\n            a = b.categories,\n            d = this.enabledDataSorting,\n            h = this.yAxis,\n            f = this.points,\n            k = f.length,\n            p = !!this.modifyValue,\n            r,\n            t = this.pointPlacementToXValue(),\n            B = !!t,\n            n = e.threshold,\n            x = e.startFromThreshold ? n : 0,\n            F,\n            M = this.zoneAxis || \"y\",\n            v = Number.MAX_VALUE;\n\n        for (r = 0; r < k; r++) {\n          var u = f[r],\n              I = u.x,\n              C = u.y,\n              H = u.low,\n              R = c && h.stacking && h.stacking.stacks[(this.negStacks && C < (x ? 0 : n) ? \"-\" : \"\") + this.stackKey];\n          if (h.positiveValuesOnly && !h.validatePositiveValue(C) || b.positiveValuesOnly && !b.validatePositiveValue(I)) u.isNull = !0;\n          u.plotX = F = K(q(b.translate(I, 0, 0, 0, 1, t, \"flags\" === this.type), -1E5, 1E5));\n\n          if (c && this.visible && R && R[I]) {\n            var y = this.getStackIndicator(y, I, this.index);\n\n            if (!u.isNull) {\n              var N = R[I];\n              var D = N.points[y.key];\n            }\n          }\n\n          l(D) && (H = D[0], C = D[1], H === x && y.key === R[I].base && (H = A(g(n) && n, h.min)), h.positiveValuesOnly && 0 >= H && (H = null), u.total = u.stackTotal = N.total, u.percentage = N.total && u.y / N.total * 100, u.stackY = C, this.irregularWidths || N.setOffset(this.pointXOffset || 0, this.barW || 0));\n          u.yBottom = E(H) ? q(h.translate(H, 0, 1, 0, 1), -1E5, 1E5) : null;\n          p && (C = this.modifyValue(C, u));\n          u.plotY = \"number\" === typeof C && Infinity !== C ? q(h.translate(C, 0, 1, 0, 1), -1E5, 1E5) : void 0;\n          u.isInside = this.isPointInside(u);\n          u.clientX = B ? K(b.translate(I, 0, 0, 0, 1, t)) : F;\n          u.negative = u[M] < (e[M + \"Threshold\"] || n || 0);\n          u.category = a && \"undefined\" !== typeof a[u.x] ? a[u.x] : u.x;\n\n          if (!u.isNull && !1 !== u.visible) {\n            \"undefined\" !== typeof G && (v = Math.min(v, Math.abs(F - G)));\n            var G = F;\n          }\n\n          u.zone = this.zones.length && u.getZone();\n          !u.graphic && this.group && d && (u.isNew = !0);\n        }\n\n        this.closestPointRangePx = v;\n        m(this, \"afterTranslate\");\n      },\n      getValidPoints: function getValidPoints(e, c, b) {\n        var a = this.chart;\n        return (e || this.points || []).filter(function (e) {\n          return c && !a.isInsidePlot(e.plotX, e.plotY, a.inverted) ? !1 : !1 !== e.visible && (b || !e.isNull);\n        });\n      },\n      getClipBox: function getClipBox(e, c) {\n        var b = this.options,\n            a = this.chart,\n            d = a.inverted,\n            g = this.xAxis,\n            h = g && this.yAxis,\n            f = a.options.chart.scrollablePlotArea || {};\n        e && !1 === b.clip && h ? e = d ? {\n          y: -a.chartWidth + h.len + h.pos,\n          height: a.chartWidth,\n          width: a.chartHeight,\n          x: -a.chartHeight + g.len + g.pos\n        } : {\n          y: -h.pos,\n          height: a.chartHeight,\n          width: a.chartWidth,\n          x: -g.pos\n        } : (e = this.clipBox || a.clipBox, c && (e.width = a.plotSizeX, e.x = (a.scrollablePixelsX || 0) * (f.scrollPositionX || 0)));\n        return c ? {\n          width: e.width,\n          x: e.x\n        } : e;\n      },\n      setClip: function setClip(e) {\n        var c = this.chart,\n            b = this.options,\n            a = c.renderer,\n            d = c.inverted,\n            g = this.clipBox,\n            h = this.getClipBox(e),\n            f = this.sharedClipKey || [\"_sharedClip\", e && e.duration, e && e.easing, h.height, b.xAxis, b.yAxis].join(),\n            k = c[f],\n            l = c[f + \"m\"];\n        e && (h.width = 0, d && (h.x = c.plotHeight + (!1 !== b.clip ? 0 : c.plotTop)));\n        k ? c.hasLoaded || k.attr(h) : (e && (c[f + \"m\"] = l = a.clipRect(d ? c.plotSizeX + 99 : -99, d ? -c.plotLeft : -c.plotTop, 99, d ? c.chartWidth : c.chartHeight)), c[f] = k = a.clipRect(h), k.count = {\n          length: 0\n        });\n        e && !k.count[this.index] && (k.count[this.index] = !0, k.count.length += 1);\n        if (!1 !== b.clip || e) this.group.clip(e || g ? k : c.clipRect), this.markerGroup.clip(l), this.sharedClipKey = f;\n        e || (k.count[this.index] && (delete k.count[this.index], --k.count.length), 0 === k.count.length && f && c[f] && (g || (c[f] = c[f].destroy()), c[f + \"m\"] && (c[f + \"m\"] = c[f + \"m\"].destroy())));\n      },\n      animate: function animate(e) {\n        var c = this.chart,\n            b = H(this.options.animation);\n        if (!c.hasRendered) if (e) this.setClip(b);else {\n          var a = this.sharedClipKey;\n          e = c[a];\n          var d = this.getClipBox(b, !0);\n          e && e.animate(d, b);\n          c[a + \"m\"] && c[a + \"m\"].animate({\n            width: d.width + 99,\n            x: d.x - (c.inverted ? 0 : 99)\n          }, b);\n        }\n      },\n      afterAnimate: function afterAnimate() {\n        this.setClip();\n        m(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      },\n      drawPoints: function drawPoints() {\n        var e = this.points,\n            c = this.chart,\n            b,\n            a,\n            d = this.options.marker,\n            g = this[this.specialGroup] || this.markerGroup,\n            h = this.xAxis,\n            f = A(d.enabled, !h || h.isRadial ? !0 : null, this.closestPointRangePx >= d.enabledThreshold * d.radius);\n        if (!1 !== d.enabled || this._hasPointMarkers) for (b = 0; b < e.length; b++) {\n          var k = e[b];\n          var l = (a = k.graphic) ? \"animate\" : \"attr\";\n          var m = k.marker || {};\n          var p = !!k.marker;\n\n          if ((f && \"undefined\" === typeof m.enabled || m.enabled) && !k.isNull && !1 !== k.visible) {\n            var r = A(m.symbol, this.symbol);\n            var t = this.markerAttribs(k, k.selected && \"select\");\n            this.enabledDataSorting && (k.startXPos = h.reversed ? -t.width : h.width);\n            var B = !1 !== k.isInside;\n            a ? a[B ? \"show\" : \"hide\"](B).animate(t) : B && (0 < t.width || k.hasImage) && (k.graphic = a = c.renderer.symbol(r, t.x, t.y, t.width, t.height, p ? m : d).add(g), this.enabledDataSorting && c.hasRendered && (a.attr({\n              x: k.startXPos\n            }), l = \"animate\"));\n            a && \"animate\" === l && a[B ? \"show\" : \"hide\"](B).animate(t);\n            if (a && !c.styledMode) a[l](this.pointAttribs(k, k.selected && \"select\"));\n            a && a.addClass(k.getClassName(), !0);\n          } else a && (k.graphic = a.destroy());\n        }\n      },\n      markerAttribs: function markerAttribs(e, c) {\n        var b = this.options,\n            a = b.marker,\n            d = e.marker || {},\n            g = d.symbol || a.symbol,\n            h = A(d.radius, a.radius);\n        c && (a = a.states[c], c = d.states && d.states[c], h = A(c && c.radius, a && a.radius, h + (a && a.radiusPlus || 0)));\n        e.hasImage = g && 0 === g.indexOf(\"url\");\n        e.hasImage && (h = 0);\n        e = {\n          x: b.crisp ? Math.floor(e.plotX) - h : e.plotX - h,\n          y: e.plotY - h\n        };\n        h && (e.width = e.height = 2 * h);\n        return e;\n      },\n      pointAttribs: function pointAttribs(e, c) {\n        var b = this.options.marker,\n            a = e && e.options,\n            d = a && a.marker || {},\n            g = this.color,\n            h = a && a.color,\n            f = e && e.color;\n        a = A(d.lineWidth, b.lineWidth);\n        var k = e && e.zone && e.zone.color;\n        e = 1;\n        g = h || k || f || g;\n        h = d.fillColor || b.fillColor || g;\n        g = d.lineColor || b.lineColor || g;\n        c = c || \"normal\";\n        b = b.states[c];\n        c = d.states && d.states[c] || {};\n        a = A(c.lineWidth, b.lineWidth, a + A(c.lineWidthPlus, b.lineWidthPlus, 0));\n        h = c.fillColor || b.fillColor || h;\n        g = c.lineColor || b.lineColor || g;\n        e = A(c.opacity, b.opacity, e);\n        return {\n          stroke: g,\n          \"stroke-width\": a,\n          fill: h,\n          opacity: e\n        };\n      },\n      destroy: function destroy(e) {\n        var c = this,\n            b = c.chart,\n            a = /AppleWebKit\\/533/.test(F.navigator.userAgent),\n            d,\n            g,\n            h = c.data || [],\n            f,\n            k;\n        m(c, \"destroy\");\n        this.removeEvents(e);\n        (c.axisTypes || []).forEach(function (b) {\n          (k = c[b]) && k.series && (p(k.series, c), k.isDirty = k.forceRedraw = !0);\n        });\n        c.legendItem && c.chart.legend.destroyItem(c);\n\n        for (g = h.length; g--;) {\n          (f = h[g]) && f.destroy && f.destroy();\n        }\n\n        c.points = null;\n        G.clearTimeout(c.animationTimeout);\n        r(c, function (b, c) {\n          b instanceof D && !b.survive && (d = a && \"group\" === c ? \"hide\" : \"destroy\", b[d]());\n        });\n        b.hoverSeries === c && (b.hoverSeries = null);\n        p(b.series, c);\n        b.orderSeries();\n        r(c, function (b, a) {\n          e && \"hcEvents\" === a || delete c[a];\n        });\n      },\n      getGraphPath: function getGraphPath(e, c, b) {\n        var a = this,\n            d = a.options,\n            g = d.step,\n            h,\n            f = [],\n            k = [],\n            l;\n        e = e || a.points;\n        (h = e.reversed) && e.reverse();\n        (g = {\n          right: 1,\n          center: 2\n        }[g] || g && 3) && h && (g = 4 - g);\n        e = this.getValidPoints(e, !1, !(d.connectNulls && !c && !b));\n        e.forEach(function (h, m) {\n          var p = h.plotX,\n              r = h.plotY,\n              t = e[m - 1];\n          (h.leftCliff || t && t.rightCliff) && !b && (l = !0);\n          h.isNull && !E(c) && 0 < m ? l = !d.connectNulls : h.isNull && !c ? l = !0 : (0 === m || l ? m = [[\"M\", h.plotX, h.plotY]] : a.getPointSpline ? m = [a.getPointSpline(e, h, m)] : g ? (m = 1 === g ? [[\"L\", t.plotX, r]] : 2 === g ? [[\"L\", (t.plotX + p) / 2, t.plotY], [\"L\", (t.plotX + p) / 2, r]] : [[\"L\", p, t.plotY]], m.push([\"L\", p, r])) : m = [[\"L\", p, r]], k.push(h.x), g && (k.push(h.x), 2 === g && k.push(h.x)), f.push.apply(f, m), l = !1);\n        });\n        f.xMap = k;\n        return a.graphPath = f;\n      },\n      drawGraph: function drawGraph() {\n        var e = this,\n            c = this.options,\n            b = (this.gappedPath || this.getGraphPath).call(this),\n            a = this.chart.styledMode,\n            d = [[\"graph\", \"highcharts-graph\"]];\n        a || d[0].push(c.lineColor || this.color || \"#cccccc\", c.dashStyle);\n        d = e.getZonesGraphs(d);\n        d.forEach(function (d, g) {\n          var h = d[0],\n              f = e[h],\n              k = f ? \"animate\" : \"attr\";\n          f ? (f.endX = e.preventGraphAnimation ? null : b.xMap, f.animate({\n            d: b\n          })) : b.length && (e[h] = f = e.chart.renderer.path(b).addClass(d[1]).attr({\n            zIndex: 1\n          }).add(e.group));\n          f && !a && (h = {\n            stroke: d[2],\n            \"stroke-width\": c.lineWidth,\n            fill: e.fillGraph && e.color || \"none\"\n          }, d[3] ? h.dashstyle = d[3] : \"square\" !== c.linecap && (h[\"stroke-linecap\"] = h[\"stroke-linejoin\"] = \"round\"), f[k](h).shadow(2 > g && c.shadow));\n          f && (f.startX = b.xMap, f.isArea = b.isArea);\n        });\n      },\n      getZonesGraphs: function getZonesGraphs(a) {\n        this.zones.forEach(function (c, b) {\n          b = [\"zone-graph-\" + b, \"highcharts-graph highcharts-zone-graph-\" + b + \" \" + (c.className || \"\")];\n          this.chart.styledMode || b.push(c.color || this.color, c.dashStyle || this.options.dashStyle);\n          a.push(b);\n        }, this);\n        return a;\n      },\n      applyZones: function applyZones() {\n        var a = this,\n            c = this.chart,\n            b = c.renderer,\n            d = this.zones,\n            g,\n            h,\n            f = this.clips || [],\n            k,\n            l = this.graph,\n            m = this.area,\n            p = Math.max(c.chartWidth, c.chartHeight),\n            r = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            t = c.inverted,\n            B,\n            n,\n            x,\n            F = !1,\n            u,\n            M;\n\n        if (d.length && (l || m) && r && \"undefined\" !== typeof r.min) {\n          var v = r.reversed;\n          var I = r.horiz;\n          l && !this.showLine && l.hide();\n          m && m.hide();\n          var E = r.getExtremes();\n          d.forEach(function (e, d) {\n            g = v ? I ? c.plotWidth : 0 : I ? 0 : r.toPixels(E.min) || 0;\n            g = q(A(h, g), 0, p);\n            h = q(Math.round(r.toPixels(A(e.value, E.max), !0) || 0), 0, p);\n            F && (g = h = r.toPixels(E.max));\n            B = Math.abs(g - h);\n            n = Math.min(g, h);\n            x = Math.max(g, h);\n            r.isXAxis ? (k = {\n              x: t ? x : n,\n              y: 0,\n              width: B,\n              height: p\n            }, I || (k.x = c.plotHeight - k.x)) : (k = {\n              x: 0,\n              y: t ? x : n,\n              width: p,\n              height: B\n            }, I && (k.y = c.plotWidth - k.y));\n            t && b.isVML && (k = r.isXAxis ? {\n              x: 0,\n              y: v ? n : x,\n              height: k.width,\n              width: c.chartWidth\n            } : {\n              x: k.y - c.plotLeft - c.spacingBox.x,\n              y: 0,\n              width: k.height,\n              height: c.chartHeight\n            });\n            f[d] ? f[d].animate(k) : f[d] = b.clipRect(k);\n            u = a[\"zone-area-\" + d];\n            M = a[\"zone-graph-\" + d];\n            l && M && M.clip(f[d]);\n            m && u && u.clip(f[d]);\n            F = e.value > E.max;\n            a.resetZones && 0 === h && (h = void 0);\n          });\n          this.clips = f;\n        } else a.visible && (l && l.show(!0), m && m.show(!0));\n      },\n      invertGroups: function invertGroups(a) {\n        function c() {\n          [\"group\", \"markerGroup\"].forEach(function (c) {\n            b[c] && (e.renderer.isVML && b[c].attr({\n              width: b.yAxis.len,\n              height: b.xAxis.len\n            }), b[c].width = b.yAxis.len, b[c].height = b.xAxis.len, b[c].invert(b.isRadialSeries ? !1 : a));\n          });\n        }\n\n        var b = this,\n            e = b.chart;\n        b.xAxis && (b.eventsToUnbind.push(J(e, \"resize\", c)), c(), b.invertGroups = c);\n      },\n      plotGroup: function plotGroup(a, c, b, d, g) {\n        var e = this[a],\n            h = !e;\n        b = {\n          visibility: b,\n          zIndex: d || .1\n        };\n        \"undefined\" === typeof this.opacity || this.chart.styledMode || \"inactive\" === this.state || (b.opacity = this.opacity);\n        h && (this[a] = e = this.chart.renderer.g().add(g));\n        e.addClass(\"highcharts-\" + c + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (E(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (e.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        e.attr(b)[h ? \"attr\" : \"animate\"](this.getPlotBox());\n        return e;\n      },\n      getPlotBox: function getPlotBox() {\n        var a = this.chart,\n            c = this.xAxis,\n            b = this.yAxis;\n        a.inverted && (c = b, b = this.xAxis);\n        return {\n          translateX: c ? c.left : a.plotLeft,\n          translateY: b ? b.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      },\n      removeEvents: function removeEvents(a) {\n        a ? this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (c) {\n          c();\n        }), this.eventsToUnbind.length = 0) : N(this);\n      },\n      render: function render() {\n        var a = this,\n            c = a.chart,\n            b = a.options,\n            d = H(b.animation),\n            g = !a.finishedAnimating && c.renderer.isSVG && d.duration,\n            h = a.visible ? \"inherit\" : \"hidden\",\n            f = b.zIndex,\n            k = a.hasRendered,\n            l = c.seriesGroup,\n            p = c.inverted;\n        m(this, \"render\");\n        var r = a.plotGroup(\"group\", \"series\", h, f, l);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", h, f, l);\n        g && a.animate && a.animate(!0);\n        r.inverted = a.isCartesian || a.invertable ? p : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.visible && a.drawPoints();\n        a.drawDataLabels && a.drawDataLabels();\n        a.redrawPoints && a.redrawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(p);\n        !1 === b.clip || a.sharedClipKey || k || r.clip(c.clipRect);\n        g && a.animate && a.animate();\n        k || (g && d.defer && (g += d.defer), a.animationTimeout = M(function () {\n          a.afterAnimate();\n        }, g || 0));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        m(a, \"afterRender\");\n      },\n      redraw: function redraw() {\n        var a = this.chart,\n            c = this.isDirty || this.isDirtyData,\n            b = this.group,\n            d = this.xAxis,\n            g = this.yAxis;\n        b && (a.inverted && b.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), b.animate({\n          translateX: A(d && d.left, a.plotLeft),\n          translateY: A(g && g.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        c && delete this.kdTree;\n      },\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      searchPoint: function searchPoint(a, c) {\n        var b = this.xAxis,\n            d = this.yAxis,\n            e = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: e ? b.len - a.chartY + b.pos : a.chartX - b.pos,\n          plotY: e ? d.len - a.chartX + d.pos : a.chartY - d.pos\n        }, c, a);\n      },\n      buildKDTree: function buildKDTree(a) {\n        function c(a, d, e) {\n          var g;\n\n          if (g = a && a.length) {\n            var h = b.kdAxisArray[d % e];\n            a.sort(function (b, c) {\n              return b[h] - c[h];\n            });\n            g = Math.floor(g / 2);\n            return {\n              point: a[g],\n              left: c(a.slice(0, g), d + 1, e),\n              right: c(a.slice(g + 1), d + 1, e)\n            };\n          }\n        }\n\n        this.buildingKdTree = !0;\n        var b = this,\n            d = -1 < b.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete b.kdTree;\n        M(function () {\n          b.kdTree = c(b.getValidPoints(null, !b.directTouch), d, d);\n          b.buildingKdTree = !1;\n        }, b.options.kdNow || a && \"touchstart\" === a.type ? 0 : 1);\n      },\n      searchKDTree: function searchKDTree(a, c, b) {\n        function d(b, c, a, k) {\n          var l = c.point,\n              m = e.kdAxisArray[a % k],\n              p = l;\n          var r = E(b[g]) && E(l[g]) ? Math.pow(b[g] - l[g], 2) : null;\n          var t = E(b[h]) && E(l[h]) ? Math.pow(b[h] - l[h], 2) : null;\n          t = (r || 0) + (t || 0);\n          l.dist = E(t) ? Math.sqrt(t) : Number.MAX_VALUE;\n          l.distX = E(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n          m = b[m] - l[m];\n          t = 0 > m ? \"left\" : \"right\";\n          r = 0 > m ? \"right\" : \"left\";\n          c[t] && (t = d(b, c[t], a + 1, k), p = t[f] < p[f] ? t : l);\n          c[r] && Math.sqrt(m * m) < p[f] && (b = d(b, c[r], a + 1, k), p = b[f] < p[f] ? b : p);\n          return p;\n        }\n\n        var e = this,\n            g = this.kdAxisArray[0],\n            h = this.kdAxisArray[1],\n            f = c ? \"distX\" : \"dist\";\n        c = -1 < e.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(b);\n        if (this.kdTree) return d(a, this.kdTree, c, c);\n      },\n      pointPlacementToXValue: function pointPlacementToXValue() {\n        var a = this.options,\n            c = a.pointRange,\n            b = this.xAxis;\n        a = a.pointPlacement;\n        \"between\" === a && (a = b.reversed ? -.5 : .5);\n        return g(a) ? a * A(c, b.pointRange) : 0;\n      },\n      isPointInside: function isPointInside(a) {\n        return \"undefined\" !== typeof a.plotY && \"undefined\" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= this.yAxis.len && 0 <= a.plotX && a.plotX <= this.xAxis.len;\n      }\n    });\n    \"\";\n  });\n  O(n, \"Extensions/Stacking.js\", [n[\"Core/Axis/Axis.js\"], n[\"Core/Chart/Chart.js\"], n[\"Core/Globals.js\"], n[\"Core/Axis/StackingAxis.js\"], n[\"Core/Utilities.js\"]], function (f, a, n, y, D) {\n    var G = D.correctFloat,\n        C = D.defined,\n        J = D.destroyObjectProperties,\n        H = D.format,\n        v = D.isNumber,\n        L = D.pick;\n    \"\";\n\n    var q = n.Series,\n        K = function () {\n      function a(a, f, n, q, m) {\n        var h = a.chart.inverted;\n        this.axis = a;\n        this.isNegative = n;\n        this.options = f = f || {};\n        this.x = q;\n        this.total = null;\n        this.points = {};\n        this.hasValidPoints = !1;\n        this.stack = m;\n        this.rightCliff = this.leftCliff = 0;\n        this.alignOptions = {\n          align: f.align || (h ? n ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: f.verticalAlign || (h ? \"middle\" : n ? \"bottom\" : \"top\"),\n          y: f.y,\n          x: f.x\n        };\n        this.textAlign = f.textAlign || (h ? n ? \"right\" : \"left\" : \"center\");\n      }\n\n      a.prototype.destroy = function () {\n        J(this, this.axis);\n      };\n\n      a.prototype.render = function (a) {\n        var f = this.axis.chart,\n            p = this.options,\n            n = p.format;\n        n = n ? H(n, this, f) : p.formatter.call(this);\n        this.label ? this.label.attr({\n          text: n,\n          visibility: \"hidden\"\n        }) : (this.label = f.renderer.label(n, null, null, p.shape, null, null, p.useHTML, !1, \"stack-labels\"), n = {\n          r: p.borderRadius || 0,\n          text: n,\n          rotation: p.rotation,\n          padding: L(p.padding, 5),\n          visibility: \"hidden\"\n        }, f.styledMode || (n.fill = p.backgroundColor, n.stroke = p.borderColor, n[\"stroke-width\"] = p.borderWidth, this.label.css(p.style)), this.label.attr(n), this.label.added || this.label.add(a));\n        this.label.labelrank = f.plotHeight;\n      };\n\n      a.prototype.setOffset = function (a, f, n, u, m) {\n        var h = this.axis,\n            l = h.chart;\n        u = h.translate(h.stacking.usePercentage ? 100 : u ? u : this.total, 0, 0, 0, 1);\n        n = h.translate(n ? n : 0);\n        n = C(u) && Math.abs(u - n);\n        a = L(m, l.xAxis[0].translate(this.x)) + a;\n        h = C(u) && this.getStackBox(l, this, a, u, f, n, h);\n        f = this.label;\n        n = this.isNegative;\n        a = \"justify\" === L(this.options.overflow, \"justify\");\n        var k = this.textAlign;\n        f && h && (m = f.getBBox(), u = f.padding, k = \"left\" === k ? l.inverted ? -u : u : \"right\" === k ? m.width : l.inverted && \"center\" === k ? m.width / 2 : l.inverted ? n ? m.width + u : -u : m.width / 2, n = l.inverted ? m.height / 2 : n ? -u : m.height, this.alignOptions.x = L(this.options.x, 0), this.alignOptions.y = L(this.options.y, 0), h.x -= k, h.y -= n, f.align(this.alignOptions, null, h), l.isInsidePlot(f.alignAttr.x + k - this.alignOptions.x, f.alignAttr.y + n - this.alignOptions.y) ? f.show() : (f.alignAttr.y = -9999, a = !1), a && q.prototype.justifyDataLabel.call(this.axis, f, this.alignOptions, f.alignAttr, m, h), f.attr({\n          x: f.alignAttr.x,\n          y: f.alignAttr.y\n        }), L(!a && this.options.crop, !0) && ((l = v(f.x) && v(f.y) && l.isInsidePlot(f.x - u + f.width, f.y) && l.isInsidePlot(f.x + u, f.y)) || f.hide()));\n      };\n\n      a.prototype.getStackBox = function (a, f, n, q, m, h, l) {\n        var k = f.axis.reversed,\n            g = a.inverted,\n            d = l.height + l.pos - (g ? a.plotLeft : a.plotTop);\n        f = f.isNegative && !k || !f.isNegative && k;\n        return {\n          x: g ? f ? q - l.right : q - h + l.pos - a.plotLeft : n + a.xAxis[0].transB - a.plotLeft,\n          y: g ? l.height - n - m : f ? d - q - h : d - q,\n          width: g ? h : m,\n          height: g ? m : h\n        };\n      };\n\n      return a;\n    }();\n\n    a.prototype.getStacks = function () {\n      var a = this,\n          f = a.inverted;\n      a.yAxis.forEach(function (a) {\n        a.stacking && a.stacking.stacks && a.hasVisibleSeries && (a.stacking.oldStacks = a.stacking.stacks);\n      });\n      a.series.forEach(function (p) {\n        var n = p.xAxis && p.xAxis.options || {};\n        !p.options.stacking || !0 !== p.visible && !1 !== a.options.chart.ignoreHiddenSeries || (p.stackKey = [p.type, L(p.options.stack, \"\"), f ? n.top : n.left, f ? n.height : n.width].join());\n      });\n    };\n\n    y.compose(f);\n\n    q.prototype.setGroupedPoints = function () {\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && 1 < this.chart.series.length && q.prototype.setStackedPoints.call(this, \"group\");\n    };\n\n    q.prototype.setStackedPoints = function (a) {\n      var f = a || this.options.stacking;\n\n      if (f && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var n = this.processedXData,\n            q = this.processedYData,\n            u = [],\n            m = q.length,\n            h = this.options,\n            l = h.threshold,\n            k = L(h.startFromThreshold && l, 0);\n        h = h.stack;\n        a = a ? this.type + \",\" + f : this.stackKey;\n        var g = \"-\" + a,\n            d = this.negStacks,\n            x = this.yAxis,\n            r = x.stacking.stacks,\n            A = x.stacking.oldStacks,\n            v,\n            B;\n        x.stacking.stacksTouched += 1;\n\n        for (B = 0; B < m; B++) {\n          var M = n[B];\n          var E = q[B];\n          var F = this.getStackIndicator(F, M, this.index);\n          var e = F.key;\n          var c = (v = d && E < (k ? 0 : l)) ? g : a;\n          r[c] || (r[c] = {});\n          r[c][M] || (A[c] && A[c][M] ? (r[c][M] = A[c][M], r[c][M].total = null) : r[c][M] = new K(x, x.options.stackLabels, v, M, h));\n          c = r[c][M];\n          null !== E ? (c.points[e] = c.points[this.index] = [L(c.cumulative, k)], C(c.cumulative) || (c.base = e), c.touched = x.stacking.stacksTouched, 0 < F.index && !1 === this.singleStacks && (c.points[e][0] = c.points[this.index + \",\" + M + \",0\"][0])) : c.points[e] = c.points[this.index] = null;\n          \"percent\" === f ? (v = v ? a : g, d && r[v] && r[v][M] ? (v = r[v][M], c.total = v.total = Math.max(v.total, c.total) + Math.abs(E) || 0) : c.total = G(c.total + (Math.abs(E) || 0))) : \"group\" === f ? null !== E && (c.total = (c.total || 0) + 1) : c.total = G(c.total + (E || 0));\n          c.cumulative = \"group\" === f ? (c.total || 1) - 1 : L(c.cumulative, k) + (E || 0);\n          null !== E && (c.points[e].push(c.cumulative), u[B] = c.cumulative, c.hasValidPoints = !0);\n        }\n\n        \"percent\" === f && (x.stacking.usePercentage = !0);\n        \"group\" !== f && (this.stackedYData = u);\n        x.stacking.oldStacks = {};\n      }\n    };\n\n    q.prototype.modifyStacks = function () {\n      var a = this,\n          f = a.stackKey,\n          n = a.yAxis.stacking.stacks,\n          q = a.processedXData,\n          v,\n          m = a.options.stacking;\n      a[m + \"Stacker\"] && [f, \"-\" + f].forEach(function (h) {\n        for (var f = q.length, k, g; f--;) {\n          if (k = q[f], v = a.getStackIndicator(v, k, a.index, h), g = (k = n[h] && n[h][k]) && k.points[v.key]) a[m + \"Stacker\"](g, k, f);\n        }\n      });\n    };\n\n    q.prototype.percentStacker = function (a, f, n) {\n      f = f.total ? 100 / f.total : 0;\n      a[0] = G(a[0] * f);\n      a[1] = G(a[1] * f);\n      this.stackedYData[n] = a[1];\n    };\n\n    q.prototype.getStackIndicator = function (a, f, n, q) {\n      !C(a) || a.x !== f || q && a.key !== q ? a = {\n        x: f,\n        index: 0,\n        key: q\n      } : a.index++;\n      a.key = [n, f, a.index].join();\n      return a;\n    };\n\n    n.StackItem = K;\n    return n.StackItem;\n  });\n  O(n, \"Core/Dynamics.js\", [n[\"Core/Axis/Axis.js\"], n[\"Core/Chart/Chart.js\"], n[\"Core/Globals.js\"], n[\"Core/Options.js\"], n[\"Core/Series/Point.js\"], n[\"Core/Time.js\"], n[\"Core/Utilities.js\"]], function (f, a, n, y, D, G, C) {\n    var J = y.time,\n        H = C.addEvent,\n        v = C.animate,\n        L = C.createElement,\n        q = C.css,\n        K = C.defined,\n        E = C.erase,\n        p = C.error,\n        t = C.extend,\n        I = C.fireEvent,\n        u = C.isArray,\n        m = C.isNumber,\n        h = C.isObject,\n        l = C.isString,\n        k = C.merge,\n        g = C.objectEach,\n        d = C.pick,\n        x = C.relativeLength,\n        r = C.setAnimation,\n        A = C.splat;\n    y = n.Series;\n    var N = n.seriesTypes;\n\n    n.cleanRecursively = function (a, d) {\n      var f = {};\n      g(a, function (g, e) {\n        if (h(a[e], !0) && !a.nodeType && d[e]) g = n.cleanRecursively(a[e], d[e]), Object.keys(g).length && (f[e] = g);else if (h(a[e]) || a[e] !== d[e]) f[e] = a[e];\n      });\n      return f;\n    };\n\n    t(a.prototype, {\n      addSeries: function addSeries(a, g, h) {\n        var f,\n            e = this;\n        a && (g = d(g, !0), I(e, \"addSeries\", {\n          options: a\n        }, function () {\n          f = e.initSeries(a);\n          e.isDirtyLegend = !0;\n          e.linkSeries();\n          f.enabledDataSorting && f.setData(a.data, !1);\n          I(e, \"afterAddSeries\", {\n            series: f\n          });\n          g && e.redraw(h);\n        }));\n        return f;\n      },\n      addAxis: function addAxis(a, d, g, h) {\n        return this.createAxis(d ? \"xAxis\" : \"yAxis\", {\n          axis: a,\n          redraw: g,\n          animation: h\n        });\n      },\n      addColorAxis: function addColorAxis(a, d, g) {\n        return this.createAxis(\"colorAxis\", {\n          axis: a,\n          redraw: d,\n          animation: g\n        });\n      },\n      createAxis: function createAxis(a, g) {\n        var h = this.options,\n            l = \"colorAxis\" === a,\n            e = g.redraw,\n            c = g.animation;\n        g = k(g.axis, {\n          index: this[a].length,\n          isX: \"xAxis\" === a\n        });\n        var b = l ? new n.ColorAxis(this, g) : new f(this, g);\n        h[a] = A(h[a] || {});\n        h[a].push(g);\n        l && (this.isDirtyLegend = !0, this.axes.forEach(function (b) {\n          b.series = [];\n        }), this.series.forEach(function (b) {\n          b.bindAxes();\n          b.isDirtyData = !0;\n        }));\n        d(e, !0) && this.redraw(c);\n        return b;\n      },\n      showLoading: function showLoading(a) {\n        var g = this,\n            h = g.options,\n            f = g.loadingDiv,\n            e = h.loading,\n            c = function c() {\n          f && q(f, {\n            left: g.plotLeft + \"px\",\n            top: g.plotTop + \"px\",\n            width: g.plotWidth + \"px\",\n            height: g.plotHeight + \"px\"\n          });\n        };\n\n        f || (g.loadingDiv = f = L(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, g.container), g.loadingSpan = L(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, f), H(g, \"redraw\", c));\n        f.className = \"highcharts-loading\";\n        g.loadingSpan.innerHTML = d(a, h.lang.loading, \"\");\n        g.styledMode || (q(f, t(e.style, {\n          zIndex: 10\n        })), q(g.loadingSpan, e.labelStyle), g.loadingShown || (q(f, {\n          opacity: 0,\n          display: \"\"\n        }), v(f, {\n          opacity: e.style.opacity || .5\n        }, {\n          duration: e.showDuration || 0\n        })));\n        g.loadingShown = !0;\n        c();\n      },\n      hideLoading: function hideLoading() {\n        var a = this.options,\n            d = this.loadingDiv;\n        d && (d.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || v(d, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function complete() {\n            q(d, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      },\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \"),\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"zAxis\", \"series\"],\n      update: function update(a, h, f, p) {\n        var e = this,\n            c = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\",\n          caption: \"setCaption\"\n        },\n            b,\n            r,\n            q,\n            t = a.isResponsiveOptions,\n            B = [];\n        I(e, \"update\", {\n          options: a\n        });\n        t || e.setResponsive(!1, !0);\n        a = n.cleanRecursively(a, e.options);\n        k(!0, e.userOptions, a);\n\n        if (b = a.chart) {\n          k(!0, e.options.chart, b);\n          \"className\" in b && e.setClassName(b.className);\n          \"reflow\" in b && e.setReflow(b.reflow);\n\n          if (\"inverted\" in b || \"polar\" in b || \"type\" in b) {\n            e.propFromSeries();\n            var F = !0;\n          }\n\n          \"alignTicks\" in b && (F = !0);\n          g(b, function (b, a) {\n            -1 !== e.propsRequireUpdateSeries.indexOf(\"chart.\" + a) && (r = !0);\n            -1 !== e.propsRequireDirtyBox.indexOf(a) && (e.isDirtyBox = !0);\n            -1 !== e.propsRequireReflow.indexOf(a) && (t ? e.isDirtyBox = !0 : q = !0);\n          });\n          !e.styledMode && \"style\" in b && e.renderer.setStyle(b.style);\n        }\n\n        !e.styledMode && a.colors && (this.options.colors = a.colors);\n        a.plotOptions && k(!0, this.options.plotOptions, a.plotOptions);\n        a.time && this.time === J && (this.time = new G(a.time));\n        g(a, function (b, a) {\n          if (e[a] && \"function\" === typeof e[a].update) e[a].update(b, !1);else if (\"function\" === typeof e[c[a]]) e[c[a]](b);\n          \"chart\" !== a && -1 !== e.propsRequireUpdateSeries.indexOf(a) && (r = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (b) {\n          if (a[b]) {\n            if (\"series\" === b) {\n              var c = [];\n              e[b].forEach(function (b, a) {\n                b.options.isInternal || c.push(d(b.options.index, a));\n              });\n            }\n\n            A(a[b]).forEach(function (a, d) {\n              var g = K(a.id),\n                  h;\n              g && (h = e.get(a.id));\n              h || (h = e[b][c ? c[d] : d]) && g && K(h.options.id) && (h = void 0);\n              h && h.coll === b && (h.update(a, !1), f && (h.touched = !0));\n              !h && f && e.collectionsWithInit[b] && (e.collectionsWithInit[b][0].apply(e, [a].concat(e.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);\n            });\n            f && e[b].forEach(function (b) {\n              b.touched || b.options.isInternal ? delete b.touched : B.push(b);\n            });\n          }\n        });\n        B.forEach(function (b) {\n          b.remove && b.remove(!1);\n        });\n        F && e.axes.forEach(function (b) {\n          b.update({}, !1);\n        });\n        r && e.getSeriesOrderByLinks().forEach(function (b) {\n          b.chart && b.update({}, !1);\n        }, this);\n        a.loading && k(!0, e.options.loading, a.loading);\n        F = b && b.width;\n        b = b && b.height;\n        l(b) && (b = x(b, F || e.chartWidth));\n        q || m(F) && F !== e.chartWidth || m(b) && b !== e.chartHeight ? e.setSize(F, b, p) : d(h, !0) && e.redraw(p);\n        I(e, \"afterUpdate\", {\n          options: a,\n          redraw: h,\n          animation: p\n        });\n      },\n      setSubtitle: function setSubtitle(a, d) {\n        this.applyDescription(\"subtitle\", a);\n        this.layOutTitles(d);\n      },\n      setCaption: function setCaption(a, d) {\n        this.applyDescription(\"caption\", a);\n        this.layOutTitles(d);\n      }\n    });\n    a.prototype.collectionsWithInit = {\n      xAxis: [a.prototype.addAxis, [!0]],\n      yAxis: [a.prototype.addAxis, [!1]],\n      series: [a.prototype.addSeries]\n    };\n    t(D.prototype, {\n      update: function update(a, g, f, k) {\n        function e() {\n          c.applyOptions(a);\n          var e = l && c.hasDummyGraphic;\n          e = null === c.y ? !e : e;\n          l && e && (c.graphic = l.destroy(), delete c.hasDummyGraphic);\n          h(a, !0) && (l && l.element && a && a.marker && \"undefined\" !== typeof a.marker.symbol && (c.graphic = l.destroy()), a && a.dataLabels && c.dataLabel && (c.dataLabel = c.dataLabel.destroy()), c.connector && (c.connector = c.connector.destroy()));\n          m = c.index;\n          b.updateParallelArrays(c, m);\n          r.data[m] = h(r.data[m], !0) || h(a, !0) ? c.options : d(a, r.data[m]);\n          b.isDirty = b.isDirtyData = !0;\n          !b.fixedBox && b.hasCartesianSeries && (p.isDirtyBox = !0);\n          \"point\" === r.legendType && (p.isDirtyLegend = !0);\n          g && p.redraw(f);\n        }\n\n        var c = this,\n            b = c.series,\n            l = c.graphic,\n            m,\n            p = b.chart,\n            r = b.options;\n        g = d(g, !0);\n        !1 === k ? e() : c.firePointEvent(\"update\", {\n          options: a\n        }, e);\n      },\n      remove: function remove(a, d) {\n        this.series.removePoint(this.series.data.indexOf(this), a, d);\n      }\n    });\n    t(y.prototype, {\n      addPoint: function addPoint(a, g, h, f, e) {\n        var c = this.options,\n            b = this.data,\n            k = this.chart,\n            l = this.xAxis;\n        l = l && l.hasNames && l.names;\n        var m = c.data,\n            p = this.xData,\n            r;\n        g = d(g, !0);\n        var n = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(n, [a]);\n        var q = n.x;\n        var t = p.length;\n        if (this.requireSorting && q < p[t - 1]) for (r = !0; t && p[t - 1] > q;) {\n          t--;\n        }\n        this.updateParallelArrays(n, \"splice\", t, 0, 0);\n        this.updateParallelArrays(n, t);\n        l && n.name && (l[q] = n.name);\n        m.splice(t, 0, a);\n        r && (this.data.splice(t, 0, null), this.processData());\n        \"point\" === c.legendType && this.generatePoints();\n        h && (b[0] && b[0].remove ? b[0].remove(!1) : (b.shift(), this.updateParallelArrays(n, \"shift\"), m.shift()));\n        !1 !== e && I(this, \"addPoint\", {\n          point: n\n        });\n        this.isDirtyData = this.isDirty = !0;\n        g && k.redraw(f);\n      },\n      removePoint: function removePoint(a, g, h) {\n        var f = this,\n            e = f.data,\n            c = e[a],\n            b = f.points,\n            k = f.chart,\n            l = function l() {\n          b && b.length === e.length && b.splice(a, 1);\n          e.splice(a, 1);\n          f.options.data.splice(a, 1);\n          f.updateParallelArrays(c || {\n            series: f\n          }, \"splice\", a, 1);\n          c && c.destroy();\n          f.isDirty = !0;\n          f.isDirtyData = !0;\n          g && k.redraw();\n        };\n\n        r(h, k);\n        g = d(g, !0);\n        c ? c.firePointEvent(\"remove\", null, l) : l();\n      },\n      remove: function remove(a, g, h, f) {\n        function e() {\n          c.destroy(f);\n          c.remove = null;\n          b.isDirtyLegend = b.isDirtyBox = !0;\n          b.linkSeries();\n          d(a, !0) && b.redraw(g);\n        }\n\n        var c = this,\n            b = c.chart;\n        !1 !== h ? I(c, \"remove\", null, e) : e();\n      },\n      update: function update(a, g) {\n        a = n.cleanRecursively(a, this.userOptions);\n        I(this, \"update\", {\n          options: a\n        });\n        var h = this,\n            f = h.chart,\n            e = h.userOptions,\n            c = h.initialType || h.type,\n            b = a.type || e.type || f.options.chart.type,\n            l = !(this.hasDerivedData || a.dataGrouping || b && b !== this.type || \"undefined\" !== typeof a.pointStart || a.pointInterval || a.pointIntervalUnit || a.keys),\n            m = N[c].prototype,\n            r,\n            q = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n            x = h.finishedAnimating && {\n          animation: !1\n        },\n            B = {};\n        l && (q.push(\"data\", \"isDirtyData\", \"points\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"_hasPointLabels\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== a.visible && q.push(\"area\", \"graph\"), h.parallelArrays.forEach(function (b) {\n          q.push(b + \"Data\");\n        }), a.data && (a.dataSorting && t(h.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));\n        a = k(e, x, {\n          index: \"undefined\" === typeof e.index ? h.index : e.index,\n          pointStart: d(e.pointStart, h.xData[0])\n        }, !l && {\n          data: h.options.data\n        }, a);\n        l && a.data && (a.data = h.options.data);\n        q = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(q);\n        q.forEach(function (b) {\n          q[b] = h[b];\n          delete h[b];\n        });\n        h.remove(!1, null, !1, !0);\n\n        for (r in m) {\n          h[r] = void 0;\n        }\n\n        N[b || c] ? t(h, N[b || c].prototype) : p(17, !0, f, {\n          missingModuleFor: b || c\n        });\n        q.forEach(function (b) {\n          h[b] = q[b];\n        });\n        h.init(f, a);\n\n        if (l && this.points) {\n          var A = h.options;\n          !1 === A.visible ? (B.graphic = 1, B.dataLabel = 1) : h._hasPointLabels || (a = A.marker, e = A.dataLabels, a && (!1 === a.enabled || \"symbol\" in a) && (B.graphic = 1), e && !1 === e.enabled && (B.dataLabel = 1));\n          this.points.forEach(function (b) {\n            b && b.series && (b.resolveColor(), Object.keys(B).length && b.destroyElements(B), !1 === A.showInLegend && b.legendItem && f.legend.destroyItem(b));\n          }, this);\n        }\n\n        h.initialType = c;\n        f.linkSeries();\n        I(this, \"afterUpdate\");\n        d(g, !0) && f.redraw(l ? void 0 : !1);\n      },\n      setName: function setName(a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      }\n    });\n    t(f.prototype, {\n      update: function update(a, h) {\n        var f = this.chart,\n            l = a && a.events || {};\n        a = k(this.userOptions, a);\n        f.options[this.coll].indexOf && (f.options[this.coll][f.options[this.coll].indexOf(this.userOptions)] = a);\n        g(f.options[this.coll].events, function (a, c) {\n          \"undefined\" === typeof l[c] && (l[c] = void 0);\n        });\n        this.destroy(!0);\n        this.init(f, t(a, {\n          events: l\n        }));\n        f.isDirtyBox = !0;\n        d(h, !0) && f.redraw();\n      },\n      remove: function remove(a) {\n        for (var g = this.chart, h = this.coll, f = this.series, e = f.length; e--;) {\n          f[e] && f[e].remove(!1);\n        }\n\n        E(g.axes, this);\n        E(g[h], this);\n        u(g.options[h]) ? g.options[h].splice(this.options.index, 1) : delete g.options[h];\n        g[h].forEach(function (a, b) {\n          a.options.index = a.userOptions.index = b;\n        });\n        this.destroy();\n        g.isDirtyBox = !0;\n        d(a, !0) && g.redraw();\n      },\n      setTitle: function setTitle(a, d) {\n        this.update({\n          title: a\n        }, d);\n      },\n      setCategories: function setCategories(a, d) {\n        this.update({\n          categories: a\n        }, d);\n      }\n    });\n  });\n  O(n, \"Series/AreaSeries.js\", [n[\"Core/Globals.js\"], n[\"Core/Color.js\"], n[\"Mixins/LegendSymbol.js\"], n[\"Core/Utilities.js\"]], function (f, a, n, y) {\n    var D = a.parse,\n        G = y.objectEach,\n        C = y.pick;\n    a = y.seriesType;\n    var J = f.Series;\n    a(\"area\", \"line\", {\n      threshold: 0\n    }, {\n      singleStacks: !1,\n      getStackPoints: function getStackPoints(a) {\n        var f = [],\n            n = [],\n            q = this.xAxis,\n            H = this.yAxis,\n            E = H.stacking.stacks[this.stackKey],\n            p = {},\n            t = this.index,\n            I = H.series,\n            u = I.length,\n            m = C(H.options.reversedStacks, !0) ? 1 : -1,\n            h;\n        a = a || this.points;\n\n        if (this.options.stacking) {\n          for (h = 0; h < a.length; h++) {\n            a[h].leftNull = a[h].rightNull = void 0, p[a[h].x] = a[h];\n          }\n\n          G(E, function (a, g) {\n            null !== a.total && n.push(g);\n          });\n          n.sort(function (a, g) {\n            return a - g;\n          });\n          var l = I.map(function (a) {\n            return a.visible;\n          });\n          n.forEach(function (a, g) {\n            var d = 0,\n                k,\n                r;\n            if (p[a] && !p[a].isNull) f.push(p[a]), [-1, 1].forEach(function (d) {\n              var f = 1 === d ? \"rightNull\" : \"leftNull\",\n                  q = 0,\n                  x = E[n[g + d]];\n              if (x) for (h = t; 0 <= h && h < u;) {\n                k = x.points[h], k || (h === t ? p[a][f] = !0 : l[h] && (r = E[a].points[h]) && (q -= r[1] - r[0])), h += m;\n              }\n              p[a][1 === d ? \"rightCliff\" : \"leftCliff\"] = q;\n            });else {\n              for (h = t; 0 <= h && h < u;) {\n                if (k = E[a].points[h]) {\n                  d = k[1];\n                  break;\n                }\n\n                h += m;\n              }\n\n              d = H.translate(d, 0, 1, 0, 1);\n              f.push({\n                isNull: !0,\n                plotX: q.translate(a, 0, 0, 0, 1),\n                x: a,\n                plotY: d,\n                yBottom: d\n              });\n            }\n          });\n        }\n\n        return f;\n      },\n      getGraphPath: function getGraphPath(a) {\n        var f = J.prototype.getGraphPath,\n            n = this.options,\n            q = n.stacking,\n            y = this.yAxis,\n            E,\n            p = [],\n            t = [],\n            I = this.index,\n            u = y.stacking.stacks[this.stackKey],\n            m = n.threshold,\n            h = Math.round(y.getThreshold(n.threshold));\n        n = C(n.connectNulls, \"percent\" === q);\n\n        var l = function l(d, f, k) {\n          var l = a[d];\n          d = q && u[l.x].points[I];\n          var r = l[k + \"Null\"] || 0;\n          k = l[k + \"Cliff\"] || 0;\n          l = !0;\n\n          if (k || r) {\n            var n = (r ? d[0] : d[1]) + k;\n            var x = d[0] + k;\n            l = !!r;\n          } else !q && a[f] && a[f].isNull && (n = x = m);\n\n          \"undefined\" !== typeof n && (t.push({\n            plotX: g,\n            plotY: null === n ? h : y.getThreshold(n),\n            isNull: l,\n            isCliff: !0\n          }), p.push({\n            plotX: g,\n            plotY: null === x ? h : y.getThreshold(x),\n            doCurve: !1\n          }));\n        };\n\n        a = a || this.points;\n        q && (a = this.getStackPoints(a));\n\n        for (E = 0; E < a.length; E++) {\n          q || (a[E].leftCliff = a[E].rightCliff = a[E].leftNull = a[E].rightNull = void 0);\n          var k = a[E].isNull;\n          var g = C(a[E].rectPlotX, a[E].plotX);\n          var d = q ? a[E].yBottom : h;\n          if (!k || n) n || l(E, E - 1, \"left\"), k && !q && n || (t.push(a[E]), p.push({\n            x: E,\n            plotX: g,\n            plotY: d\n          })), n || l(E, E + 1, \"right\");\n        }\n\n        E = f.call(this, t, !0, !0);\n        p.reversed = !0;\n        k = f.call(this, p, !0, !0);\n        (d = k[0]) && \"M\" === d[0] && (k[0] = [\"L\", d[1], d[2]]);\n        k = E.concat(k);\n        f = f.call(this, t, !1, n);\n        k.xMap = E.xMap;\n        this.areaPath = k;\n        return f;\n      },\n      drawGraph: function drawGraph() {\n        this.areaPath = [];\n        J.prototype.drawGraph.apply(this);\n        var a = this,\n            f = this.areaPath,\n            n = this.options,\n            q = [[\"area\", \"highcharts-area\", this.color, n.fillColor]];\n        this.zones.forEach(function (f, v) {\n          q.push([\"zone-area-\" + v, \"highcharts-area highcharts-zone-area-\" + v + \" \" + f.className, f.color || a.color, f.fillColor || n.fillColor]);\n        });\n        q.forEach(function (q) {\n          var v = q[0],\n              p = a[v],\n              t = p ? \"animate\" : \"attr\",\n              I = {};\n          p ? (p.endX = a.preventGraphAnimation ? null : f.xMap, p.animate({\n            d: f\n          })) : (I.zIndex = 0, p = a[v] = a.chart.renderer.path(f).addClass(q[1]).add(a.group), p.isArea = !0);\n          a.chart.styledMode || (I.fill = C(q[3], D(q[2]).setOpacity(C(n.fillOpacity, .75)).get()));\n          p[t](I);\n          p.startX = f.xMap;\n          p.shiftUnit = n.step ? 2 : 1;\n        });\n      },\n      drawLegendSymbol: n.drawRectangle\n    });\n    \"\";\n  });\n  O(n, \"Series/SplineSeries.js\", [n[\"Core/Utilities.js\"]], function (f) {\n    var a = f.pick;\n    f = f.seriesType;\n    f(\"spline\", \"line\", {}, {\n      getPointSpline: function getPointSpline(f, n, D) {\n        var y = n.plotX || 0,\n            C = n.plotY || 0,\n            J = f[D - 1];\n        D = f[D + 1];\n\n        if (J && !J.isNull && !1 !== J.doCurve && !n.isCliff && D && !D.isNull && !1 !== D.doCurve && !n.isCliff) {\n          f = J.plotY || 0;\n          var H = D.plotX || 0;\n          D = D.plotY || 0;\n          var v = 0;\n          var L = (1.5 * y + (J.plotX || 0)) / 2.5;\n          var q = (1.5 * C + f) / 2.5;\n          H = (1.5 * y + H) / 2.5;\n          var K = (1.5 * C + D) / 2.5;\n          H !== L && (v = (K - q) * (H - y) / (H - L) + C - K);\n          q += v;\n          K += v;\n          q > f && q > C ? (q = Math.max(f, C), K = 2 * C - q) : q < f && q < C && (q = Math.min(f, C), K = 2 * C - q);\n          K > D && K > C ? (K = Math.max(D, C), q = 2 * C - K) : K < D && K < C && (K = Math.min(D, C), q = 2 * C - K);\n          n.rightContX = H;\n          n.rightContY = K;\n        }\n\n        n = [\"C\", a(J.rightContX, J.plotX, 0), a(J.rightContY, J.plotY, 0), a(L, y, 0), a(q, C, 0), y, C];\n        J.rightContX = J.rightContY = void 0;\n        return n;\n      }\n    });\n    \"\";\n  });\n  O(n, \"Series/AreaSplineSeries.js\", [n[\"Core/Globals.js\"], n[\"Mixins/LegendSymbol.js\"], n[\"Core/Options.js\"], n[\"Core/Utilities.js\"]], function (f, a, n, y) {\n    y = y.seriesType;\n    f = f.seriesTypes.area.prototype;\n    y(\"areaspline\", \"spline\", n.defaultOptions.plotOptions.area, {\n      getStackPoints: f.getStackPoints,\n      getGraphPath: f.getGraphPath,\n      drawGraph: f.drawGraph,\n      drawLegendSymbol: a.drawRectangle\n    });\n    \"\";\n  });\n  O(n, \"Series/ColumnSeries.js\", [n[\"Core/Globals.js\"], n[\"Core/Color.js\"], n[\"Mixins/LegendSymbol.js\"], n[\"Core/Utilities.js\"]], function (f, a, n, y) {\n    \"\";\n\n    var D = a.parse,\n        G = y.animObject,\n        C = y.clamp,\n        J = y.defined,\n        H = y.extend,\n        v = y.isNumber,\n        L = y.merge,\n        q = y.pick;\n    a = y.seriesType;\n    var K = y.objectEach,\n        E = f.Series;\n    a(\"column\", \"line\", {\n      borderRadius: 0,\n      centerInCategory: !1,\n      groupPadding: .2,\n      marker: null,\n      pointPadding: .1,\n      minPointLength: 0,\n      cropThreshold: 50,\n      pointRange: null,\n      states: {\n        hover: {\n          halo: !1,\n          brightness: .1\n        },\n        select: {\n          color: \"#cccccc\",\n          borderColor: \"#000000\"\n        }\n      },\n      dataLabels: {\n        align: void 0,\n        verticalAlign: void 0,\n        y: void 0\n      },\n      startFromThreshold: !0,\n      stickyTracking: !1,\n      tooltip: {\n        distance: 6\n      },\n      threshold: 0,\n      borderColor: \"#ffffff\"\n    }, {\n      cropShoulder: 0,\n      directTouch: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      negStacks: !0,\n      init: function init() {\n        E.prototype.init.apply(this, arguments);\n        var a = this,\n            f = a.chart;\n        f.hasRendered && f.series.forEach(function (f) {\n          f.type === a.type && (f.isDirty = !0);\n        });\n      },\n      getColumnMetrics: function getColumnMetrics() {\n        var a = this,\n            f = a.options,\n            n = a.xAxis,\n            v = a.yAxis,\n            m = n.options.reversedStacks;\n        m = n.reversed && !m || !n.reversed && m;\n        var h,\n            l = {},\n            k = 0;\n        !1 === f.grouping ? k = 1 : a.chart.series.forEach(function (d) {\n          var g = d.yAxis,\n              f = d.options;\n\n          if (d.type === a.type && (d.visible || !a.chart.options.chart.ignoreHiddenSeries) && v.len === g.len && v.pos === g.pos) {\n            if (f.stacking && \"group\" !== f.stacking) {\n              h = d.stackKey;\n              \"undefined\" === typeof l[h] && (l[h] = k++);\n              var m = l[h];\n            } else !1 !== f.grouping && (m = k++);\n\n            d.columnIndex = m;\n          }\n        });\n        var g = Math.min(Math.abs(n.transA) * (n.ordinal && n.ordinal.slope || f.pointRange || n.closestPointRange || n.tickInterval || 1), n.len),\n            d = g * f.groupPadding,\n            x = (g - 2 * d) / (k || 1);\n        f = Math.min(f.maxPointWidth || n.len, q(f.pointWidth, x * (1 - 2 * f.pointPadding)));\n        a.columnMetrics = {\n          width: f,\n          offset: (x - f) / 2 + (d + ((a.columnIndex || 0) + (m ? 1 : 0)) * x - g / 2) * (m ? -1 : 1),\n          paddedWidth: x,\n          columnCount: k\n        };\n        return a.columnMetrics;\n      },\n      crispCol: function crispCol(a, f, n, q) {\n        var m = this.chart,\n            h = this.borderWidth,\n            l = -(h % 2 ? .5 : 0);\n        h = h % 2 ? .5 : 1;\n        m.inverted && m.renderer.isVML && (h += 1);\n        this.options.crisp && (n = Math.round(a + n) + l, a = Math.round(a) + l, n -= a);\n        q = Math.round(f + q) + h;\n        l = .5 >= Math.abs(f) && .5 < q;\n        f = Math.round(f) + h;\n        q -= f;\n        l && q && (--f, q += 1);\n        return {\n          x: a,\n          y: f,\n          width: n,\n          height: q\n        };\n      },\n      adjustForMissingColumns: function adjustForMissingColumns(a, n, q, v) {\n        var m = this,\n            h = this.options.stacking;\n\n        if (!q.isNull && 1 < v.columnCount) {\n          var l = 0,\n              k = 0;\n          K(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {\n            if (\"number\" === typeof q.x && (a = a[q.x.toString()])) {\n              var d = a.points[m.index],\n                  g = a.total;\n              h ? (d && (l = k), a.hasValidPoints && k++) : f.isArray(d) && (l = d[1], k = g || 0);\n            }\n          });\n          a = (q.plotX || 0) + ((k - 1) * v.paddedWidth + n) / 2 - n - l * v.paddedWidth;\n        }\n\n        return a;\n      },\n      translate: function translate() {\n        var a = this,\n            f = a.chart,\n            n = a.options,\n            u = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        u = a.borderWidth = q(n.borderWidth, u ? 0 : 1);\n        var m = a.xAxis,\n            h = a.yAxis,\n            l = n.threshold,\n            k = a.translatedThreshold = h.getThreshold(l),\n            g = q(n.minPointLength, 5),\n            d = a.getColumnMetrics(),\n            x = d.width,\n            r = a.barW = Math.max(x, 1 + 2 * u),\n            A = a.pointXOffset = d.offset,\n            y = a.dataMin,\n            B = a.dataMax;\n        f.inverted && (k -= .5);\n        n.pointPadding && (r = Math.ceil(r));\n        E.prototype.translate.apply(a);\n        a.points.forEach(function (p) {\n          var t = q(p.yBottom, k),\n              F = 999 + Math.abs(t),\n              e = x,\n              c = p.plotX || 0;\n          F = C(p.plotY, -F, h.len + F);\n          var b = c + A,\n              u = r,\n              w = Math.min(F, t),\n              E = Math.max(F, t) - w;\n\n          if (g && Math.abs(E) < g) {\n            E = g;\n            var M = !h.reversed && !p.negative || h.reversed && p.negative;\n            v(l) && v(B) && p.y === l && B <= l && (h.min || 0) < l && y !== B && (M = !M);\n            w = Math.abs(w - k) > g ? t - g : k - (M ? g : 0);\n          }\n\n          J(p.options.pointWidth) && (e = u = Math.ceil(p.options.pointWidth), b -= Math.round((e - x) / 2));\n          n.centerInCategory && (b = a.adjustForMissingColumns(b, e, p, d));\n          p.barX = b;\n          p.pointWidth = e;\n          p.tooltipPos = f.inverted ? [h.len + h.pos - f.plotLeft - F, m.len + m.pos - f.plotTop - (c || 0) - A - u / 2, E] : [b + u / 2, F + h.pos - f.plotTop, E];\n          p.shapeType = a.pointClass.prototype.shapeType || \"rect\";\n          p.shapeArgs = a.crispCol.apply(a, p.isNull ? [b, k, u, 0] : [b, w, u, E]);\n        });\n      },\n      getSymbol: f.noop,\n      drawLegendSymbol: n.drawRectangle,\n      drawGraph: function drawGraph() {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      },\n      pointAttribs: function pointAttribs(a, f) {\n        var p = this.options,\n            n = this.pointAttrToOptions || {};\n        var m = n.stroke || \"borderColor\";\n        var h = n[\"stroke-width\"] || \"borderWidth\",\n            l = a && a.color || this.color,\n            k = a && a[m] || p[m] || this.color || l,\n            g = a && a[h] || p[h] || this[h] || 0;\n        n = a && a.options.dashStyle || p.dashStyle;\n        var d = q(a && a.opacity, p.opacity, 1);\n\n        if (a && this.zones.length) {\n          var x = a.getZone();\n          l = a.options.color || x && (x.color || a.nonZonedColor) || this.color;\n          x && (k = x.borderColor || k, n = x.dashStyle || n, g = x.borderWidth || g);\n        }\n\n        f && a && (a = L(p.states[f], a.options.states && a.options.states[f] || {}), f = a.brightness, l = a.color || \"undefined\" !== typeof f && D(l).brighten(a.brightness).get() || l, k = a[m] || k, g = a[h] || g, n = a.dashStyle || n, d = q(a.opacity, d));\n        m = {\n          fill: l,\n          stroke: k,\n          \"stroke-width\": g,\n          opacity: d\n        };\n        n && (m.dashstyle = n);\n        return m;\n      },\n      drawPoints: function drawPoints() {\n        var a = this,\n            f = this.chart,\n            n = a.options,\n            q = f.renderer,\n            m = n.animationLimit || 250,\n            h;\n        a.points.forEach(function (l) {\n          var k = l.graphic,\n              g = !!k,\n              d = k && f.pointCount < m ? \"animate\" : \"attr\";\n\n          if (v(l.plotY) && null !== l.y) {\n            h = l.shapeArgs;\n            k && l.hasNewShapeType() && (k = k.destroy());\n            a.enabledDataSorting && (l.startXPos = a.xAxis.reversed ? -(h ? h.width : 0) : a.xAxis.width);\n            k || (l.graphic = k = q[l.shapeType](h).add(l.group || a.group)) && a.enabledDataSorting && f.hasRendered && f.pointCount < m && (k.attr({\n              x: l.startXPos\n            }), g = !0, d = \"animate\");\n            if (k && g) k[d](L(h));\n            if (n.borderRadius) k[d]({\n              r: n.borderRadius\n            });\n            f.styledMode || k[d](a.pointAttribs(l, l.selected && \"select\")).shadow(!1 !== l.allowShadow && n.shadow, null, n.stacking && !n.borderRadius);\n            k.addClass(l.getClassName(), !0);\n          } else k && (l.graphic = k.destroy());\n        });\n      },\n      animate: function animate(a) {\n        var f = this,\n            p = this.yAxis,\n            n = f.options,\n            m = this.chart.inverted,\n            h = {},\n            l = m ? \"translateX\" : \"translateY\";\n        if (a) h.scaleY = .001, a = C(p.toPixels(n.threshold), p.pos, p.pos + p.len), m ? h.translateX = a - p.len : h.translateY = a, f.clipBox && f.setClip(), f.group.attr(h);else {\n          var k = f.group.attr(l);\n          f.group.animate({\n            scaleY: 1\n          }, H(G(f.options.animation), {\n            step: function step(a, d) {\n              f.group && (h[l] = k + d.pos * (p.pos - k), f.group.attr(h));\n            }\n          }));\n        }\n      },\n      remove: function remove() {\n        var a = this,\n            f = a.chart;\n        f.hasRendered && f.series.forEach(function (f) {\n          f.type === a.type && (f.isDirty = !0);\n        });\n        E.prototype.remove.apply(a, arguments);\n      }\n    });\n    \"\";\n  });\n  O(n, \"Series/BarSeries.js\", [n[\"Core/Utilities.js\"]], function (f) {\n    f = f.seriesType;\n    f(\"bar\", \"column\", null, {\n      inverted: !0\n    });\n    \"\";\n  });\n  O(n, \"Series/ScatterSeries.js\", [n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = a.addEvent;\n    a = a.seriesType;\n    var y = f.Series;\n    a(\"scatter\", \"line\", {\n      lineWidth: 0,\n      findNearestPointBy: \"xy\",\n      jitter: {\n        x: 0,\n        y: 0\n      },\n      marker: {\n        enabled: !0\n      },\n      tooltip: {\n        headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>',\n        pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n      }\n    }, {\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1,\n      drawGraph: function drawGraph() {\n        this.options.lineWidth && y.prototype.drawGraph.call(this);\n      },\n      applyJitter: function applyJitter() {\n        var a = this,\n            f = this.options.jitter,\n            n = this.points.length;\n        f && this.points.forEach(function (C, y) {\n          [\"x\", \"y\"].forEach(function (v, D) {\n            var q = \"plot\" + v.toUpperCase();\n\n            if (f[v] && !C.isNull) {\n              var H = a[v + \"Axis\"];\n              var E = f[v] * H.transA;\n\n              if (H && !H.isLog) {\n                var p = Math.max(0, C[q] - E);\n                H = Math.min(H.len, C[q] + E);\n                D = 1E4 * Math.sin(y + D * n);\n                C[q] = p + (H - p) * (D - Math.floor(D));\n                \"x\" === v && (C.clientX = C.plotX);\n              }\n            }\n          });\n        });\n      }\n    });\n    n(y, \"afterTranslate\", function () {\n      this.applyJitter && this.applyJitter();\n    });\n    \"\";\n  });\n  O(n, \"Mixins/CenteredSeries.js\", [n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = a.isNumber,\n        y = a.pick,\n        D = a.relativeLength,\n        G = f.deg2rad;\n    return f.CenteredSeriesMixin = {\n      getCenter: function getCenter() {\n        var a = this.options,\n            n = this.chart,\n            H = 2 * (a.slicedOffset || 0),\n            v = n.plotWidth - 2 * H,\n            G = n.plotHeight - 2 * H,\n            q = a.center,\n            K = Math.min(v, G),\n            E = a.size,\n            p = a.innerSize || 0;\n        \"string\" === typeof E && (E = parseFloat(E));\n        \"string\" === typeof p && (p = parseFloat(p));\n        a = [y(q[0], \"50%\"), y(q[1], \"50%\"), y(E && 0 > E ? void 0 : a.size, \"100%\"), y(p && 0 > p ? void 0 : a.innerSize || 0, \"0%\")];\n        !n.angular || this instanceof f.Series || (a[3] = 0);\n\n        for (q = 0; 4 > q; ++q) {\n          E = a[q], n = 2 > q || 2 === q && /%$/.test(E), a[q] = D(E, [v, G, K, a[2]][q]) + (n ? H : 0);\n        }\n\n        a[3] > a[2] && (a[3] = a[2]);\n        return a;\n      },\n      getStartAndEndRadians: function getStartAndEndRadians(a, f) {\n        a = n(a) ? a : 0;\n        f = n(f) && f > a && 360 > f - a ? f : a + 360;\n        return {\n          start: G * (a + -90),\n          end: G * (f + -90)\n        };\n      }\n    };\n  });\n  O(n, \"Series/PieSeries.js\", [n[\"Core/Globals.js\"], n[\"Core/Renderer/SVG/SVGRenderer.js\"], n[\"Mixins/LegendSymbol.js\"], n[\"Core/Series/Point.js\"], n[\"Core/Utilities.js\"], n[\"Mixins/CenteredSeries.js\"]], function (f, a, n, y, D, G) {\n    var C = D.addEvent,\n        J = D.clamp,\n        H = D.defined,\n        v = D.fireEvent,\n        L = D.isNumber,\n        q = D.merge,\n        K = D.pick,\n        E = D.relativeLength,\n        p = D.seriesType,\n        t = D.setAnimation,\n        I = G.getStartAndEndRadians;\n    D = f.noop;\n    var u = f.Series;\n    p(\"pie\", \"line\", {\n      center: [null, null],\n      clip: !1,\n      colorByPoint: !0,\n      dataLabels: {\n        allowOverlap: !0,\n        connectorPadding: 5,\n        connectorShape: \"fixedOffset\",\n        crookDistance: \"70%\",\n        distance: 30,\n        enabled: !0,\n        formatter: function formatter() {\n          return this.point.isNull ? void 0 : this.point.name;\n        },\n        softConnector: !0,\n        x: 0\n      },\n      fillColor: void 0,\n      ignoreHiddenPoint: !0,\n      inactiveOtherPoints: !0,\n      legendType: \"point\",\n      marker: null,\n      size: null,\n      showInLegend: !1,\n      slicedOffset: 10,\n      stickyTracking: !1,\n      tooltip: {\n        followPointer: !0\n      },\n      borderColor: \"#ffffff\",\n      borderWidth: 1,\n      lineWidth: void 0,\n      states: {\n        hover: {\n          brightness: .1\n        }\n      }\n    }, {\n      isCartesian: !1,\n      requireSorting: !1,\n      directTouch: !0,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"],\n      axisTypes: [],\n      pointAttribs: f.seriesTypes.column.prototype.pointAttribs,\n      animate: function animate(a) {\n        var f = this,\n            l = f.points,\n            k = f.startAngleRad;\n        a || l.forEach(function (a) {\n          var d = a.graphic,\n              g = a.shapeArgs;\n          d && g && (d.attr({\n            r: K(a.startR, f.center && f.center[3] / 2),\n            start: k,\n            end: k\n          }), d.animate({\n            r: g.r,\n            start: g.start,\n            end: g.end\n          }, f.options.animation));\n        });\n      },\n      hasData: function hasData() {\n        return !!this.processedXData.length;\n      },\n      updateTotals: function updateTotals() {\n        var a,\n            f = 0,\n            l = this.points,\n            k = l.length,\n            g = this.options.ignoreHiddenPoint;\n\n        for (a = 0; a < k; a++) {\n          var d = l[a];\n          f += g && !d.visible ? 0 : d.isNull ? 0 : d.y;\n        }\n\n        this.total = f;\n\n        for (a = 0; a < k; a++) {\n          d = l[a], d.percentage = 0 < f && (d.visible || !g) ? d.y / f * 100 : 0, d.total = f;\n        }\n      },\n      generatePoints: function generatePoints() {\n        u.prototype.generatePoints.call(this);\n        this.updateTotals();\n      },\n      getX: function getX(a, f, l) {\n        var h = this.center,\n            g = this.radii ? this.radii[l.index] : h[2] / 2;\n        a = Math.asin(J((a - h[1]) / (g + l.labelDistance), -1, 1));\n        return h[0] + (f ? -1 : 1) * Math.cos(a) * (g + l.labelDistance) + (0 < l.labelDistance ? (f ? -1 : 1) * this.options.dataLabels.padding : 0);\n      },\n      translate: function translate(a) {\n        this.generatePoints();\n        var f = 0,\n            l = this.options,\n            k = l.slicedOffset,\n            g = k + (l.borderWidth || 0),\n            d = I(l.startAngle, l.endAngle),\n            m = this.startAngleRad = d.start;\n        d = (this.endAngleRad = d.end) - m;\n        var n = this.points,\n            p = l.dataLabels.distance;\n        l = l.ignoreHiddenPoint;\n        var q,\n            t = n.length;\n        a || (this.center = a = this.getCenter());\n\n        for (q = 0; q < t; q++) {\n          var u = n[q];\n          var y = m + f * d;\n          if (!l || u.visible) f += u.percentage / 100;\n          var F = m + f * d;\n          u.shapeType = \"arc\";\n          u.shapeArgs = {\n            x: a[0],\n            y: a[1],\n            r: a[2] / 2,\n            innerR: a[3] / 2,\n            start: Math.round(1E3 * y) / 1E3,\n            end: Math.round(1E3 * F) / 1E3\n          };\n          u.labelDistance = K(u.options.dataLabels && u.options.dataLabels.distance, p);\n          u.labelDistance = E(u.labelDistance, u.shapeArgs.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, u.labelDistance);\n          F = (F + y) / 2;\n          F > 1.5 * Math.PI ? F -= 2 * Math.PI : F < -Math.PI / 2 && (F += 2 * Math.PI);\n          u.slicedTranslation = {\n            translateX: Math.round(Math.cos(F) * k),\n            translateY: Math.round(Math.sin(F) * k)\n          };\n          var e = Math.cos(F) * a[2] / 2;\n          var c = Math.sin(F) * a[2] / 2;\n          u.tooltipPos = [a[0] + .7 * e, a[1] + .7 * c];\n          u.half = F < -Math.PI / 2 || F > Math.PI / 2 ? 1 : 0;\n          u.angle = F;\n          y = Math.min(g, u.labelDistance / 5);\n          u.labelPosition = {\n            natural: {\n              x: a[0] + e + Math.cos(F) * u.labelDistance,\n              y: a[1] + c + Math.sin(F) * u.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > u.labelDistance ? \"center\" : u.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: a[0] + e + Math.cos(F) * y,\n                y: a[1] + c + Math.sin(F) * y\n              },\n              touchingSliceAt: {\n                x: a[0] + e,\n                y: a[1] + c\n              }\n            }\n          };\n        }\n\n        v(this, \"afterTranslate\");\n      },\n      drawEmpty: function drawEmpty() {\n        var f = this.startAngleRad,\n            h = this.endAngleRad,\n            l = this.options;\n\n        if (0 === this.total && this.center) {\n          var k = this.center[0];\n          var g = this.center[1];\n          this.graph || (this.graph = this.chart.renderer.arc(k, g, this.center[1] / 2, 0, f, h).addClass(\"highcharts-empty-series\").add(this.group));\n          this.graph.attr({\n            d: a.prototype.symbols.arc(k, g, this.center[2] / 2, 0, {\n              start: f,\n              end: h,\n              innerR: this.center[3] / 2\n            })\n          });\n          this.chart.styledMode || this.graph.attr({\n            \"stroke-width\": l.borderWidth,\n            fill: l.fillColor || \"none\",\n            stroke: l.color || \"#cccccc\"\n          });\n        } else this.graph && (this.graph = this.graph.destroy());\n      },\n      redrawPoints: function redrawPoints() {\n        var a = this,\n            f = a.chart,\n            l = f.renderer,\n            k,\n            g,\n            d,\n            n,\n            p = a.options.shadow;\n        this.drawEmpty();\n        !p || a.shadowGroup || f.styledMode || (a.shadowGroup = l.g(\"shadow\").attr({\n          zIndex: -1\n        }).add(a.group));\n        a.points.forEach(function (h) {\n          var m = {};\n          g = h.graphic;\n\n          if (!h.isNull && g) {\n            n = h.shapeArgs;\n            k = h.getTranslate();\n\n            if (!f.styledMode) {\n              var r = h.shadowGroup;\n              p && !r && (r = h.shadowGroup = l.g(\"shadow\").add(a.shadowGroup));\n              r && r.attr(k);\n              d = a.pointAttribs(h, h.selected && \"select\");\n            }\n\n            h.delayedRendering ? (g.setRadialReference(a.center).attr(n).attr(k), f.styledMode || g.attr(d).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(p, r), h.delayedRendering = !1) : (g.setRadialReference(a.center), f.styledMode || q(!0, m, d), q(!0, m, n, k), g.animate(m));\n            g.attr({\n              visibility: h.visible ? \"inherit\" : \"hidden\"\n            });\n            g.addClass(h.getClassName());\n          } else g && (h.graphic = g.destroy());\n        });\n      },\n      drawPoints: function drawPoints() {\n        var a = this.chart.renderer;\n        this.points.forEach(function (f) {\n          f.graphic && f.hasNewShapeType() && (f.graphic = f.graphic.destroy());\n          f.graphic || (f.graphic = a[f.shapeType](f.shapeArgs).add(f.series.group), f.delayedRendering = !0);\n        });\n      },\n      searchPoint: D,\n      sortByAngle: function sortByAngle(a, f) {\n        a.sort(function (a, h) {\n          return \"undefined\" !== typeof a.angle && (h.angle - a.angle) * f;\n        });\n      },\n      drawLegendSymbol: n.drawRectangle,\n      getCenter: G.getCenter,\n      getSymbol: D,\n      drawGraph: null\n    }, {\n      init: function init() {\n        y.prototype.init.apply(this, arguments);\n        var a = this;\n        a.name = K(a.name, \"Slice\");\n\n        var f = function f(_f) {\n          a.slice(\"select\" === _f.type);\n        };\n\n        C(a, \"select\", f);\n        C(a, \"unselect\", f);\n        return a;\n      },\n      isValid: function isValid() {\n        return L(this.y) && 0 <= this.y;\n      },\n      setVisible: function setVisible(a, f) {\n        var h = this,\n            k = h.series,\n            g = k.chart,\n            d = k.options.ignoreHiddenPoint;\n        f = K(f, d);\n        a !== h.visible && (h.visible = h.options.visible = a = \"undefined\" === typeof a ? !h.visible : a, k.options.data[k.data.indexOf(h)] = h.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (d) {\n          if (h[d]) h[d][a ? \"show\" : \"hide\"](!0);\n        }), h.legendItem && g.legend.colorizeItem(h, a), a || \"hover\" !== h.state || h.setState(\"\"), d && (k.isDirty = !0), f && g.redraw());\n      },\n      slice: function slice(a, f, l) {\n        var h = this.series;\n        t(l, h.chart);\n        K(f, !0);\n        this.sliced = this.options.sliced = H(a) ? a : !this.sliced;\n        h.options.data[h.data.indexOf(this)] = this.options;\n        this.graphic && this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      },\n      getTranslate: function getTranslate() {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      },\n      haloPath: function haloPath(a) {\n        var f = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(f.x, f.y, f.r + a, f.r + a, {\n          innerR: f.r - 1,\n          start: f.start,\n          end: f.end\n        });\n      },\n      connectorShapes: {\n        fixedOffset: function fixedOffset(a, f, l) {\n          var h = f.breakAt;\n          f = f.touchingSliceAt;\n          return [[\"M\", a.x, a.y], l.softConnector ? [\"C\", a.x + (\"left\" === a.alignment ? -5 : 5), a.y, 2 * h.x - f.x, 2 * h.y - f.y, h.x, h.y] : [\"L\", h.x, h.y], [\"L\", f.x, f.y]];\n        },\n        straight: function straight(a, f) {\n          f = f.touchingSliceAt;\n          return [[\"M\", a.x, a.y], [\"L\", f.x, f.y]];\n        },\n        crookedLine: function crookedLine(a, f, l) {\n          f = f.touchingSliceAt;\n          var h = this.series,\n              g = h.center[0],\n              d = h.chart.plotWidth,\n              m = h.chart.plotLeft;\n          h = a.alignment;\n          var n = this.shapeArgs.r;\n          l = E(l.crookDistance, 1);\n          d = \"left\" === h ? g + n + (d + m - g - n) * (1 - l) : m + (g - n) * l;\n          l = [\"L\", d, a.y];\n          g = !0;\n          if (\"left\" === h ? d > a.x || d < f.x : d < a.x || d > f.x) g = !1;\n          a = [[\"M\", a.x, a.y]];\n          g && a.push(l);\n          a.push([\"L\", f.x, f.y]);\n          return a;\n        }\n      },\n      getConnectorPath: function getConnectorPath() {\n        var a = this.labelPosition,\n            f = this.series.options.dataLabels,\n            l = f.connectorShape,\n            k = this.connectorShapes;\n        k[l] && (l = k[l]);\n        return l.call(this, {\n          x: a.final.x,\n          y: a.final.y,\n          alignment: a.alignment\n        }, a.connectorPosition, f);\n      }\n    });\n    \"\";\n  });\n  O(n, \"Core/Series/DataLabels.js\", [n[\"Core/Globals.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = f.noop,\n        y = f.seriesTypes,\n        D = a.arrayMax,\n        G = a.clamp,\n        C = a.defined,\n        J = a.extend,\n        H = a.fireEvent,\n        v = a.format,\n        L = a.getDeferredAnimation,\n        q = a.isArray,\n        K = a.merge,\n        E = a.objectEach,\n        p = a.pick,\n        t = a.relativeLength,\n        I = a.splat,\n        u = a.stableSort,\n        m = f.Series;\n\n    f.distribute = function (a, l, k) {\n      function g(a, d) {\n        return a.target - d.target;\n      }\n\n      var d,\n          h = !0,\n          m = a,\n          n = [];\n      var q = 0;\n      var t = m.reducedLen || l;\n\n      for (d = a.length; d--;) {\n        q += a[d].size;\n      }\n\n      if (q > t) {\n        u(a, function (a, d) {\n          return (d.rank || 0) - (a.rank || 0);\n        });\n\n        for (q = d = 0; q <= t;) {\n          q += a[d].size, d++;\n        }\n\n        n = a.splice(d - 1, a.length);\n      }\n\n      u(a, g);\n\n      for (a = a.map(function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: p(a.align, .5)\n        };\n      }); h;) {\n        for (d = a.length; d--;) {\n          h = a[d], q = (Math.min.apply(0, h.targets) + Math.max.apply(0, h.targets)) / 2, h.pos = G(q - h.size * h.align, 0, l - h.size);\n        }\n\n        d = a.length;\n\n        for (h = !1; d--;) {\n          0 < d && a[d - 1].pos + a[d - 1].size > a[d].pos && (a[d - 1].size += a[d].size, a[d - 1].targets = a[d - 1].targets.concat(a[d].targets), a[d - 1].align = .5, a[d - 1].pos + a[d - 1].size > l && (a[d - 1].pos = l - a[d - 1].size), a.splice(d, 1), h = !0);\n        }\n      }\n\n      m.push.apply(m, n);\n      d = 0;\n      a.some(function (a) {\n        var g = 0;\n        if (a.targets.some(function () {\n          m[d].pos = a.pos + g;\n          if (\"undefined\" !== typeof k && Math.abs(m[d].pos - m[d].target) > k) return m.slice(0, d + 1).forEach(function (a) {\n            delete a.pos;\n          }), m.reducedLen = (m.reducedLen || l) - .1 * l, m.reducedLen > .1 * l && f.distribute(m, l, k), !0;\n          g += m[d].size;\n          d++;\n        })) return !0;\n      });\n      u(m, g);\n    };\n\n    m.prototype.drawDataLabels = function () {\n      function a(a, d) {\n        var c = d.filter;\n        return c ? (d = c.operator, a = a[c.property], c = c.value, \">\" === d && a > c || \"<\" === d && a < c || \">=\" === d && a >= c || \"<=\" === d && a <= c || \"==\" === d && a == c || \"===\" === d && a === c ? !0 : !1) : !0;\n      }\n\n      function f(a, d) {\n        var c = [],\n            b;\n        if (q(a) && !q(d)) c = a.map(function (a) {\n          return K(a, d);\n        });else if (q(d) && !q(a)) c = d.map(function (b) {\n          return K(a, b);\n        });else if (q(a) || q(d)) for (b = Math.max(a.length, d.length); b--;) {\n          c[b] = K(a[b], d[b]);\n        } else c = K(a, d);\n        return c;\n      }\n\n      var k = this,\n          g = k.chart,\n          d = k.options,\n          m = d.dataLabels,\n          n = k.points,\n          t,\n          u = k.hasRendered || 0,\n          B = m.animation;\n      B = m.defer ? L(g, B, k) : {\n        defer: 0,\n        duration: 0\n      };\n      var y = g.renderer;\n      m = f(f(g.options.plotOptions && g.options.plotOptions.series && g.options.plotOptions.series.dataLabels, g.options.plotOptions && g.options.plotOptions[k.type] && g.options.plotOptions[k.type].dataLabels), m);\n      H(this, \"drawDataLabels\");\n\n      if (q(m) || m.enabled || k._hasPointLabels) {\n        var D = k.plotGroup(\"dataLabelsGroup\", \"data-labels\", u ? \"inherit\" : \"hidden\", m.zIndex || 6);\n        D.attr({\n          opacity: +u\n        });\n        !u && (u = k.dataLabelsGroup) && (k.visible && D.show(!0), u[d.animation ? \"animate\" : \"attr\"]({\n          opacity: 1\n        }, B));\n        n.forEach(function (h) {\n          t = I(f(m, h.dlOptions || h.options && h.options.dataLabels));\n          t.forEach(function (e, c) {\n            var b = e.enabled && (!h.isNull || h.dataLabelOnNull) && a(h, e),\n                f = h.dataLabels ? h.dataLabels[c] : h.dataLabel,\n                l = h.connectors ? h.connectors[c] : h.connector,\n                m = p(e.distance, h.labelDistance),\n                n = !f;\n\n            if (b) {\n              var r = h.getLabelConfig();\n              var q = p(e[h.formatPrefix + \"Format\"], e.format);\n              r = C(q) ? v(q, r, g) : (e[h.formatPrefix + \"Formatter\"] || e.formatter).call(r, e);\n              q = e.style;\n              var t = e.rotation;\n              g.styledMode || (q.color = p(e.color, q.color, k.color, \"#000000\"), \"contrast\" === q.color ? (h.contrastColor = y.getContrast(h.color || k.color), q.color = !C(m) && e.inside || 0 > m || d.stacking ? h.contrastColor : \"#000000\") : delete h.contrastColor, d.cursor && (q.cursor = d.cursor));\n              var x = {\n                r: e.borderRadius || 0,\n                rotation: t,\n                padding: e.padding,\n                zIndex: 1\n              };\n              g.styledMode || (x.fill = e.backgroundColor, x.stroke = e.borderColor, x[\"stroke-width\"] = e.borderWidth);\n              E(x, function (a, b) {\n                \"undefined\" === typeof a && delete x[b];\n              });\n            }\n\n            !f || b && C(r) ? b && C(r) && (f ? x.text = r : (h.dataLabels = h.dataLabels || [], f = h.dataLabels[c] = t ? y.text(r, 0, -9999, e.useHTML).addClass(\"highcharts-data-label\") : y.label(r, 0, -9999, e.shape, null, null, e.useHTML, null, \"data-label\"), c || (h.dataLabel = f), f.addClass(\" highcharts-data-label-color-\" + h.colorIndex + \" \" + (e.className || \"\") + (e.useHTML ? \" highcharts-tracker\" : \"\"))), f.options = e, f.attr(x), g.styledMode || f.css(q).shadow(e.shadow), f.added || f.add(D), e.textPath && !e.useHTML && (f.setTextPath(h.getDataLabelPath && h.getDataLabelPath(f) || h.graphic, e.textPath), h.dataLabelPath && !e.textPath.enabled && (h.dataLabelPath = h.dataLabelPath.destroy())), k.alignDataLabel(h, f, e, null, n)) : (h.dataLabel = h.dataLabel && h.dataLabel.destroy(), h.dataLabels && (1 === h.dataLabels.length ? delete h.dataLabels : delete h.dataLabels[c]), c || delete h.dataLabel, l && (h.connector = h.connector.destroy(), h.connectors && (1 === h.connectors.length ? delete h.connectors : delete h.connectors[c])));\n          });\n        });\n      }\n\n      H(this, \"afterDrawDataLabels\");\n    };\n\n    m.prototype.alignDataLabel = function (a, f, k, g, d) {\n      var h = this,\n          l = this.chart,\n          m = this.isCartesian && l.inverted,\n          n = this.enabledDataSorting,\n          q = p(a.dlBox && a.dlBox.centerX, a.plotX, -9999),\n          t = p(a.plotY, -9999),\n          v = f.getBBox(),\n          u = k.rotation,\n          e = k.align,\n          c = l.isInsidePlot(q, Math.round(t), m),\n          b = \"justify\" === p(k.overflow, n ? \"none\" : \"justify\"),\n          z = this.visible && !1 !== a.visible && (a.series.forceDL || n && !b || c || k.inside && g && l.isInsidePlot(q, m ? g.x + 1 : g.y + g.height - 1, m));\n\n      var w = function w(e) {\n        n && h.xAxis && !b && h.setDataLabelStartPos(a, f, d, c, e);\n      };\n\n      if (z) {\n        var y = l.renderer.fontMetrics(l.styledMode ? void 0 : k.style.fontSize, f).b;\n        g = J({\n          x: m ? this.yAxis.len - t : q,\n          y: Math.round(m ? this.xAxis.len - q : t),\n          width: 0,\n          height: 0\n        }, g);\n        J(k, {\n          width: v.width,\n          height: v.height\n        });\n        u ? (b = !1, q = l.renderer.rotCorr(y, u), q = {\n          x: g.x + (k.x || 0) + g.width / 2 + q.x,\n          y: g.y + (k.y || 0) + {\n            top: 0,\n            middle: .5,\n            bottom: 1\n          }[k.verticalAlign] * g.height\n        }, w(q), f[d ? \"attr\" : \"animate\"](q).attr({\n          align: e\n        }), w = (u + 720) % 360, w = 180 < w && 360 > w, \"left\" === e ? q.y -= w ? v.height : 0 : \"center\" === e ? (q.x -= v.width / 2, q.y -= v.height / 2) : \"right\" === e && (q.x -= v.width, q.y -= w ? 0 : v.height), f.placed = !0, f.alignAttr = q) : (w(g), f.align(k, null, g), q = f.alignAttr);\n        b && 0 <= g.height ? this.justifyDataLabel(f, k, q, v, g, d) : p(k.crop, !0) && (z = l.isInsidePlot(q.x, q.y) && l.isInsidePlot(q.x + v.width, q.y + v.height));\n        if (k.shape && !u) f[d ? \"attr\" : \"animate\"]({\n          anchorX: m ? l.plotWidth - a.plotY : a.plotX,\n          anchorY: m ? l.plotHeight - a.plotX : a.plotY\n        });\n      }\n\n      d && n && (f.placed = !1);\n      z || n && !b || (f.hide(!0), f.placed = !1);\n    };\n\n    m.prototype.setDataLabelStartPos = function (a, f, k, g, d) {\n      var h = this.chart,\n          l = h.inverted,\n          m = this.xAxis,\n          n = m.reversed,\n          p = l ? f.height / 2 : f.width / 2;\n      a = (a = a.pointWidth) ? a / 2 : 0;\n      m = l ? d.x : n ? -p - a : m.width - p + a;\n      d = l ? n ? this.yAxis.height - p + a : -p - a : d.y;\n      f.startXPos = m;\n      f.startYPos = d;\n      g ? \"hidden\" === f.visibility && (f.show(), f.attr({\n        opacity: 0\n      }).animate({\n        opacity: 1\n      })) : f.attr({\n        opacity: 1\n      }).animate({\n        opacity: 0\n      }, void 0, f.hide);\n      h.hasRendered && (k && f.attr({\n        x: f.startXPos,\n        y: f.startYPos\n      }), f.placed = !0);\n    };\n\n    m.prototype.justifyDataLabel = function (a, f, k, g, d, m) {\n      var h = this.chart,\n          l = f.align,\n          n = f.verticalAlign,\n          p = a.box ? 0 : a.padding || 0,\n          q = f.x;\n      q = void 0 === q ? 0 : q;\n      var t = f.y;\n      var x = void 0 === t ? 0 : t;\n      t = k.x + p;\n\n      if (0 > t) {\n        \"right\" === l && 0 <= q ? (f.align = \"left\", f.inside = !0) : q -= t;\n        var e = !0;\n      }\n\n      t = k.x + g.width - p;\n      t > h.plotWidth && (\"left\" === l && 0 >= q ? (f.align = \"right\", f.inside = !0) : q += h.plotWidth - t, e = !0);\n      t = k.y + p;\n      0 > t && (\"bottom\" === n && 0 <= x ? (f.verticalAlign = \"top\", f.inside = !0) : x -= t, e = !0);\n      t = k.y + g.height - p;\n      t > h.plotHeight && (\"top\" === n && 0 >= x ? (f.verticalAlign = \"bottom\", f.inside = !0) : x += h.plotHeight - t, e = !0);\n      e && (f.x = q, f.y = x, a.placed = !m, a.align(f, void 0, d));\n      return e;\n    };\n\n    y.pie && (y.pie.prototype.dataLabelPositioners = {\n      radialDistributionY: function radialDistributionY(a) {\n        return a.top + a.distributeBox.pos;\n      },\n      radialDistributionX: function radialDistributionX(a, f, k, g) {\n        return a.getX(k < f.top + 2 || k > f.bottom - 2 ? g : k, f.half, f);\n      },\n      justify: function justify(a, f, k) {\n        return k[0] + (a.half ? -1 : 1) * (f + a.labelDistance);\n      },\n      alignToPlotEdges: function alignToPlotEdges(a, f, k, g) {\n        a = a.getBBox().width;\n        return f ? a + g : k - a - g;\n      },\n      alignToConnectors: function alignToConnectors(a, f, k, g) {\n        var d = 0,\n            h;\n        a.forEach(function (a) {\n          h = a.dataLabel.getBBox().width;\n          h > d && (d = h);\n        });\n        return f ? d + g : k - d - g;\n      }\n    }, y.pie.prototype.drawDataLabels = function () {\n      var a = this,\n          l = a.data,\n          k,\n          g = a.chart,\n          d = a.options.dataLabels || {},\n          n = d.connectorPadding,\n          r,\n          q = g.plotWidth,\n          t = g.plotHeight,\n          v = g.plotLeft,\n          u = Math.round(g.chartWidth / 3),\n          y,\n          F = a.center,\n          e = F[2] / 2,\n          c = F[1],\n          b,\n          z,\n          w,\n          E,\n          H = [[], []],\n          G,\n          I,\n          J,\n          L,\n          O = [0, 0, 0, 0],\n          S = a.dataLabelPositioners,\n          V;\n      a.visible && (d.enabled || a._hasPointLabels) && (l.forEach(function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), m.prototype.drawDataLabels.apply(a), l.forEach(function (a) {\n        a.dataLabel && (a.visible ? (H[a.half].push(a), a.dataLabel._pos = null, !C(d.style.width) && !C(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > u && (a.dataLabel.css({\n          width: Math.round(.7 * u) + \"px\"\n        }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n      }), H.forEach(function (h, l) {\n        var m = h.length,\n            r = [],\n            x;\n\n        if (m) {\n          a.sortByAngle(h, l - .5);\n\n          if (0 < a.maxLabelDistance) {\n            var u = Math.max(0, c - e - a.maxLabelDistance);\n            var A = Math.min(c + e + a.maxLabelDistance, g.plotHeight);\n            h.forEach(function (a) {\n              0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, c - e - a.labelDistance), a.bottom = Math.min(c + e + a.labelDistance, g.plotHeight), x = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n                target: a.labelPosition.natural.y - a.top + x / 2,\n                size: x,\n                rank: a.y\n              }, r.push(a.distributeBox));\n            });\n            u = A + x - u;\n            f.distribute(r, u, u / 5);\n          }\n\n          for (L = 0; L < m; L++) {\n            k = h[L];\n            w = k.labelPosition;\n            b = k.dataLabel;\n            J = !1 === k.visible ? \"hidden\" : \"inherit\";\n            I = u = w.natural.y;\n            r && C(k.distributeBox) && (\"undefined\" === typeof k.distributeBox.pos ? J = \"hidden\" : (E = k.distributeBox.size, I = S.radialDistributionY(k)));\n            delete k.positionIndex;\n            if (d.justify) G = S.justify(k, e, F);else switch (d.alignTo) {\n              case \"connectors\":\n                G = S.alignToConnectors(h, l, q, v);\n                break;\n\n              case \"plotEdges\":\n                G = S.alignToPlotEdges(b, l, q, v);\n                break;\n\n              default:\n                G = S.radialDistributionX(a, k, I, u);\n            }\n            b._attr = {\n              visibility: J,\n              align: w.alignment\n            };\n            V = k.options.dataLabels || {};\n            b._pos = {\n              x: G + p(V.x, d.x) + ({\n                left: n,\n                right: -n\n              }[w.alignment] || 0),\n              y: I + p(V.y, d.y) - 10\n            };\n            w.final.x = G;\n            w.final.y = I;\n            p(d.crop, !0) && (z = b.getBBox().width, u = null, G - z < n && 1 === l ? (u = Math.round(z - G + n), O[3] = Math.max(u, O[3])) : G + z > q - n && 0 === l && (u = Math.round(G + z - q + n), O[1] = Math.max(u, O[1])), 0 > I - E / 2 ? O[0] = Math.max(Math.round(-I + E / 2), O[0]) : I + E / 2 > t && (O[2] = Math.max(Math.round(I + E / 2 - t), O[2])), b.sideOverflow = u);\n          }\n        }\n      }), 0 === D(O) || this.verifyDataLabelOverflow(O)) && (this.placeDataLabels(), this.points.forEach(function (c) {\n        V = K(d, c.options.dataLabels);\n\n        if (r = p(V.connectorWidth, 1)) {\n          var e;\n          y = c.connector;\n\n          if ((b = c.dataLabel) && b._pos && c.visible && 0 < c.labelDistance) {\n            J = b._attr.visibility;\n            if (e = !y) c.connector = y = g.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + c.colorIndex + (c.className ? \" \" + c.className : \"\")).add(a.dataLabelsGroup), g.styledMode || y.attr({\n              \"stroke-width\": r,\n              stroke: V.connectorColor || c.color || \"#666666\"\n            });\n            y[e ? \"attr\" : \"animate\"]({\n              d: c.getConnectorPath()\n            });\n            y.attr(\"visibility\", J);\n          } else y && (c.connector = y.destroy());\n        }\n      }));\n    }, y.pie.prototype.placeDataLabels = function () {\n      this.points.forEach(function (a) {\n        var f = a.dataLabel,\n            h;\n        f && a.visible && ((h = f._pos) ? (f.sideOverflow && (f._attr.width = Math.max(f.getBBox().width - f.sideOverflow, 0), f.css({\n          width: f._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), f.shortened = !0), f.attr(f._attr), f[f.moved ? \"animate\" : \"attr\"](h), f.moved = !0) : f && f.attr({\n          y: -9999\n        }));\n        delete a.distributeBox;\n      }, this);\n    }, y.pie.prototype.alignDataLabel = n, y.pie.prototype.verifyDataLabelOverflow = function (a) {\n      var f = this.center,\n          h = this.options,\n          g = h.center,\n          d = h.minSize || 80,\n          m = null !== h.size;\n\n      if (!m) {\n        if (null !== g[0]) var n = Math.max(f[2] - Math.max(a[1], a[3]), d);else n = Math.max(f[2] - a[1] - a[3], d), f[0] += (a[3] - a[1]) / 2;\n        null !== g[1] ? n = G(n, d, f[2] - Math.max(a[0], a[2])) : (n = G(n, d, f[2] - a[0] - a[2]), f[1] += (a[0] - a[2]) / 2);\n        n < f[2] ? (f[2] = n, f[3] = Math.min(t(h.innerSize || 0, n), n), this.translate(f), this.drawDataLabels && this.drawDataLabels()) : m = !0;\n      }\n\n      return m;\n    });\n    y.column && (y.column.prototype.alignDataLabel = function (a, f, k, g, d) {\n      var h = this.chart.inverted,\n          l = a.series,\n          n = a.dlBox || a.shapeArgs,\n          q = p(a.below, a.plotY > p(this.translatedThreshold, l.yAxis.len)),\n          t = p(k.inside, !!this.options.stacking);\n      n && (g = K(n), 0 > g.y && (g.height += g.y, g.y = 0), n = g.y + g.height - l.yAxis.len, 0 < n && n < g.height && (g.height -= n), h && (g = {\n        x: l.yAxis.len - g.y - g.height,\n        y: l.xAxis.len - g.x - g.width,\n        width: g.height,\n        height: g.width\n      }), t || (h ? (g.x += q ? 0 : g.width, g.width = 0) : (g.y += q ? g.height : 0, g.height = 0)));\n      k.align = p(k.align, !h || t ? \"center\" : q ? \"right\" : \"left\");\n      k.verticalAlign = p(k.verticalAlign, h || t ? \"middle\" : q ? \"top\" : \"bottom\");\n      m.prototype.alignDataLabel.call(this, a, f, k, g, d);\n      k.inside && a.contrastColor && f.css({\n        color: a.contrastColor\n      });\n    });\n  });\n  O(n, \"Extensions/OverlappingDataLabels.js\", [n[\"Core/Chart/Chart.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = a.addEvent,\n        y = a.fireEvent,\n        D = a.isArray,\n        G = a.isNumber,\n        C = a.objectEach,\n        J = a.pick;\n    n(f, \"render\", function () {\n      var a = [];\n      (this.labelCollectors || []).forEach(function (f) {\n        a = a.concat(f());\n      });\n      (this.yAxis || []).forEach(function (f) {\n        f.stacking && f.options.stackLabels && !f.options.stackLabels.allowOverlap && C(f.stacking.stacks, function (f) {\n          C(f, function (f) {\n            a.push(f.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (f) {\n        var n = f.options.dataLabels;\n        f.visible && (!1 !== n.enabled || f._hasPointLabels) && (f.nodes || f.points).forEach(function (f) {\n          f.visible && (D(f.dataLabels) ? f.dataLabels : f.dataLabel ? [f.dataLabel] : []).forEach(function (n) {\n            var q = n.options;\n            n.labelrank = J(q.labelrank, f.labelrank, f.shapeArgs && f.shapeArgs.height);\n            q.allowOverlap || a.push(n);\n          });\n        });\n      });\n      this.hideOverlappingLabels(a);\n    });\n\n    f.prototype.hideOverlappingLabels = function (a) {\n      var f = this,\n          n = a.length,\n          q = f.renderer,\n          C,\n          E,\n          p,\n          t = !1;\n\n      var D = function D(a) {\n        var f,\n            h = a.box ? 0 : a.padding || 0,\n            g = f = 0,\n            d;\n\n        if (a && (!a.alignAttr || a.placed)) {\n          var m = a.alignAttr || {\n            x: a.attr(\"x\"),\n            y: a.attr(\"y\")\n          };\n          var n = a.parentGroup;\n          a.width || (f = a.getBBox(), a.width = f.width, a.height = f.height, f = q.fontMetrics(null, a.element).h);\n          var p = a.width - 2 * h;\n          (d = {\n            left: \"0\",\n            center: \"0.5\",\n            right: \"1\"\n          }[a.alignValue]) ? g = +d * p : G(a.x) && Math.round(a.x) !== a.translateX && (g = a.x - a.translateX);\n          return {\n            x: m.x + (n.translateX || 0) + h - (g || 0),\n            y: m.y + (n.translateY || 0) + h - f,\n            width: a.width - 2 * h,\n            height: a.height - 2 * h\n          };\n        }\n      };\n\n      for (E = 0; E < n; E++) {\n        if (C = a[E]) C.oldOpacity = C.opacity, C.newOpacity = 1, C.absoluteBox = D(C);\n      }\n\n      a.sort(function (a, f) {\n        return (f.labelrank || 0) - (a.labelrank || 0);\n      });\n\n      for (E = 0; E < n; E++) {\n        var u = (D = a[E]) && D.absoluteBox;\n\n        for (C = E + 1; C < n; ++C) {\n          var m = (p = a[C]) && p.absoluteBox;\n          !u || !m || D === p || 0 === D.newOpacity || 0 === p.newOpacity || m.x >= u.x + u.width || m.x + m.width <= u.x || m.y >= u.y + u.height || m.y + m.height <= u.y || ((D.labelrank < p.labelrank ? D : p).newOpacity = 0);\n        }\n      }\n\n      a.forEach(function (a) {\n        if (a) {\n          var h = a.newOpacity;\n          a.oldOpacity !== h && (a.alignAttr && a.placed ? (a[h ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), t = !0, a.alignAttr.opacity = h, a[a.isOld ? \"animate\" : \"attr\"](a.alignAttr, null, function () {\n            f.styledMode || a.css({\n              pointerEvents: h ? \"auto\" : \"none\"\n            });\n            a.visibility = h ? \"inherit\" : \"hidden\";\n          }), y(f, \"afterHideOverlappingLabel\")) : a.attr({\n            opacity: h\n          }));\n          a.isOld = !0;\n        }\n      });\n      t && y(f, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  O(n, \"Core/Interaction.js\", [n[\"Core/Chart/Chart.js\"], n[\"Core/Globals.js\"], n[\"Core/Legend.js\"], n[\"Core/Options.js\"], n[\"Core/Series/Point.js\"], n[\"Core/Utilities.js\"]], function (f, a, n, y, D, G) {\n    var C = y.defaultOptions,\n        J = G.addEvent,\n        H = G.createElement,\n        v = G.css,\n        L = G.defined,\n        q = G.extend,\n        K = G.fireEvent,\n        E = G.isArray,\n        p = G.isFunction,\n        t = G.isNumber,\n        I = G.isObject,\n        u = G.merge,\n        m = G.objectEach,\n        h = G.pick,\n        l = a.hasTouch;\n    y = a.Series;\n    G = a.seriesTypes;\n    var k = a.svg;\n    var g = a.TrackerMixin = {\n      drawTrackerPoint: function drawTrackerPoint() {\n        var a = this,\n            f = a.chart,\n            g = f.pointer,\n            h = function h(a) {\n          var d = g.getPointFromEvent(a);\n          \"undefined\" !== typeof d && (g.isDirectTouch = !0, d.onMouseOver(a));\n        },\n            k;\n\n        a.points.forEach(function (a) {\n          k = E(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          k.forEach(function (d) {\n            d.div ? d.div.point = a : d.element.point = a;\n          });\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (d) {\n          if (a[d]) {\n            a[d].addClass(\"highcharts-tracker\").on(\"mouseover\", h).on(\"mouseout\", function (a) {\n              g.onTrackerMouseOut(a);\n            });\n            if (l) a[d].on(\"touchstart\", h);\n            !f.styledMode && a.options.cursor && a[d].css(v).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        K(this, \"afterDrawTracker\");\n      },\n      drawTrackerGraph: function drawTrackerGraph() {\n        var a = this,\n            f = a.options,\n            g = f.trackByArea,\n            h = [].concat(g ? a.areaPath : a.graphPath),\n            m = a.chart,\n            n = m.pointer,\n            p = m.renderer,\n            q = m.options.tooltip.snap,\n            t = a.tracker,\n            e = function e(b) {\n          if (m.hoverSeries !== a) a.onMouseOver();\n        },\n            c = \"rgba(192,192,192,\" + (k ? .0001 : .002) + \")\";\n\n        t ? t.attr({\n          d: h\n        }) : a.graph && (a.tracker = p.path(h).attr({\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(g ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), m.styledMode || a.tracker.attr({\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          stroke: c,\n          fill: g ? c : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (g ? 0 : 2 * q)\n        }), [a.tracker, a.markerGroup].forEach(function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", e).on(\"mouseout\", function (a) {\n            n.onTrackerMouseOut(a);\n          });\n          f.cursor && !m.styledMode && a.css({\n            cursor: f.cursor\n          });\n          if (l) a.on(\"touchstart\", e);\n        }));\n        K(this, \"afterDrawTracker\");\n      }\n    };\n    G.column && (G.column.prototype.drawTracker = g.drawTrackerPoint);\n    G.pie && (G.pie.prototype.drawTracker = g.drawTrackerPoint);\n    G.scatter && (G.scatter.prototype.drawTracker = g.drawTrackerPoint);\n    q(n.prototype, {\n      setItemEvents: function setItemEvents(a, f, g) {\n        var d = this,\n            h = d.chart.renderer.boxWrapper,\n            k = a instanceof D,\n            l = \"highcharts-legend-\" + (k ? \"point\" : \"series\") + \"-active\",\n            m = d.chart.styledMode;\n        (g ? [f, a.legendSymbol] : [a.legendGroup]).forEach(function (g) {\n          if (g) g.on(\"mouseover\", function () {\n            a.visible && d.allItems.forEach(function (d) {\n              a !== d && d.setState(\"inactive\", !k);\n            });\n            a.setState(\"hover\");\n            a.visible && h.addClass(l);\n            m || f.css(d.options.itemHoverStyle);\n          }).on(\"mouseout\", function () {\n            d.chart.styledMode || f.css(u(a.visible ? d.itemStyle : d.itemHiddenStyle));\n            d.allItems.forEach(function (d) {\n              a !== d && d.setState(\"\", !k);\n            });\n            h.removeClass(l);\n            a.setState();\n          }).on(\"click\", function (e) {\n            var c = function c() {\n              a.setVisible && a.setVisible();\n              d.allItems.forEach(function (b) {\n                a !== b && b.setState(a.visible ? \"inactive\" : \"\", !k);\n              });\n            };\n\n            h.removeClass(l);\n            e = {\n              browserEvent: e\n            };\n            a.firePointEvent ? a.firePointEvent(\"legendItemClick\", e, c) : K(a, \"legendItemClick\", e, c);\n          });\n        });\n      },\n      createCheckboxForItem: function createCheckboxForItem(a) {\n        a.checkbox = H(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        J(a.checkbox, \"click\", function (d) {\n          K(a.series || a, \"checkboxClick\", {\n            checked: d.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      }\n    });\n    q(f.prototype, {\n      showResetZoom: function showResetZoom() {\n        function a() {\n          f.zoomOut();\n        }\n\n        var f = this,\n            g = C.lang,\n            h = f.options.chart.resetZoomButton,\n            k = h.theme,\n            l = k.states,\n            m = \"chart\" === h.relativeTo || \"spaceBox\" === h.relativeTo ? null : \"plotBox\";\n        K(this, \"beforeShowResetZoom\", null, function () {\n          f.resetZoomButton = f.renderer.button(g.resetZoom, null, null, a, k, l && l.hover).attr({\n            align: h.position.align,\n            title: g.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(h.position, !1, m);\n        });\n        K(this, \"afterShowResetZoom\");\n      },\n      zoomOut: function zoomOut() {\n        K(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      },\n      zoom: function zoom(a) {\n        var d = this,\n            f,\n            g = d.pointer,\n            k = !1,\n            l = d.inverted ? g.mouseDownX : g.mouseDownY;\n        !a || a.resetSelection ? (d.axes.forEach(function (a) {\n          f = a.zoom();\n        }), g.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {\n          var h = a.axis,\n              e = d.inverted ? h.left : h.top,\n              c = d.inverted ? e + h.width : e + h.height,\n              b = h.isXAxis,\n              m = !1;\n          if (!b && l >= e && l <= c || b || !L(l)) m = !0;\n          g[b ? \"zoomX\" : \"zoomY\"] && m && (f = h.zoom(a.min, a.max), h.displayBtn && (k = !0));\n        });\n        var m = d.resetZoomButton;\n        k && !m ? d.showResetZoom() : !k && I(m) && (d.resetZoomButton = m.destroy());\n        f && d.redraw(h(d.options.chart.animation, a && a.animation, 100 > d.pointCount));\n      },\n      pan: function pan(d, f) {\n        var g = this,\n            h = g.hoverPoints,\n            k = g.options.chart,\n            l = g.options.mapNavigation && g.options.mapNavigation.enabled,\n            m;\n        f = \"object\" === typeof f ? f : {\n          enabled: f,\n          type: \"x\"\n        };\n        k && k.panning && (k.panning = f);\n        var n = f.type;\n        K(this, \"pan\", {\n          originalEvent: d\n        }, function () {\n          h && h.forEach(function (a) {\n            a.setState();\n          });\n          var f = [1];\n          \"xy\" === n ? f = [1, 0] : \"y\" === n && (f = [0]);\n          f.forEach(function (e) {\n            var c = g[e ? \"xAxis\" : \"yAxis\"][0],\n                b = c.horiz,\n                f = d[b ? \"chartX\" : \"chartY\"];\n            b = b ? \"mouseDownX\" : \"mouseDownY\";\n            var h = g[b],\n                k = (c.pointRange || 0) / 2,\n                p = c.reversed && !g.inverted || !c.reversed && g.inverted ? -1 : 1,\n                q = c.getExtremes(),\n                r = c.toValue(h - f, !0) + k * p;\n            p = c.toValue(h + c.len - f, !0) - k * p;\n            var u = p < r;\n            h = u ? p : r;\n            r = u ? r : p;\n            var v = c.hasVerticalPanning(),\n                x = c.panningState;\n            c.series.forEach(function (a) {\n              if (v && !e && (!x || x.isDirty)) {\n                var b = a.getProcessedData(!0);\n                a = a.getExtremes(b.yData, !0);\n                x || (x = {\n                  startMin: Number.MAX_VALUE,\n                  startMax: -Number.MAX_VALUE\n                });\n                t(a.dataMin) && t(a.dataMax) && (x.startMin = Math.min(a.dataMin, x.startMin), x.startMax = Math.max(a.dataMax, x.startMax));\n              }\n            });\n            p = Math.min(a.pick(null === x || void 0 === x ? void 0 : x.startMin, q.dataMin), k ? q.min : c.toValue(c.toPixels(q.min) - c.minPixelPadding));\n            k = Math.max(a.pick(null === x || void 0 === x ? void 0 : x.startMax, q.dataMax), k ? q.max : c.toValue(c.toPixels(q.max) + c.minPixelPadding));\n            c.panningState = x;\n            c.isOrdinal || (u = p - h, 0 < u && (r += u, h = p), u = r - k, 0 < u && (r = k, h -= u), c.series.length && h !== q.min && r !== q.max && h >= p && r <= k && (c.setExtremes(h, r, !1, !1, {\n              trigger: \"pan\"\n            }), g.resetZoomButton || l || h === p || r === k || !n.match(\"y\") || (g.showResetZoom(), c.displayBtn = !1), m = !0), g[b] = f);\n          });\n          m && g.redraw(!1);\n          v(g.container, {\n            cursor: \"move\"\n          });\n        });\n      }\n    });\n    q(D.prototype, {\n      select: function select(a, f) {\n        var d = this,\n            g = d.series,\n            k = g.chart;\n        this.selectedStaging = a = h(a, !d.selected);\n        d.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: f\n        }, function () {\n          d.selected = d.options.selected = a;\n          g.options.data[g.data.indexOf(d)] = d.options;\n          d.setState(a && \"select\");\n          f || k.getSelectedPoints().forEach(function (a) {\n            var f = a.series;\n            a.selected && a !== d && (a.selected = a.options.selected = !1, f.options.data[f.data.indexOf(a)] = a.options, a.setState(k.hoverPoints && f.options.inactiveOtherPoints ? \"inactive\" : \"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      },\n      onMouseOver: function onMouseOver(a) {\n        var d = this.series.chart,\n            f = d.pointer;\n        a = a ? f.normalize(a) : f.getChartCoordinatesFromPoint(this, d.inverted);\n        f.runPointActions(a, this);\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      },\n      importEvents: function importEvents() {\n        if (!this.hasImportedEvents) {\n          var a = this,\n              f = u(a.series.options.point, a.options).events;\n          a.events = f;\n          m(f, function (d, f) {\n            p(d) && J(a, f, d);\n          });\n          this.hasImportedEvents = !0;\n        }\n      },\n      setState: function setState(a, f) {\n        var d = this.series,\n            g = this.state,\n            k = d.options.states[a || \"normal\"] || {},\n            l = C.plotOptions[d.type].marker && d.options.marker,\n            m = l && !1 === l.enabled,\n            n = l && l.states && l.states[a || \"normal\"] || {},\n            p = !1 === n.enabled,\n            e = d.stateMarkerGraphic,\n            c = this.marker || {},\n            b = d.chart,\n            t = d.halo,\n            u,\n            v = l && d.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !f || this.selected && \"select\" !== a || !1 === k.enabled || a && (p || m && !1 === n.enabled) || a && c.states && c.states[a] && !1 === c.states[a].enabled)) {\n          this.state = a;\n          v && (u = d.markerAttribs(this, a));\n\n          if (this.graphic) {\n            g && this.graphic.removeClass(\"highcharts-point-\" + g);\n            a && this.graphic.addClass(\"highcharts-point-\" + a);\n\n            if (!b.styledMode) {\n              var x = d.pointAttribs(this, a);\n              var y = h(b.options.chart.animation, k.animation);\n              d.options.inactiveOtherPoints && x.opacity && ((this.dataLabels || []).forEach(function (a) {\n                a && a.animate({\n                  opacity: x.opacity\n                }, y);\n              }), this.connector && this.connector.animate({\n                opacity: x.opacity\n              }, y));\n              this.graphic.animate(x, y);\n            }\n\n            u && this.graphic.animate(u, h(b.options.chart.animation, n.animation, l.animation));\n            e && e.hide();\n          } else {\n            if (a && n) {\n              g = c.symbol || d.symbol;\n              e && e.currentSymbol !== g && (e = e.destroy());\n              if (u) if (e) e[f ? \"animate\" : \"attr\"]({\n                x: u.x,\n                y: u.y\n              });else g && (d.stateMarkerGraphic = e = b.renderer.symbol(g, u.x, u.y, u.width, u.height).add(d.markerGroup), e.currentSymbol = g);\n              !b.styledMode && e && e.attr(d.pointAttribs(this, a));\n            }\n\n            e && (e[a && this.isInside ? \"show\" : \"hide\"](), e.element.point = this);\n          }\n\n          a = k.halo;\n          k = (e = this.graphic || e) && e.visibility || \"inherit\";\n          a && a.size && e && \"hidden\" !== k && !this.isCluster ? (t || (d.halo = t = b.renderer.path().add(e.parentGroup)), t.show()[f ? \"animate\" : \"attr\"]({\n            d: this.haloPath(a.size)\n          }), t.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + h(this.colorIndex, d.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: k,\n            zIndex: -1\n          }), t.point = this, b.styledMode || t.attr(q({\n            fill: this.color || d.color,\n            \"fill-opacity\": a.opacity\n          }, a.attributes))) : t && t.point && t.point.haloPath && t.animate({\n            d: t.point.haloPath(0)\n          }, null, t.hide);\n          K(this, \"afterSetState\");\n        }\n      },\n      haloPath: function haloPath(a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      }\n    });\n    q(y.prototype, {\n      onMouseOver: function onMouseOver() {\n        var a = this.chart,\n            f = a.hoverSeries;\n        a.pointer.setHoverChartIndex();\n        if (f && f !== this) f.onMouseOut();\n        this.options.events.mouseOver && K(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      },\n      onMouseOut: function onMouseOut() {\n        var a = this.options,\n            f = this.chart,\n            g = f.tooltip,\n            h = f.hoverPoint;\n        f.hoverSeries = null;\n        if (h) h.onMouseOut();\n        this && a.events.mouseOut && K(this, \"mouseOut\");\n        !g || this.stickyTracking || g.shared && !this.noSharedTooltip || g.hide();\n        f.series.forEach(function (a) {\n          a.setState(\"\", !0);\n        });\n      },\n      setState: function setState(a, f) {\n        var d = this,\n            g = d.options,\n            k = d.graph,\n            l = g.inactiveOtherPoints,\n            m = g.states,\n            n = g.lineWidth,\n            p = g.opacity,\n            e = h(m[a || \"normal\"] && m[a || \"normal\"].animation, d.chart.options.chart.animation);\n        g = 0;\n        a = a || \"\";\n\n        if (d.state !== a && ([d.group, d.markerGroup, d.dataLabelsGroup].forEach(function (c) {\n          c && (d.state && c.removeClass(\"highcharts-series-\" + d.state), a && c.addClass(\"highcharts-series-\" + a));\n        }), d.state = a, !d.chart.styledMode)) {\n          if (m[a] && !1 === m[a].enabled) return;\n          a && (n = m[a].lineWidth || n + (m[a].lineWidthPlus || 0), p = h(m[a].opacity, p));\n          if (k && !k.dashstyle) for (m = {\n            \"stroke-width\": n\n          }, k.animate(m, e); d[\"zone-graph-\" + g];) {\n            d[\"zone-graph-\" + g].attr(m), g += 1;\n          }\n          l || [d.group, d.markerGroup, d.dataLabelsGroup, d.labelBySeries].forEach(function (a) {\n            a && a.animate({\n              opacity: p\n            }, e);\n          });\n        }\n\n        f && l && d.points && d.setAllPointsToState(a);\n      },\n      setAllPointsToState: function setAllPointsToState(a) {\n        this.points.forEach(function (d) {\n          d.setState && d.setState(a);\n        });\n      },\n      setVisible: function setVisible(a, f) {\n        var d = this,\n            g = d.chart,\n            h = d.legendItem,\n            k = g.options.chart.ignoreHiddenSeries,\n            l = d.visible;\n        var m = (d.visible = a = d.options.visible = d.userOptions.visible = \"undefined\" === typeof a ? !l : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (d[a]) d[a][m]();\n        });\n        if (g.hoverSeries === d || (g.hoverPoint && g.hoverPoint.series) === d) d.onMouseOut();\n        h && g.legend.colorizeItem(d, a);\n        d.isDirty = !0;\n        d.options.stacking && g.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        d.linkedSeries.forEach(function (d) {\n          d.setVisible(a, !1);\n        });\n        k && (g.isDirtyBox = !0);\n        K(d, m);\n        !1 !== f && g.redraw();\n      },\n      show: function show() {\n        this.setVisible(!0);\n      },\n      hide: function hide() {\n        this.setVisible(!1);\n      },\n      select: function select(a) {\n        this.selected = a = this.options.selected = \"undefined\" === typeof a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        K(this, a ? \"select\" : \"unselect\");\n      },\n      drawTracker: g.drawTrackerGraph\n    });\n  });\n  O(n, \"Core/Responsive.js\", [n[\"Core/Chart/Chart.js\"], n[\"Core/Utilities.js\"]], function (f, a) {\n    var n = a.find,\n        y = a.isArray,\n        D = a.isObject,\n        G = a.merge,\n        C = a.objectEach,\n        J = a.pick,\n        H = a.splat,\n        v = a.uniqueKey;\n\n    f.prototype.setResponsive = function (a, f) {\n      var q = this.options.responsive,\n          y = [],\n          p = this.currentResponsive;\n      !f && q && q.rules && q.rules.forEach(function (a) {\n        \"undefined\" === typeof a._id && (a._id = v());\n        this.matchResponsiveRule(a, y);\n      }, this);\n      f = G.apply(0, y.map(function (a) {\n        return n(q.rules, function (f) {\n          return f._id === a;\n        }).chartOptions;\n      }));\n      f.isResponsiveOptions = !0;\n      y = y.toString() || void 0;\n      y !== (p && p.ruleIds) && (p && this.update(p.undoOptions, a, !0), y ? (p = this.currentOptions(f), p.isResponsiveOptions = !0, this.currentResponsive = {\n        ruleIds: y,\n        mergedOptions: f,\n        undoOptions: p\n      }, this.update(f, a, !0)) : this.currentResponsive = void 0);\n    };\n\n    f.prototype.matchResponsiveRule = function (a, f) {\n      var n = a.condition;\n      (n.callback || function () {\n        return this.chartWidth <= J(n.maxWidth, Number.MAX_VALUE) && this.chartHeight <= J(n.maxHeight, Number.MAX_VALUE) && this.chartWidth >= J(n.minWidth, 0) && this.chartHeight >= J(n.minHeight, 0);\n      }).call(this) && f.push(a._id);\n    };\n\n    f.prototype.currentOptions = function (a) {\n      function f(a, q, v, u) {\n        var m;\n        C(a, function (a, l) {\n          if (!u && -1 < n.collectionsWithUpdate.indexOf(l)) for (a = H(a), v[l] = [], m = 0; m < Math.max(a.length, q[l].length); m++) {\n            q[l][m] && (void 0 === a[m] ? v[l][m] = q[l][m] : (v[l][m] = {}, f(a[m], q[l][m], v[l][m], u + 1)));\n          } else D(a) ? (v[l] = y(a) ? [] : {}, f(a, q[l] || {}, v[l], u + 1)) : v[l] = \"undefined\" === typeof q[l] ? null : q[l];\n        });\n      }\n\n      var n = this,\n          v = {};\n      f(a, this.options, v, 0);\n      return v;\n    };\n  });\n  O(n, \"masters/highcharts.src.js\", [n[\"Core/Globals.js\"]], function (f) {\n    return f;\n  });\n  n[\"masters/highcharts.src.js\"]._modules = n;\n  return n[\"masters/highcharts.src.js\"];\n});","map":null,"metadata":{},"sourceType":"script"}